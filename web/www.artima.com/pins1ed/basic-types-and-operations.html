<html>
<head>
<title>Basic Types and Operations</title>
<meta name="description" content="
" />
<meta name="keywords" content="scala" />
<meta name="author" content="Martin Odersky, Lex Spoon, and Bill Venners" />
<link rel="stylesheet" type="text/css" href="/artima.css" />
<link rel="shortcut icon" href="/favicon.ico" />
</head>
<body><table width="100%" cellspacing="0">
<tr>
<td align="left" valign="bottom">
<a href="/index.jsp"><img src="/images/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43" /></a>
</td>
</table>
<table width="100%" bgcolor="#333333">
<tr>
<td align="center">
<div class="ml">
<a href="/articles" class="hl">Articles</a>&nbsp;|
<a href="/news/index.jsp" class="hl">News</a>&nbsp;|
<a href="/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;|
<a href="/buzz/index.jsp" class="hl">Buzz</a>&nbsp;|
<a href="/shop/catalog" class="hl">Books</a>&nbsp;|
<a href="/forums/index.jsp" class="hl">Forums</a>
</div>
</td>
</tr>
</table>
<table width="100%" bgcolor="#AACCFF">
<tr>
<td align="center">
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/basic-types-and-operationsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/classes-and-objects.html">Previous</a>&nbsp;| 
<a href="/pins1ed/functional-objects.html">Next</a>
</div>
</td>
</tr>
</table>
<BR>
<div class="vegies">
<div class="tc">
<span class="sts">Chapter 5 of Programming in Scala, First Edition</span><br />
<span class="ts">Basic Types and Operations</span><br />
<span class="as">by Martin Odersky, Lex Spoon, and Bill Venners</span><br />
<span class="pd">December 10, 2008</span><br />
</div>




<p>Now that you've seen classes and objects in action, it's a good time to look at Scala's
basic types and operations in more depth.
If you're familiar with Java, you'll be glad to find that Java's basic
types and operators have the same meaning in Scala. However there
are some interesting differences that will make this chapter worthwhile reading even
if you're an experienced Java developer. Because some of the aspects of Scala
covered in this chapter are essentially the same in Java, we've inserted notes
indicating what Java developers can safely skip, to expedite your
progress.</p>

<p>In this chapter, you'll get an overview of Scala's basic types,
including <span class="code">String</span>s and the value types <span class="code">Int</span>, <span class="code">Long</span>, <span class="code">Short</span>,
<span class="code">Byte</span>, <span class="code">Float</span>, <span class="code">Double</span>, <span class="code">Char</span>, and <span class="code">Boolean</span>. You'll learn
the operations you can perform on these types, including how operator
precedence works in Scala expressions. You'll also learn
how implicit conversions can "enrich" variants of these basic types, giving
you additional operations beyond those supported by Java.</p>

<h3><a name="5.1"></a>5.1 Some basic types <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.1">link</a>]</span></h3>


<p>Several fundamental types of Scala, along with the ranges of values instances of
these types may
have, are shown in <a href="basic-types-and-operations.html#tab:valtypes">Table 5.1</a>.
Collectively, types <span class="code">Byte</span>,<a id="i1013322880-1"></a>
<span class="code">Short</span>,<a id="i1149344948-1"></a> <span class="code">Int</span>,<a id="i517506535-1"></a>
<span class="code">Long</span>,<a id="i-149056780-1"></a> and <span class="code">Char</span><a id="i1377752142-1"></a> are
called <em>integral types</em>.<a id="i-1495655539-1"></a> The integral types plus
<span class="code">Float</span><a id="i-1609149804-1"></a> and <span class="code">Double</span><a id="i-265180023-1"></a>
are called <em>numeric types</em>.<a id="i-404482804-1"></a></p>

<p><a name="tab:valtypes"></a></p>

<h5>Table 5.1 - Some basic types<a id="i608338568-1"></a></h5>


<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Value type</span></span>
  </td>
  <td>
<div align="center"><span style="font-size:medium"><span style="font-weight:bold">Range</span></span>
</div>


  </td>
</tr>
<tr class="topline ">
  <td>
    <span class="code"><span class="typename">Byte</span></span>
  </td>
  <td>
    <span style="font-size:small">8-bit signed two's complement integer (-2<sup>7</sup> to 2<sup>7</sup> - 1, inclusive)</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Short</span></span>
  </td>
  <td>
    <span style="font-size:small">16-bit signed two's complement integer (-2<sup>15</sup> to 2<sup>15</sup> - 1, inclusive)</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Int</span></span>
  </td>
  <td>
    <span style="font-size:small">32-bit signed two's complement integer (-2<sup>31</sup> to 2<sup>31</sup> - 1, inclusive)</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Long</span></span>
  </td>
  <td>
    <span style="font-size:small">64-bit signed two's complement integer (-2<sup>63</sup> to 2<sup>63</sup> - 1, inclusive)</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Char</span></span>
  </td>
  <td>
    <span style="font-size:small">16-bit unsigned Unicode character (0 to 2<sup>16</sup> - 1, inclusive)</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">String</span></span>
  </td>
  <td>
    <span style="font-size:small">a sequence of <span class="code">Char</span>s</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Float</span></span>
  </td>
  <td>
    <span style="font-size:small">32-bit IEEE 754 single-precision float</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Double</span></span>
  </td>
  <td>
    <span style="font-size:small">64-bit IEEE 754 double-precision float</span>
  </td>
</tr>
<tr class="bottomline">
  <td>
    <span class="code"><span class="typename">Boolean</span></span>
  </td>
  <td>
    <span style="font-size:small"><span class="code">true</span> or <span class="code">false</span></span>
  </td>
</tr>
</table>


<p>Other than <span class="code">String</span>, which resides in package <span class="code">java.lang</span>, all of the types shown
in <a href="basic-types-and-operations.html#tab:valtypes">Table 5.1</a> are members of package
<span class="code">scala</span>.<a href="basic-types-and-operations.html#footnote5-1">[1]</a> For example, the full name of <span class="code">Int</span> is <span class="code">scala.Int</span>.
However, given that all the members of package <span class="code">scala</span> and <span class="code">java.lang</span> are automatically imported into every Scala source file,
you can just use the simple names (<i>i.e.</i>, names like
<span class="code">Boolean</span>,<a id="i1148427104-1"></a> <span class="code">Char</span>, or
<span class="code">String</span><a id="i-1230806839-1"></a>) everywhere.</p>

<div class="note">
<h4>Note</h4>
You can in fact
currently use lower case aliases<a id="i-768099765-1"></a><a id="i-621629083-1"></a> for Scala value types, which correspond to Java's primitive types.
For example, you can say <span class="code">int</span> instead of <span class="code">Int</span> in a Scala program. But keep in mind they both mean exactly the same thing: <span class="code">scala.Int</span>.
The recommended style that arose from the experience of the Scala community is to always use the upper case form, which is what we do
in this book. In honor of this community-driven choice, the lower case variants may be deprecated or even removed in a future
version of Scala, so you would be wise indeed to go with the community flow and say <span class="code">Int</span>, not <span class="code">int</span>, in your Scala code.


</div>


<p>Savvy Java developers will note that Scala's basic types have the exact same ranges as the corresponding types in Java.
This enables the Scala compiler to transform instances of Scala <a href="glossary.html#g1985162377"><em>value types</em></a>, such as <span class="code">Int</span> or <span class="code">Double</span>, down to Java primitive types
in the bytecodes it produces.</p>

<h3><a name="5.2"></a>5.2 Literals <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.2">link</a>]</span></h3>


<p><a name="sec:literals"></a></p>

<p>All of the basic types listed in <a href="basic-types-and-operations.html#tab:valtypes">Table 5.1</a> can be written with <a href="glossary.html#g182460591"><em>literals</em></a>.  A
literal is a way to write a constant value directly in
code.<a id="i1361311140-1"></a></p>

<div class="pointofinterest">
<h3>Fast track for Java programmers</h3>


<p>The syntax of most literals shown in this section are exactly the same
as in Java, so if you're a Java master, you can safely skip much of this section. The
two differences you should read about are Scala's literals for raw strings and
symbols, which are described starting <a href="basic-types-and-operations.html#sec:string-literals">here</a>.</p>

</div>


<h4>Integer literals</h4>


<p>Integer literals for the types <span class="code">Int</span>, <span class="code">Long</span>, <span class="code">Short</span>, and <span class="code">Byte</span> come in three forms: decimal, hexadecimal, and octal. The way an integer literal begins indicates the
base of the number. If the number begins with a <span class="code">0x</span> or <span class="code">0X</span>, it is hexadecimal (base 16), and may contain <span class="code">0</span> through <span class="code">9</span> as well as upper or lowercase
digits <span class="code">A</span> through <span class="code">F</span>.
Some examples are:<a id="i-168837784-1"></a><a id="i208067142-1"></a></p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;hex&nbsp;=&nbsp;<span class="literal">0x5</span>
  <span class="output">hex:&nbsp;Int&nbsp;=&nbsp;5</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;hex2&nbsp;=&nbsp;<span class="literal">0x00FF</span>
  <span class="output">hex2:&nbsp;Int&nbsp;=&nbsp;255</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;magic&nbsp;=&nbsp;<span class="literal">0xcafebabe</span>
  <span class="output">magic:&nbsp;Int&nbsp;=&nbsp;-889275714</span>
</pre><!-- -->


<p>Note that the Scala shell always prints integer values in base 10, no matter what literal form you may have
used to initialize it. Thus the interpreter displays the value of the <span class="code">hex2</span> variable you initialized with literal <span class="code">0x00FF</span>
as decimal 255. (Of course, you don't need to take our word for it. A good way to start getting a feel for the language is to
try these statements out in the interpreter as you read this chapter.)
If the number begins with a zero, it is octal (base 8), and may, therefore, only contain digits <span class="code">0</span> through <span class="code">7</span>. Some examples are:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;oct&nbsp;=&nbsp;<span class="literal">035</span>&nbsp;&nbsp;<span class="comment">//&nbsp;(35&nbsp;octal&nbsp;is&nbsp;29&nbsp;decimal)</span>
  <span class="output">oct:&nbsp;Int&nbsp;=&nbsp;29</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;nov&nbsp;=&nbsp;<span class="literal">0777</span>
  <span class="output">nov:&nbsp;Int&nbsp;=&nbsp;511</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;dec&nbsp;=&nbsp;<span class="literal">0321</span>
  <span class="output">dec:&nbsp;Int&nbsp;=&nbsp;209</span>
</pre><!-- -->


<p>If the number begins with a non-zero digit, and is otherwise undecorated,
it is decimal (base 10). For example:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;dec1&nbsp;=&nbsp;<span class="literal">31</span>
  <span class="output">dec1:&nbsp;Int&nbsp;=&nbsp;31</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;dec2&nbsp;=&nbsp;<span class="literal">255</span>
  <span class="output">dec2:&nbsp;Int&nbsp;=&nbsp;255</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;dec3&nbsp;=&nbsp;<span class="literal">20</span>
  <span class="output">dec3:&nbsp;Int&nbsp;=&nbsp;20</span>
</pre><!-- -->


<p>If an integer literal ends in an <span class="code">L</span> or <span class="code">l</span>, it is a <span class="code">Long</span>, otherwise it is an <span class="code">Int</span>. Some examples of
<span class="code">Long</span> integer literals are:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;prog&nbsp;=&nbsp;<span class="literal">0XCAFEBABEL</span>
  <span class="output">prog:&nbsp;Long&nbsp;=&nbsp;3405691582</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;tower&nbsp;=&nbsp;<span class="literal">35L</span>
  <span class="output">tower:&nbsp;Long&nbsp;=&nbsp;35</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;of&nbsp;=&nbsp;<span class="literal">31l</span>
  <span class="output">of:&nbsp;Long&nbsp;=&nbsp;31</span>
</pre><!-- -->


<p>If an <span class="code">Int</span> literal is assigned to a variable of type <span class="code">Short</span> or
<span class="code">Byte</span>, the literal is treated as if it were a <span class="code">Short</span> or <span class="code">Byte</span> type so long as the literal value is within the valid range for that type.
For example:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;little:&nbsp;<span class="typename">Short</span>&nbsp;=&nbsp;<span class="literal">367</span>
  <span class="output">little:&nbsp;Short&nbsp;=&nbsp;367</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;littler:&nbsp;<span class="typename">Byte</span>&nbsp;=&nbsp;<span class="literal">38</span>
  <span class="output">littler:&nbsp;Byte&nbsp;=&nbsp;38</span>
</pre><!-- -->


<h4>Floating point literals</h4>


<p>Floating point literals are made up of decimal digits, optionally containing a decimal point, and optionally followed by an <span class="code">E</span> or <span class="code">e</span>
and an exponent. Some examples of floating-point literals are:<a id="i1661236620-1"></a><a id="i2064554715-1"></a></p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;big&nbsp;=&nbsp;<span class="literal">1.2345</span>
  <span class="output">big:&nbsp;Double&nbsp;=&nbsp;1.2345</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;bigger&nbsp;=&nbsp;<span class="literal">1.2345e1</span>
  <span class="output">bigger:&nbsp;Double&nbsp;=&nbsp;12.345</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;biggerStill&nbsp;=&nbsp;<span class="literal">123E45</span>
  <span class="output">biggerStill:&nbsp;Double&nbsp;=&nbsp;1.23E47</span>
</pre><!-- -->


<p>Note that the exponent portion means the power of 10 by which the other portion is multiplied. Thus, 1.2345e1 is 1.2345 <i>times</i> 10<sup>1</sup>, which
is 12.345. If a floating-point literal ends in an <span class="code">F</span> or <span class="code">f</span>, it is a <span class="code">Float</span>, otherwise it is a <span class="code">Double</span>. Optionally, a <span class="code">Double</span> floating-point literal can
end in <span class="code">D</span> or <span class="code">d</span>. Some examples of <span class="code">Float</span> literals are:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;little&nbsp;=&nbsp;<span class="literal">1.2345F</span>
  <span class="output">little:&nbsp;Float&nbsp;=&nbsp;1.2345</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;littleBigger&nbsp;=&nbsp;<span class="literal">3e5f</span>
  <span class="output">littleBigger:&nbsp;Float&nbsp;=&nbsp;300000.0</span>
</pre><!-- -->


<p>That last value expressed as a <span class="code">Double</span> could
take these (and other) forms:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;anotherDouble&nbsp;=&nbsp;<span class="literal">3e5</span>
  <span class="output">anotherDouble:&nbsp;Double&nbsp;=&nbsp;300000.0</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;yetAnother&nbsp;=&nbsp;<span class="literal">3e5D</span>
  <span class="output">yetAnother:&nbsp;Double&nbsp;=&nbsp;300000.0</span>
</pre><!-- -->


<h4>Character literals</h4>


<p>Character literals are composed of any Unicode character between single
quotes, such as:<a id="i1377637053-1"></a><a id="i2027394259-1"></a><a id="i-197420869-1"></a><a id="i-2096980664-1"></a></p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;a&nbsp;=&nbsp;<span class="quotedstring">'A'</span>
  <span class="output">a:&nbsp;Char&nbsp;=&nbsp;A</span>
</pre><!-- -->


<p>In addition to providing an explicit character between the single quotes, you can provide an octal or hex number for the character code point preceded by a
backslash. The octal number must be between <span class="code">'\0'</span> and <span class="code">'\377'</span>. For example, the Unicode character code point for the letter A is 101 octal. Thus:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;c&nbsp;=&nbsp;<span class="quotedstring">'\101'</span>
  <span class="output">c:&nbsp;Char&nbsp;=&nbsp;A</span>
</pre><!-- -->


<p>A character literal can also be given as a general Unicode character consisting
of four hex digits and preceded by a <span class="code">\u</span>, as in:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;d&nbsp;=&nbsp;<span class="quotedstring">'\u0041'</span>
  <span class="output">d:&nbsp;Char&nbsp;=&nbsp;A</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;f&nbsp;=&nbsp;<span class="quotedstring">'\u0044'</span>
  <span class="output">f:&nbsp;Char&nbsp;=&nbsp;D</span>
</pre><!-- -->
In fact, such Unicode characters can appear anywhere in a Scala program. For instance
you could also write an identifier like this:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;B\u0041\u0044&nbsp;=&nbsp;<span class="literal">1</span>
  <span class="output">BAD:&nbsp;Int&nbsp;=&nbsp;1</span>
</pre><!-- -->
This identifier is treated as identical to <span class="code">BAD</span>, the result of expanding the two Unicode
characters in the code above. In general, it is a bad idea to name identifiers like
this, because it is hard to read. Rather, this syntax is intended to allow Scala
source files that include non-ASCII Unicode characters to be represented in ASCII.


<p>Finally, there are also a few character literals represented by special escape sequences, shown in <a href="basic-types-and-operations.html#tab:specchar">Table 5.2</a>.
For example:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;backslash&nbsp;=&nbsp;<span class="quotedstring">'\\'</span>
  <span class="output">backslash:&nbsp;Char&nbsp;=&nbsp;\</span>
</pre><!-- --></p>

<p><a name="tab:specchar"></a></p>

<h5>Table 5.2 - Special character literal escape sequences<a id="i-1682237230-1"></a><a id="i576133849-1"></a></h5>


<div align="center">
<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Literal</span></span>
  </td>
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Meaning</span></span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span class="code">\n</span>
  </td>
  <td>
    line feed (<span class="code">\u000A</span>)
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">\b</span>
  </td>
  <td>
    backspace (<span class="code">\u0008</span>)
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">\t</span>
  </td>
  <td>
    tab (<span class="code">\u0009</span>)
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">\f</span>
  </td>
  <td>
    form feed (<span class="code">\u000C</span>)
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">\r</span>
  </td>
  <td>
    carriage return (<span class="code">\u000D</span>)
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">\"</span>
  </td>
  <td>
    double quote (<span class="code">\u0022</span>)
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">\'</span>
  </td>
  <td>
    single quote (<span class="code">\u0027</span>)
  </td>
</tr>
<tr class="bottomline">
  <td>
    <span class="code">\\</span>
  </td>
  <td>
    backslash (<span class="code">\u005C</span>)
  </td>
</tr>
</table>


</div>


<h4>String literals</h4>


<p><a name="sec:string-literals"></a></p>

<p>A string literal is composed of characters surrounded by double quotes:<a id="i-2068973913-1"></a><a id="i1483927337-1"></a><a id="i1349528476-1"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;hello&nbsp;=&nbsp;<span class="quotedstring">"hello"</span>
  <span class="output">hello:&nbsp;java.lang.String&nbsp;=&nbsp;hello</span>
</pre><!-- -->
The syntax of the characters within the quotes is the same as with
character literals.  For example: 
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;escapes&nbsp;=&nbsp;<span class="quotedstring">"\\\"\'"</span>
  <span class="output">escapes:&nbsp;java.lang.String&nbsp;=&nbsp;\"'</span>
</pre><!-- --></p>

<p>Because this syntax is awkward for strings that contain a lot of escape
sequences or strings that span multiple lines, Scala
includes a special syntax for <span style="font-style:italic">raw
strings</span>.<a id="i-1493588176-1"></a><a id="i1433882250-1"></a><a id="i943241332-1"></a>  You start and end a
raw string with three double quotation marks in a row (<span class="code">"""</span>).  The
interior of a raw string may contain any characters whatsoever,
including newlines, quotation marks, and special characters, except of
course three quotes in a row.  For example, the following program
prints out a message using a raw string:<a id="i-1356616527-1"></a>
<pre>
  println(<span class="quotedstring">"""Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">Type&nbsp;"HELP"&nbsp;for&nbsp;help."""</span>)
</pre><!-- -->
Running this code does not produce quite what is desired, however:</p>

<pre>
  <span class="output">Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;"HELP"&nbsp;for&nbsp;help.</span>
</pre><!-- -->
The issue is that the leading spaces before the second line are
included in the string!  To help with this common situation, you can
call <span class="code">stripMargin</span> on
strings.<a id="i-696378315-1"></a>  To use this
method, put a pipe character (<span class="code">|</span>) at the front of each line, and
then call <span class="code">stripMargin</span> on the whole string:
<pre>
  println(<span class="quotedstring">"""|Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">|Type&nbsp;"HELP"&nbsp;for&nbsp;help."""</span>.stripMargin)
</pre><!-- -->
Now the code behaves as desired:


<pre>
  <span class="output">Welcome&nbsp;to&nbsp;Ultamix&nbsp;3000.</span>
  <span class="output">Type&nbsp;"HELP"&nbsp;for&nbsp;help.</span>
</pre><!-- -->


<h4>Symbol literals</h4>


<p>A symbol literal is written <span class="code">'</span><em>ident</em>, where <em>ident</em> can be any
alphanumeric identifier.
Such literals are mapped to instances of the predefined
class <span class="code">scala.Symbol</span>. Specifically, the literal <span class="code">'cymbal</span> will be expanded
by the compiler to a factory method invocation: <span class="code">Symbol("cymbal")</span>.  Symbol literals are typically used in
situations where you would use just an identifier in a dynamically<a id="i2012339474-4"></a><a id="i716433724-4"></a>
typed language.<a id="i-2064511954-1"></a><a id="i386345772-1"></a> For instance, you might want to define a method
that updates a record in a database:
<pre>
  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;updateRecordByName(r:&nbsp;<span class="typename">Symbol</span>,&nbsp;value:&nbsp;<span class="typename">Any</span>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;code&nbsp;goes&nbsp;here</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <span class="output">updateRecordByName:&nbsp;(Symbol,Any)Unit</span>
</pre><!-- -->
The method takes as parameters a symbol indicating the name of a record 
field and a value with which the field should be updated in the record. 
In a dynamically typed language, you could invoke this operation
passing an undeclared field identifier to the method, 
but in Scala this would not compile:<a id="i138103638-1"></a><!-- -->
<pre>
  scala&gt;&nbsp;updateRecordByName(favoriteAlbum,&nbsp;<span class="quotedstring">"OK&nbsp;Computer"</span>)
  <span class="output">&lt;console&gt;:6:&nbsp;error:&nbsp;not&nbsp;found:&nbsp;value&nbsp;favoriteAlbum</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateRecordByName(favoriteAlbum,&nbsp;"OK&nbsp;Computer")</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^&nbsp;&nbsp;</span>
</pre><!-- --></p>

<p>Instead, and almost as concisely, you can pass a symbol literal:<!-- -->
<pre>
  scala&gt;&nbsp;updateRecordByName(<span class="quotedstring">'favoriteAlbum</span>,&nbsp;<span class="quotedstring">"OK&nbsp;Computer"</span>)
</pre><!-- -->
There is not much you can do with a symbol, except
find out its name:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;s&nbsp;=&nbsp;<span class="quotedstring">'aSymbol</span>
  <span class="output">s:&nbsp;Symbol&nbsp;=&nbsp;'aSymbol</span>
  <br />  scala&gt;&nbsp;s.name
  <span class="output">res20:&nbsp;String&nbsp;=&nbsp;aSymbol</span>
</pre><!-- -->
Another thing that's noteworthy is that symbols are <span style="font-style:italic">interned</span>. If you 
write the same symbol literal twice, both expressions will refer to the exact same <span class="code">Symbol</span> object.</p>

<h4>Boolean literals</h4>
 The <span class="code">Boolean</span> type has two literals,
<span class="code">true</span> and <span class="code">false</span>:<a id="i-2062178222-1"></a><a id="i594122396-1"></a><a id="i907417652-1"></a><a id="i1304901727-1"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;bool&nbsp;=&nbsp;<span class="vem">true</span>&nbsp;
  <span class="output">bool:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;fool&nbsp;=&nbsp;<span class="vem">false</span>
  <span class="output">fool:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- -->


<p>That's all there is to it. You are now
literally<a href="basic-types-and-operations.html#footnote5-2">[2]</a> an expert in Scala.</p>

<h3><a name="5.3"></a>5.3 Operators are methods <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.3">link</a>]</span></h3>


<p><a name="sec:operators"></a></p>

<p>Scala provides a rich set of operators for its basic
types.
As mentioned in previous chapters, these operators are
actually just a nice syntax for ordinary method calls.  For example,
<span class="code">1</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> really means the same thing as <span class="code">(1).+(2)</span>.<a id="i-614149608-2"></a> In other words,
class <span class="code">Int</span> contains a method named <span class="code">+</span> that takes an <span class="code">Int</span> and
returns an <span class="code">Int</span> result.  This <span class="code">+</span> method is 
invoked when you add two <span class="code">Int</span>s:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;sum&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;+&nbsp;<span class="literal">2</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;(1).+(2)</span>
  <span class="output">sum:&nbsp;Int&nbsp;=&nbsp;3</span>
</pre><!-- -->


<p>To prove this to yourself, you can<!-- --> write the expression explicitly as a method invocation:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;sumMore&nbsp;=&nbsp;(<span class="literal">1</span>).+(<span class="literal">2</span>)&nbsp;
  <span class="output">sumMore:&nbsp;Int&nbsp;=&nbsp;3</span>
</pre><!-- -->


<p>In fact, <span class="code">Int</span> contains several
<em>overloaded</em> <span class="code">+</span> methods that take different parameter
types.<a href="basic-types-and-operations.html#footnote5-3">[3]</a>
For example, <span class="code">Int</span> has another method, also named <span class="code">+</span>,
that takes and returns a <span class="code">Long</span>. If you
add a <span class="code">Long</span> to an <span class="code">Int</span>, this alternate <span class="code">+</span> method will be invoked, as in:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;longSum&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;+&nbsp;<span class="literal">2L</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;(1).+(2L)</span>
  <span class="output">longSum:&nbsp;Long&nbsp;=&nbsp;3</span>
</pre><!-- -->
The <span class="code">+</span> symbol is an operator&mdash;an infix operator to be specific.<a id="i145517742-1"></a><a id="i-74898194-1"></a>
Operator notation is not limited to methods like <span class="code">+</span> that look like
operators in other languages. You can use <em>any</em> method in operator
notation.<a id="i-1126677335-1"></a>
For example, class <span class="code">String</span> has a method, <span class="code">indexOf</span>, that takes one <span class="code">Char</span> parameter. The <span class="code">indexOf</span> method searches the string for the first occurrence
of the specified character, and returns its index or <span class="code">-1</span> if it doesn't find the character.
You can use <span class="code">indexOf</span> as an
operator, like this:


<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;s&nbsp;=&nbsp;<span class="quotedstring">"Hello,&nbsp;world!"</span>&nbsp;
  <span class="output">s:&nbsp;java.lang.String&nbsp;=&nbsp;Hello,&nbsp;world!</span>
  <br />  scala&gt;&nbsp;s&nbsp;indexOf&nbsp;<span class="quotedstring">'o'</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;s.indexOf('o')</span>
  <span class="output">res0:&nbsp;Int&nbsp;=&nbsp;4</span>
</pre><!-- -->


<p>In addition, <span class="code">String</span> offers an overloaded <span class="code">indexOf</span> method that takes two parameters, the character for which to search 
and an index at which to start. (The other <span class="code">indexOf</span> method, shown previously, starts at index zero, the beginning of the <span class="code">String</span>.) Even though this <span class="code">indexOf</span>
method takes two arguments, you can use it in operator notation. But whenever you call a method that takes multiple
arguments using operator notation, you have to place those arguments in parentheses. For example, here's how you use this other 
<span class="code">indexOf</span> form as an operator (continuing from the previous example):</p>

<pre>
  scala&gt;&nbsp;s&nbsp;indexOf&nbsp;(<span class="quotedstring">'o'</span>,&nbsp;<span class="literal">5</span>)&nbsp;<span class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;s.indexOf('o',&nbsp;5)</span>
  <span class="output">res1:&nbsp;Int&nbsp;=&nbsp;8</span>
</pre><!-- -->


<div class="aside">
<h3>Any method can be an operator</h3>


<p>In Scala operators are not special language syntax: any method can be an operator. What makes a method an operator is how you <em>use</em> it.
When you write "<span class="code">s.indexOf('o')</span>", <span class="code">indexOf</span> is not an operator. But when
you write "<span class="code">s</span>&nbsp;<span class="code">indexOf</span>&nbsp;<span class="code">'o'</span>", <span class="code">indexOf</span> <em>is</em> an operator, because you're using
it in operator notation.</p>

</div>


<p>So far, you've seen examples of <em>infix</em> operator notation, which means
the method to invoke sits between the object and the parameter or parameters you
wish to pass to the method, as in "<span class="code">7</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>".
Scala also has two other operator notations: prefix and postfix.
In prefix notation, you put the method name before the object on which you
are invoking the method, for example, the `<span class="code">-</span>' in <span class="code">-7</span>. In postfix
notation, you put the method after the object, for example, the "<span class="code">toLong</span>"
in "<span class="code">7</span>&nbsp;<span class="code">toLong</span>".</p>

<p>In contrast to the infix operator notation&mdash;in which operators take two operands, one to the left and the other to the right&mdash;prefix and postfix
operators are <em>unary</em>: they take just one operand.<a id="i-1088310403-1"></a> In prefix notation, the operand is to the right of the operator.<a id="i711311856-1"></a><a id="i-2117778892-1"></a>
Some examples of prefix operators are <span class="code">-2.0</span>, <span class="code">!found</span>, and <span class="code"><span style="font-size:large">~</span>0xFF</span>. As with the
infix operators, these prefix operators are a shorthand way of invoking methods. In this case,
however, the name of the method has "<span class="code">unary_</span>" prepended to the operator character. For instance, Scala will transform the expression <span class="code">-2.0</span> into
the method invocation "<span class="code">(2.0).unary_-</span>".  You can demonstrate this to yourself by typing the method call both via operator notation and explicitly:</p>

<pre>
  scala&gt;&nbsp;-<span class="literal">2.0</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Scala&nbsp;invokes&nbsp;(2.0).unary_-</span>
  <span class="output">res2:&nbsp;Double&nbsp;=&nbsp;-2.0</span>
  <br />  scala&gt;&nbsp;(<span class="literal">2.0</span>).unary_-
  <span class="output">res3:&nbsp;Double&nbsp;=&nbsp;-2.0</span>
</pre><!-- -->


<p>The only identifiers that can be used as prefix operators are <span class="code">+</span>, <span class="code">-</span>, <span class="code">!</span>, and <span class="code"><span style="font-size:large">~</span></span>. Thus, if you define a method named <span class="code">unary_!</span>, you
could invoke that method on a value or variable of the appropriate type using prefix operator notation, such as <span class="code">!p</span>. But if you define a method
named <span class="code">unary_*</span>, you wouldn't be able to use prefix operator notation, because <span class="code">*</span> isn't one of the four identifiers that can be used as prefix
operators. You could invoke the method normally, as in <span class="code">p.unary_*</span>, but if you attempted to invoke it via <span class="code">*p</span>, Scala will
parse it as if you'd written <span class="code">*.p</span>, which is probably not what you had in mind!<a href="basic-types-and-operations.html#footnote5-4">[4]</a></p>

<p>Postfix operators are methods that take no arguments, when they are
invoked without a dot or parentheses. In Scala, you can leave off
empty parentheses on method calls.<a id="i-1718164274-1"></a><a id="i1976561855-1"></a> The convention is that you include
parentheses if the method has side effects, such as <span class="code">println()</span>, but
you can leave them off if the method has no side effects, such as
<span class="code">toLowerCase</span> invoked on a <span class="code">String</span>:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;s&nbsp;=&nbsp;<span class="quotedstring">"Hello,&nbsp;world!"</span>
  <span class="output">s:&nbsp;java.lang.String&nbsp;=&nbsp;Hello,&nbsp;world!</span>
  <br />  scala&gt;&nbsp;s.toLowerCase&nbsp;
  <span class="output">res4:&nbsp;java.lang.String&nbsp;=&nbsp;hello,&nbsp;world!</span>
</pre><!-- -->


<p>In this latter case of a method that requires no arguments, you can alternatively leave off the dot and
use postfix operator notation:<a id="i797797395-1"></a><a id="i-1299180525-1"></a></p>

<pre>
  scala&gt;&nbsp;s&nbsp;toLowerCase
  <span class="output">res5:&nbsp;java.lang.String&nbsp;=&nbsp;hello,&nbsp;world!</span>
</pre><!-- -->


<p>In this case, <span class="code">toLowerCase</span> is used as a postfix operator on the operand <span class="code">s</span>.</p>

<p>To see what operators you can use with Scala's basic types, therefore, all you really need
to do is look at the methods declared in the type's classes in the Scala API documentation. Given that this is a Scala tutorial, however,
we'll give you a quick tour of most of these methods in the next few sections.</p>

<div class="pointofinterest">
<h3>Fast track for Java programmers</h3>


<p>Many aspects of Scala described in the remainder of this chapter
are the same as in Java.
If you're a Java guru in a rush, you can 
safely skip to <a href="basic-types-and-operations.html#sec:equality">Section 5.7</a> <a href="basic-types-and-operations.html#sec:equality">here</a>, which
describes how Scala differs from Java in the area of object equality.</p>

</div>


<h3><a name="5.4"></a>5.4 Arithmetic operations <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.4">link</a>]</span></h3>


<p>You can invoke arithmetic methods via infix operator notation for<a id="i63774984-1"></a>
addition (<span class="code">+</span>),<a id="i983413923-1"></a> subtraction (<span class="code">-</span>)<a id="i716347441-1"></a>, multiplication
(<span class="code">*</span>)<a id="i-1513393110-1"></a>, division
(<span class="code">/</span>)<a id="i1085968089-1"></a>, and remainder (<span class="code">%</span>)<a id="i277713802-1"></a>, on
any numeric type. Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<span class="literal">1.2</span>&nbsp;+&nbsp;<span class="literal">2.3</span>
  <span class="output">res6:&nbsp;Double&nbsp;=&nbsp;3.5</span>
  <br />  scala&gt;&nbsp;<span class="literal">3</span>&nbsp;-&nbsp;<span class="literal">1</span>
  <span class="output">res7:&nbsp;Int&nbsp;=&nbsp;2</span>
  <br />  scala&gt;&nbsp;<span class="quotedstring">'b'</span>&nbsp;-&nbsp;<span class="quotedstring">'a'</span>
  <span class="output">res8:&nbsp;Int&nbsp;=&nbsp;1</span>
  <br />  scala&gt;&nbsp;<span class="literal">2L</span>&nbsp;*&nbsp;<span class="literal">3L</span>&nbsp;&nbsp;
  <span class="output">res9:&nbsp;Long&nbsp;=&nbsp;6</span>
  <br />  scala&gt;&nbsp;<span class="literal">11</span>&nbsp;/&nbsp;<span class="literal">4</span>&nbsp;&nbsp;&nbsp;
  <span class="output">res10:&nbsp;Int&nbsp;=&nbsp;2</span>
  <br />  scala&gt;&nbsp;<span class="literal">11</span>&nbsp;%&nbsp;<span class="literal">4</span>&nbsp;&nbsp;&nbsp;
  <span class="output">res11:&nbsp;Int&nbsp;=&nbsp;3</span>
  <br />  scala&gt;&nbsp;<span class="literal">11.0f</span>&nbsp;/&nbsp;<span class="literal">4.0f</span>
  <span class="output">res12:&nbsp;Float&nbsp;=&nbsp;2.75</span>
  <br />  scala&gt;&nbsp;<span class="literal">11.0</span>&nbsp;%&nbsp;<span class="literal">4.0</span>&nbsp;&nbsp;
  <span class="output">res13:&nbsp;Double&nbsp;=&nbsp;3.0</span>
</pre><!-- -->


<p>When both the left and right operands are integral types (<span class="code">Int</span>, <span class="code">Long</span>, <span class="code">Byte</span>, <span class="code">Short</span>, or <span class="code">Char</span>), the <span class="code">/</span> operator will tell
you the whole number portion of the quotient, excluding any remainder. The <span class="code">%</span> operator indicates the remainder of an implied integer division.</p>

<p>The floating-point remainder you get with <span class="code">%</span>
is not the one defined by the IEEE 754 standard. The IEEE 754 remainder uses 
rounding division, not truncating division, in calculating the remainder, so it is quite different from the integer remainder operation. If you really
want an IEEE 754 remainder, you can call <span class="code">IEEEremainder</span> on <span class="code">scala.Math</span>, as in:</p>

<pre>
  scala&gt;&nbsp;Math.IEEEremainder(<span class="literal">11.0</span>,&nbsp;<span class="literal">4.0</span>)
  <span class="output">res14:&nbsp;Double&nbsp;=&nbsp;-1.0</span>
</pre><!-- -->


<p>The numeric types also offer unary prefix operators <span class="code">+</span> (method <span class="code">unary_+</span>) and <span class="code">-</span> (method <span class="code">unary_-</span>), which allow you
to indicate a literal number is positive or negative, as in <span class="code">-3</span> or <span class="code">+4.0</span>. If
you don't specify a unary <span class="code">+</span> or <span class="code">-</span>, a literal number is interpreted as positive.
Unary <span class="code">+</span> exists solely for symmetry with unary <span class="code">-</span>, but has no effect.
The unary <span class="code">-</span> can also be used to negate a variable.
Here are some examples:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;neg&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;+&nbsp;-<span class="literal">3</span>
  <span class="output">neg:&nbsp;Int&nbsp;=&nbsp;-2</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;y&nbsp;=&nbsp;+<span class="literal">3</span>
  <span class="output">y:&nbsp;Int&nbsp;=&nbsp;3</span>
  <br />  scala&gt;&nbsp;-neg
  <span class="output">res15:&nbsp;Int&nbsp;=&nbsp;2</span>
</pre><!-- -->


<h3><a name="5.5"></a>5.5 Relational and logical  operations <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.5">link</a>]</span></h3>


<p>You can compare numeric types with relational methods greater than<a id="i-1517365894-1"></a>
(<span class="code">&gt;</span>)<a id="i1603867875-1"></a>, less than (<span class="code">&lt;</span>)<a id="i1911627354-1"></a>, greater
than or equal to (<span class="code">&gt;=</span>)<a id="i-1287376184-1"></a>, and less than or
equal to (<span class="code">&lt;=</span>)<a id="i-299474407-1"></a>, which yield a <span class="code">Boolean</span> result. In
addition, you can use the unary `<span class="code">!</span>' operator (the <span class="code">unary_!</span> method)
to invert a <span class="code">Boolean</span> value.<a id="i1211007643-1"></a><a id="i1148427104-2"></a>  Here are a few examples:</p>

<pre>
  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;&gt;&nbsp;<span class="literal">2</span>&nbsp;
  <span class="output">res16:&nbsp;Boolean&nbsp;=&nbsp;false</span>
  <br />  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;&lt;&nbsp;<span class="literal">2</span>&nbsp;
  <span class="output">res17:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="literal">1.0</span>&nbsp;&lt;=&nbsp;<span class="literal">1.0</span>&nbsp;&nbsp;
  <span class="output">res18:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="literal">3.5f</span>&nbsp;&gt;=&nbsp;<span class="literal">3.6f</span>&nbsp;&nbsp;
  <span class="output">res19:&nbsp;Boolean&nbsp;=&nbsp;false</span>
  <br />  scala&gt;&nbsp;<span class="quotedstring">'a'</span>&nbsp;&gt;=&nbsp;<span class="quotedstring">'A'</span>&nbsp;
  <span class="output">res20:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;thisIsBoring&nbsp;=&nbsp;!<span class="vem">true</span>&nbsp;
  <span class="output">thisIsBoring:&nbsp;Boolean&nbsp;=&nbsp;false</span>
  <br />  scala&gt;&nbsp;!thisIsBoring&nbsp;&nbsp;&nbsp;
  <span class="output">res21:&nbsp;Boolean&nbsp;=&nbsp;true</span>
</pre><!-- -->


<p>The logical methods, logical-and (<span class="code">&amp;&amp;</span>) and logical-or (<span class="code">||</span>), take <span class="code">Boolean</span> operands in infix notation<a id="i-206208280-1"></a>
and yield a <span class="code">Boolean</span> result.  For example:<a id="i-1437722857-1"></a><a id="i-893626619-1"></a><!-- --></p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;toBe&nbsp;=&nbsp;<span class="vem">true</span>
  <span class="output">toBe:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;question&nbsp;=&nbsp;toBe&nbsp;||&nbsp;!toBe
  <span class="output">question:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;paradox&nbsp;=&nbsp;toBe&nbsp;&amp;&amp;&nbsp;!toBe
  <span class="output">paradox:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- -->


<p>The logical-and and logical-or operations are <em>short-circuited</em> as in Java: expressions<a id="i682407483-1"></a>
built from these operators are only evaluated as far as needed to determine the result.
In other words, the right-hand side of logical-and and logical-or expressions
won't be evaluated if the left-hand side determines the result. For example, if the left-hand side of a logical-and expression
evaluates to <span class="code">false</span>, the result of the expression will definitely be <span class="code">false</span>, so the right-hand side is not evaluated. Likewise, if
the left-hand side of a logical-or expression evaluates to <span class="code">true</span>, the result of the expression will definitely be <span class="code">true</span>, so the
right-hand side is not evaluated.
For example:
<pre>
  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;salt()&nbsp;=&nbsp;{&nbsp;println(<span class="quotedstring">"salt"</span>);&nbsp;<span class="vem">false</span>&nbsp;}
  <span class="output">salt:&nbsp;()Boolean</span>
  <br />  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;pepper()&nbsp;=&nbsp;{&nbsp;println(<span class="quotedstring">"pepper"</span>);&nbsp;<span class="vem">true</span>&nbsp;}
  <span class="output">pepper:&nbsp;()Boolean</span>
  <br />  scala&gt;&nbsp;pepper()&nbsp;&amp;&amp;&nbsp;salt()
  <span class="output">pepper</span>
  <span class="output">salt</span>
  <span class="output">res22:&nbsp;Boolean&nbsp;=&nbsp;false</span>
  <br />  scala&gt;&nbsp;salt()&nbsp;&amp;&amp;&nbsp;pepper()&nbsp;
  <span class="output">salt</span>
  <span class="output">res23:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- -->
In the first expression, <span class="code">pepper</span> and <span class="code">salt</span> are invoked,  but
in the second, only <span class="code">salt</span> is invoked.  Given <span class="code">salt</span> returns
<span class="code">false</span>, there's no need to call <span class="code">pepper</span>.</p>

<div class="note">
<h4>Note</h4>


<p>You may be wondering how short-circuiting can work given
operators are just methods.  Normally, all arguments are evaluated before entering a method, so how can a method avoid evaluating its second argument?  The answer is that all Scala
methods have a facility for delaying the evaluation of their
arguments, or even declining to evaluate them at all.  The facility is
called <a href="glossary.html#g-1173919606"><em>by-name parameters</em></a> and is discussed in
<a href="control-abstraction.html#sec:by-name-parameters">Section 9.5</a>.</p>

</div>


<h3><a name="5.6"></a>5.6 Bitwise operations <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.6">link</a>]</span></h3>


<p>Scala enables you to perform operations on individual bits of integer types with several bitwise methods.<a id="i-1867892596-1"></a><a id="i-169049836-1"></a><a id="i608439332-1"></a><a id="i-788169784-1"></a><a id="i1085931200-1"></a>
The bitwise methods are: bitwise-and (<span class="code">&amp;</span>), bitwise-or (<span class="code">|</span>), and bitwise-xor (<span class="code">^</span>).<a href="basic-types-and-operations.html#footnote5-5">[5]</a> The unary bitwise
complement operator (<span class="code"><span style="font-size:large">~</span></span>, the method <span class="code">unary_<span style="font-size:large">~</span></span>), inverts each bit in its operand. For example:</p>

<pre>
  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;&amp;&nbsp;<span class="literal">2</span>&nbsp;&nbsp;
  <span class="output">res24:&nbsp;Int&nbsp;=&nbsp;0</span>
  <br />  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;|&nbsp;<span class="literal">2</span>&nbsp;&nbsp;
  <span class="output">res25:&nbsp;Int&nbsp;=&nbsp;3</span>
  <br />  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;^&nbsp;<span class="literal">3</span>&nbsp;&nbsp;
  <span class="output">res26:&nbsp;Int&nbsp;=&nbsp;2</span>
  <br />  scala&gt;&nbsp;<span style="font-size:large">~</span><span class="literal">1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <span class="output">res27:&nbsp;Int&nbsp;=&nbsp;-2</span>
</pre><!-- -->
The first expression, <span class="code">1</span>&nbsp;<span class="code">&amp;</span>&nbsp;<span class="code">2</span>, bitwise-ands each bit in 1 (0001) and 2 (0010), which yields 0 (0000). The
second expression, <span class="code">1</span>&nbsp;<span class="code">|</span>&nbsp;<span class="code">2</span>, bitwise-ors each bit in the same operands, yielding 3 (0011). The third expression, <span class="code">1</span>&nbsp;<span class="code">^</span>&nbsp;<span class="code">3</span>,
bitwise-xors each bit in 1 (0001) and 3 (0011), yielding 2 (0010). The final expression, <span class="code"><span style="font-size:large">~</span>1</span>, inverts each bit in 1 (0001),
yielding -2, which in binary looks like 11111111111111111111111111111110.


<p>Scala integer types also offer three shift methods: shift left (<span class="code">&lt;&lt;</span>), shift right (<span class="code">&gt;&gt;</span>), and<a id="i-1251371832-1"></a><a id="i-1409237921-1"></a><a id="i472230236-1"></a><a id="i-365724318-1"></a>
unsigned shift right (<span class="code">&gt;&gt;&gt;</span>). The shift methods, when used in infix operator notation, shift the integer
value on the left of the operator by the amount specified by the integer value on the right. Shift left and
unsigned shift right fill with zeroes as they shift. Shift right fills with the highest bit (the sign bit) of the
left-hand value as it shifts. Here are some examples:<a id="i1037331510-1"></a></p>

<pre>
  scala&gt;&nbsp;-<span class="literal">1</span>&nbsp;&gt;&gt;&nbsp;<span class="literal">31</span>&nbsp;
  <span class="output">res28:&nbsp;Int&nbsp;=&nbsp;-1</span>
  <br />  scala&gt;&nbsp;-<span class="literal">1</span>&nbsp;&gt;&gt;&gt;&nbsp;<span class="literal">31</span>
  <span class="output">res29:&nbsp;Int&nbsp;=&nbsp;1</span>
  <br />  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;&lt;&lt;&nbsp;<span class="literal">2</span>&nbsp;&nbsp;&nbsp;
  <span class="output">res30:&nbsp;Int&nbsp;=&nbsp;4</span>
</pre><!-- -->


<p>-1 in binary is 11111111111111111111111111111111. In the first example, <span class="code">-1</span>&nbsp;<span class="code">&gt;&gt;</span>&nbsp;<span class="code">31</span>, -1 is shifted to the right 31 bit positions. Since an
<span class="code">Int</span> consists of 32 bits, this operation effectively moves the leftmost bit over until it becomes the rightmost
bit.<a href="basic-types-and-operations.html#footnote5-6">[6]</a>
Since the <span class="code">&gt;&gt;</span> method fills with ones as it shifts right, because the leftmost bit of -1 is 1, the result is identical to the original left operand, 32 one bits, or -1.
In the second example, <span class="code">-1</span>&nbsp;<span class="code">&gt;&gt;&gt;</span>&nbsp;<span class="code">31</span>, the leftmost bit is again shifted right until it is in the rightmost position, but this time
filling with zeroes along the way. Thus the result this time is binary 00000000000000000000000000000001, or 1. In the final example, <span class="code">1</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">2</span>,  
the left operand, 1, is shifted left two positions (filling in with zeroes), resulting in binary 00000000000000000000000000000100, or 4.</p>

<h3><a name="5.7"></a>5.7 Object equality <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.7">link</a>]</span></h3>


<p><a name="sec:equality"></a></p>

<p>If you want to compare two objects for equality, you
can use either <span class="code">==</span>, or its inverse
<span class="code">!=</span>.<a id="i46092869-1"></a><a id="i307189229-1"></a> Here are a
few simple examples:<a id="i-1583721442-1"></a><a id="i1095465388-1"></a><a id="i15383763-1"></a><a id="i-1108611945-1"></a>
<pre>
  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;==&nbsp;<span class="literal">2</span>&nbsp;
  <span class="output">res31:&nbsp;Boolean&nbsp;=&nbsp;false</span>
  <br />  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;!=&nbsp;<span class="literal">2</span>&nbsp;
  <span class="output">res32:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="literal">2</span>&nbsp;==&nbsp;<span class="literal">2</span>&nbsp;
  <span class="output">res33:&nbsp;Boolean&nbsp;=&nbsp;true</span>
</pre><!-- -->
These operations actually apply to all objects, not just basic types.
For example, you can use <span class="code">==</span> to compare lists:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;==&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">res34:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;==&nbsp;<span class="typename">List</span>(<span class="literal">4</span>,&nbsp;<span class="literal">5</span>,&nbsp;<span class="literal">6</span>)
  <span class="output">res35:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- -->
Going further, you can compare two objects that have different types:
<pre>
  scala&gt;&nbsp;<span class="literal">1</span>&nbsp;==&nbsp;<span class="literal">1.0</span>
  <span class="output">res36:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;==&nbsp;<span class="quotedstring">"hello"</span>
  <span class="output">res37:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- -->
You can even compare against <span class="code">null</span>, or against things that might be
<span class="code">null</span>.  No exception will be thrown:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;==&nbsp;<span class="vem">null</span>
  <span class="output">res38:&nbsp;Boolean&nbsp;=&nbsp;false</span>
  <br />  scala&gt;&nbsp;<span class="vem">null</span>&nbsp;==&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">res39:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- --></p>

<p>As you see, <span class="code">==</span> has been carefully crafted so that you get just the
equality comparison you want in most cases.  This is accomplished with
a very simple rule: first check the left side for <span class="code">null</span>, and if it
is not <span class="code">null</span>, call the <span class="code">equals</span> method.<a id="i-342464093-1"></a>
Since <span class="code">equals</span> is a method, the precise
comparison you get depends on the type of the left-hand argument.
Since there is an automatic null check, you do not have to do the
check yourself.<a href="basic-types-and-operations.html#footnote5-7">[7]</a></p>

<p>This kind of comparison will yield <span class="code">true</span> on different objects, so
long as their contents are the same and their <span class="code">equals</span> method is
written to be based on
contents.  For example, here is a comparison
between two strings that happen to have the same five letters in them:<a id="i307189229-2"></a>
<pre>
  scala&gt;&nbsp;(<span class="quotedstring">"he"</span>+<span class="quotedstring">"llo"</span>)&nbsp;==&nbsp;<span class="quotedstring">"hello"</span>
  <span class="output">res40:&nbsp;Boolean&nbsp;=&nbsp;true</span>
</pre><!-- --></p>

<div class="aside">
<h3>How Scala's <span class="code">==</span> differs from Java's</h3>


<p>In Java, you can use <span class="code">==</span> to compare both primitive<a id="i-383144457-1"></a><a id="i1422354335-1"></a>
and reference types. On primitive types, Java's <span class="code">==</span> compares value equality,<a id="i1877185224-1"></a>
as in Scala. On reference types, however, Java's <span class="code">==</span> compares <a href="glossary.html#g1293228591"><em>reference equality</em></a>, which
means the two variables point to the same object on the JVM's heap.
Scala provides a facility for comparing reference equality, as well, under the name <span class="code">eq</span>.  However,
<span class="code">eq</span> and its opposite, <span class="code">ne</span>, only apply to objects that directly map to Java objects.
The full details about <span class="code">eq</span> and <span class="code">ne</span> are given in <a href="scalas-hierarchy.html#sec:scalas-class-hierarchy">Sections 11.1</a> and<a href="scalas-hierarchy.html#sec:impl-primitives"> 11.2</a>.
Also, see <a href="object-equality.html">Chapter 28</a> on how to write a good <span class="code">equals</span> method.<a id="i-795280463-1"></a><a id="i2030434891-1"></a><a id="i-1620977796-1"></a><a id="i1319501024-1"></a><a id="i1544052809-1"></a></p>

</div>


<h3><a name="5.8"></a>5.8 Operator precedence and associativity <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.8">link</a>]</span></h3>


<p><a name="sec:precedence"></a></p>

<p>Operator precedence determines which parts of an expression are evaluated before the other parts. For example, the expression<a id="i1955596960-1"></a><a id="i2084616098-1"></a>
<span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">7</span> evaluates to 16, not 28, because the * operator has a higher precedence than the + operator. Thus the multiplication<!-- --> part of
the expression is evaluated before the addition<!-- --> part. You can of course use parentheses in expressions to clarify evaluation
order or to override precedence. For example, if you really wanted the result of the expression above to be 28, you could
write the expression like this:</p>

<pre>
  (<span class="literal">2</span>&nbsp;+&nbsp;<span class="literal">2</span>)&nbsp;*&nbsp;<span class="literal">7</span>
</pre><!-- -->


<p>Given that Scala doesn't have operators, per se, just a way to use
methods in operator notation, you may be wondering how operator
precedence works. Scala decides precedence based on the first
character of the methods used in operator notation (there's one
exception to this rule, which will be discussed below). If the method name
starts with a <span class="code">*</span>, for example, it will have a higher precedence than
a method that starts with a <span class="code">+</span>. Thus <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">7</span> will be evaluated
as <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">7)</span>, and <span class="code">a</span>&nbsp;<span class="code">+++</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">***</span>&nbsp;<span class="code">c</span> (in which <span class="code">a</span>, <span class="code">b</span>, and <span class="code">c</span>
are variables, and <span class="code">+++</span> and <span class="code">***</span> are methods) will be
evaluated <span class="code">a</span>&nbsp;<span class="code">+++</span>&nbsp;<span class="code">(b</span>&nbsp;<span class="code">***</span>&nbsp;<span class="code">c)</span>, because the <span class="code">***</span> method has a higher
precedence than the <span class="code">+++</span> method.</p>

<p><a href="basic-types-and-operations.html#tab:opprec">Table 5.3</a> <a href="basic-types-and-operations.html#tab:opprec">here</a> shows the precedence given to the first character of a method in decreasing order of precedence, with
characters on the same line having the same precedence. The higher a character is in this table, the higher the
precedence of methods that start with that character.
Here's an example that illustrates the influence of precedence:</p>

<pre>
  scala&gt;&nbsp;<span class="literal">2</span>&nbsp;&lt;&lt;&nbsp;<span class="literal">2</span>&nbsp;+&nbsp;<span class="literal">2</span>
  <span class="output">res41:&nbsp;Int&nbsp;=&nbsp;32</span>
</pre><!-- -->


<p>The <span class="code">&lt;&lt;</span> method starts with the character <span class="code">&lt;</span>, which appears lower in <a href="basic-types-and-operations.html#tab:opprec">Table 5.3</a> than the character <span class="code">+</span>, which is the
first and only character of the <span class="code">+</span> method. Thus <span class="code">&lt;&lt;</span> will have lower precedence than <span class="code">+</span>, and the expression will
be evaluated by first invoking the <span class="code">+</span> method, then the <span class="code">&lt;&lt;</span> method, as in <span class="code">2</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">(2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2)</span>. <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> is <span class="code">4</span>, by
our math, and <span class="code">2</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">4</span> yields <span class="code">32</span>. Here's another example:</p>

<pre>
  scala&gt;&nbsp;<span class="literal">2</span>&nbsp;+&nbsp;<span class="literal">2</span>&nbsp;&lt;&lt;&nbsp;<span class="literal">2</span>
  <span class="output">res42:&nbsp;Int&nbsp;=&nbsp;16</span>
</pre><!-- -->


<p>Since the first characters are the same as in the previous example, the methods will be invoked in the same order. First the <span class="code">+</span> method will be invoked,
then the <span class="code">&lt;&lt;</span> method. So <span class="code">2</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">2</span> will again yield <span class="code">4</span>, and <span class="code">4</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">2</span> is 16.</p>

<p><a name="tab:opprec"></a></p>

<h5>Table 5.3 - Operator precedence<a id="i-1002965951-1"></a><a id="i-1679614205-1"></a></h5>


<div align="center">
<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    (all other special characters)
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">*</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">%</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">+</span>&nbsp;<span class="code">-</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">:</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">=</span>&nbsp;<span class="code">!</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">&lt;</span>&nbsp;<span class="code">&gt;</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">&amp;</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">^</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">|</span>
  </td>
</tr>
<tr class="">
  <td>
    (all letters)
  </td>
</tr>
<tr class="bottomline">
  <td>
    (all assignment operators)
  </td>
</tr>
</table>


</div>


<p>The one exception to the precedence rule, 
alluded to above,
concerns <span style="font-style:italic">assignment operators</span>, which end in an equals character.
If an operator ends in an equals character <span class="code">(=)</span>, and the
operator is not one of the comparison operators <span class="code">&lt;=</span>, <span class="code">&gt;=</span>, <span class="code">==</span>,
or <span class="code">!=</span>, then the precedence of the operator is the same as that
of simple assignment <span class="code">(=)</span>. That is, it is lower than the
precedence of any other operator. For instance:
<pre>
  x&nbsp;*=&nbsp;y&nbsp;+&nbsp;<span class="literal">1</span>
</pre><!-- -->
means the same as:
<pre>
  x&nbsp;*=&nbsp;(y&nbsp;+&nbsp;<span class="literal">1</span>)
</pre><!-- -->
because <span class="code">*=</span> is classified as an assignment operator whose precedence is lower than <span class="code">+</span>, even though the operator's first character 
is <span class="code">*</span>, which would suggest a precedence higher than <span class="code">+</span>.</p>

<p>When multiple operators of the same precedence appear side by side in an expression, the <em>associativity</em> of the operators<a id="i1109054020-1"></a><a id="i1812392602-1"></a>
determines the way operators are grouped. The associativity of an operator in Scala is determined by its <em>last</em> character. As mentioned
<a href="next-steps-in-scala.html#note:colonmethod">here</a> of <a href="next-steps-in-scala.html">Chapter 3</a>, any method that ends in a `<span class="code">:</span>'
character is invoked on its right operand, passing in the left operand. Methods
that end in any other character are the other way around. They are invoked on their left operand, passing in the right operand.
So <span class="code">a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b</span> yields <span class="code">a.*(b)</span>, but <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">b</span> yields <span class="code">b.:::(a)</span>.<a id="i-1085593547-2"></a></p>

<p>No matter what associativity an operator has, however, its operands are always evaluated left to right. 
So if <span class="code">b</span> is an expression that is not just a simple reference to an immutable value, then <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">b</span>
is more precisely treated as the following block:
<pre>
  {&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;a;&nbsp;b.:::(x)&nbsp;}
</pre><!-- -->
In this block <span class="code">a</span> is still evaluated before <span class="code">b</span>, and then the result of this evaluation is passed as an operand
to <span class="code">b</span>'s <span class="code">:::</span> method.</p>

<p>This associativity rule also plays a role when multiple operators of
the same precedence appear side by side. If the methods end in `<span class="code">:</span>',
they are grouped right to left; otherwise, they are grouped left to
right.  For example, <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">c</span> is treated as <span class="code">a</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">(b</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">c)</span>. 
But <span class="code">a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">c</span>, by contrast, is treated as <span class="code">(a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">c</span>.</p>

<p>Operator precedence is part of the Scala language. You needn't be afraid to use it. Nevertheless, it is
good style to use parentheses to clarify what operators are operating upon what expressions.
Perhaps the only precedence you can truly count on other programmers knowing without looking up is that multiplicative operators, <span class="code">*</span>,
<span class="code">/</span>, and <span class="code">%</span>, have a higher precedence than the additive ones <span class="code">+</span> and <span class="code">-</span>. Thus even if <span class="code">a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">c</span> yields the result you want without
parentheses, the extra clarity you get by writing <span class="code">(a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b)</span>&nbsp;<span class="code">&lt;&lt;</span>&nbsp;<span class="code">c</span> may reduce the frequency with which your peers utter
your name in operator notation, for example, by shouting in disgust, "<span class="code">bills</span> <!-- --> <span class="code">!*&amp;^%<span style="font-size:large">~</span></span> <!-- --> <span class="code">code!</span>".<a href="basic-types-and-operations.html#footnote5-8">[8]</a></p>

<h3><a name="5.9"></a>5.9 Rich wrappers <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.9">link</a>]</span></h3>


<p><a name="sec:rich-wrappers"></a></p>

<p>You can invoke many more methods on Scala's basic types than were described in the previous sections.  A
few examples are shown in <a href="basic-types-and-operations.html#tab:richops">Table 5.4</a>.  These methods are
available via <em>implicit conversions</em>, a technique that will be
described in detail in
<a href="implicit-conversions-and-parameters.html">Chapter 21</a>.<a id="i-108634082-1"></a><a id="i681737575-1"></a><a id="i807731316-1"></a>
All you need to know for now is that for each basic type described in this chapter, there is also a "rich
wrapper" that provides several additional methods.  To see all
the available methods on the basic types, therefore, you should look at the API
documentation on the rich wrapper for each basic type.  Those classes
are listed in <a href="basic-types-and-operations.html#tab:richclasses">Table 5.5</a>.</p>

<p><a name="tab:richops"></a></p>

<h5>Table 5.4 - Some rich operations<a id="i-256644535-2"></a><a id="i-2103371977-1"></a><a id="i574171488-2"></a><a id="i-995240575-1"></a><a id="i1813550033-1"></a></h5>


<div align="center">
<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Code</span></span>
  </td>
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Result</span></span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span class="code"><span class="literal">0</span></span>&nbsp;<span class="code">max</span>&nbsp;<span class="code"><span class="literal">5</span></span>
  </td>
  <td>
    <span class="code">5</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="literal">0</span></span>&nbsp;<span class="code">min</span>&nbsp;<span class="code"><span class="literal">5</span></span>
  </td>
  <td>
    <span class="code">0</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">-<span class="literal">2.7</span></span>&nbsp;<span class="code">abs</span>
  </td>
  <td>
    <span class="code">2.7</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">-<span class="literal">2.7</span></span>&nbsp;<span class="code">round</span>
  </td>
  <td>
    <span class="code">-3L</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="literal">1.5</span></span>&nbsp;<span class="code">isInfinity</span>
  </td>
  <td>
    <span class="code">false</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">(<span class="literal">1.0</span></span>&nbsp;<span class="code">/</span>&nbsp;<span class="code"><span class="literal">0</span>)</span>&nbsp;<span class="code">isInfinity</span>
  </td>
  <td>
    <span class="code">true</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="literal">4</span></span>&nbsp;<span class="code">to</span>&nbsp;<span class="code"><span class="literal">6</span></span>
  </td>
  <td>
    <span class="code">Range(4,</span>&nbsp;<span class="code">5,</span>&nbsp;<span class="code">6)</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="quotedstring">"bob"</span></span>&nbsp;<span class="code">capitalize</span>
  </td>
  <td>
    <span class="code">"Bob"</span>
  </td>
</tr>
<tr class="bottomline">
  <td>
    <span class="code"><span class="quotedstring">"robert"</span></span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code"><span class="literal">2</span></span>
  </td>
  <td>
    <span class="code">"bert"</span>
  </td>
</tr>
</table>


</div>


<p><a name="tab:richclasses"></a></p>

<h5>Table 5.5 - Rich wrapper classes</h5>


<div align="center">
<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Basic type</span></span>
  </td>
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">Rich wrapper</span></span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span class="code"><span class="typename">Byte</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichByte</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Short</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichShort</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Int</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichInt</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Char</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichChar</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">String</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichString</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Float</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichFloat</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code"><span class="typename">Double</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichDouble</span>
  </td>
</tr>
<tr class="bottomline">
  <td>
    <span class="code"><span class="typename">Boolean</span></span>
  </td>
  <td>
    <span class="code">scala.runtime.RichBoolean</span>
  </td>
</tr>
</table>


</div>


<h3><a name="5.10"></a>5.10 Conclusion <span style="font-size: .5em">[<a href="basic-types-and-operations.html#5.10">link</a>]</span></h3>


<p>The main take-aways from this chapter are that operators in Scala are
method calls, and that implicit conversions to rich variants exist for
Scala's basic types that add even more useful methods. In the next
chapter, we'll show you what it means to design objects in a
functional style that gives new implementations of some of the
operators that you have seen in this chapter.</p>

<hr/>
<h4>Footnotes for Chapter 5:</h4>


<p><a name="footnote5-1">[1]</a> Packages, which were briefly
described in <a href="first-steps-in-scala.html#step2">Step 2</a> in <a href="first-steps-in-scala.html">Chapter 2</a>,
will be covered in depth in <a href="packages-and-imports.html">Chapter 13</a>.</p>

<p><a name="footnote5-2">[2]</a> figuratively speaking</p>

<p><a name="footnote5-3">[3]</a> <em>Overloaded</em> methods have the same name but
different argument types. More on method overloading in <a href="functional-objects.html#sec:method-overloading">Section 6.11</a>.</p>

<p><a name="footnote5-4">[4]</a> All is not necessarily
lost, however. There is an extremely slight chance your program with
the <span class="code">*p</span> might compile as C++.</p>

<p><a name="footnote5-5">[5]</a> The bitwise-xor
method performs an <em>exclusive or</em> on its operands. Identical bits yield a 0. Different bits yield a 1. Thus
<span class="code">0011</span>&nbsp;<span class="code">^</span>&nbsp;<span class="code">0101</span> yields <span class="code">0110</span></p>

<p><a name="footnote5-6">[6]</a> The leftmost bit in an integer type is the sign bit. If the leftmost bit is 1, the number is negative. If 0, the number is positive.</p>

<p><a name="footnote5-7">[7]</a> The automatic check does not look at the
right-hand side, but any reasonable <span class="code">equals</span> method should return
<span class="code">false</span> if its argument is <span class="code">null</span>.</p>

<p><a name="footnote5-8">[8]</a> By now you should be able to figure out that
given this code, the Scala compiler would invoke <span class="code">(bills.!*&amp;^%<span style="font-size:large">~</span>(code)).!()</span>.</p>



<br clear="all">
<p>
<center>
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/basic-types-and-operationsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/classes-and-objects.html">Previous</a>&nbsp;| 
<a href="/pins1ed/functional-objects.html">Next</a>
</div>
</center>
</div>
<hr width="100%" />
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<br />
<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/custom">
<table border="0" bgcolor="#ffffff">
<tr><td nowrap="nowrap" valign="top" align="left" height="32">
<a href="http://www.google.com/">
<img src="http://www.google.com/logos/Logo_25wht.gif"
border="0" alt="Google"></img></a>
</td>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="Artima.com"></input>
<input type="text" name="q" size="31" maxlength="255" value=""></input>
<input type="submit" name="sa" value="Search"></input>
</td></tr>
<tr>
<td>&nbsp;</td>
<td nowrap="nowrap">
<font size="-1" color="#000000">
<input type="radio" name="sitesearch" value=""></input> Web
<input type="radio" name="sitesearch" value="Artima.com" checked="checked"></input>Artima.com
</font>&nbsp;&nbsp;
<input type="hidden" name="client" value="pub-3911176865765226"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:http://www.artima.com/images/artima150.gif;S:http://www.artima.com;FORID:1;"></input>
<input type="hidden" name="hl" value="en"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</center>
<div class="sp">
<div style="text-align: center">
<a href="http://www.artima.com/copyright.html">Copyright</a> &copy; 1996-2014 Artima, Inc. All Rights Reserved.</a> - <a href="http://www.artima.com/privacy.html">Privacy Policy</a> - <a href="http://www.artima.com/termsofuse.html">Terms of Use</a> - <a href="http://www.artima.com/advertising.html">Advertise with Us</a>
</div>
</div>
<br />
</body>
</html>
