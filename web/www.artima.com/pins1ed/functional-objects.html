<html>
<head>
<title>Functional Objects</title>
<meta name="description" content="
" />
<meta name="keywords" content="scala" />
<meta name="author" content="Martin Odersky, Lex Spoon, and Bill Venners" />
<link rel="stylesheet" type="text/css" href="/artima.css" />
<link rel="shortcut icon" href="/favicon.ico" />
</head>
<body><table width="100%" cellspacing="0">
<tr>
<td align="left" valign="bottom">
<a href="/index.jsp"><img src="/images/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43" /></a>
</td>
</table>
<table width="100%" bgcolor="#333333">
<tr>
<td align="center">
<div class="ml">
<a href="/articles" class="hl">Articles</a>&nbsp;|
<a href="/news/index.jsp" class="hl">News</a>&nbsp;|
<a href="/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;|
<a href="/buzz/index.jsp" class="hl">Buzz</a>&nbsp;|
<a href="/shop/catalog" class="hl">Books</a>&nbsp;|
<a href="/forums/index.jsp" class="hl">Forums</a>
</div>
</td>
</tr>
</table>
<table width="100%" bgcolor="#AACCFF">
<tr>
<td align="center">
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/functional-objectsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/basic-types-and-operations.html">Previous</a>&nbsp;| 
<a href="/pins1ed/builtin-control-structures.html">Next</a>
</div>
</td>
</tr>
</table>
<BR>
<div class="vegies">
<div class="tc">
<span class="sts">Chapter 6 of Programming in Scala, First Edition</span><br />
<span class="ts">Functional Objects</span><br />
<span class="as">by Martin Odersky, Lex Spoon, and Bill Venners</span><br />
<span class="pd">December 10, 2008</span><br />
</div>




<p>With the understanding of Scala basics you gained in previous
chapters, you're ready to see how to design more full-featured classes
in Scala.  The emphasis in this chapter is on classes that define
functional objects, that is, objects that do not have any mutable
state.<a id="i47852440-1"></a>  As a running example, we'll create several variants of a class
that models rational numbers as immutable objects.  Along the way,
we'll show you more aspects of object-oriented programming in Scala:
class parameters and constructors, methods and operators, private
members, overriding, checking preconditions, overloading, and self
references<a id="i1689782844-2"></a><a id="i-2121954815-1"></a>.</p>

<h3><a name="6.1"></a>6.1 A specification for class <span class="code">Rational</span> <span style="font-size: .5em">[<a href="functional-objects.html#6.1">link</a>]</span></h3>


<p><a name="sec:class-for-rational-numbers"></a></p>

<p>A <em>rational number</em> is a number that can be expressed as a ratio <sup>n</sup>/<sub>d</sub>,
where <i>n</i> and <i>d</i> are integers, except that <i>d</i> cannot be zero.
<i>n</i> is called the <span style="font-style:italic">numerator</span> and <i>d</i> the <span style="font-style:italic">denominator</span>.
Examples of rational numbers are <sup>1</sup>/<sub>2</sub>, <sup>2</sup>/<sub>3</sub>, <sup>112</sup>/<sub>239</sub>, and
<sup>2</sup>/<sub>1</sub>. Compared to floating-point numbers, rational numbers have
the advantage that fractions are represented exactly, without
rounding or approximation.</p>

<p>The class we'll design in this chapter must model the behavior of rational numbers, including
allowing them to be added, subtracted, multiplied, and divided.
To add two rationals, you must first obtain a common
denominator, then add the two numerators. For example, to add <sup>1</sup>/<sub>2</sub> + <sup>2</sup>/<sub>3</sub>, you multiply both parts of
the left operand by 3 and both parts of the right operand by 2, which gives you <sup>3</sup>/<sub>6</sub> +
<sup>4</sup>/<sub>6</sub>. Adding the two numerators yields the result,
<sup>7</sup>/<sub>6</sub>. To multiply two rational numbers, you can simply multiply
their numerators and multiply their denominators. Thus,
<sup>1</sup>/<sub>2</sub> * <sup>2</sup>/<sub>5</sub> gives <sup>2</sup>/<sub>10</sub>, which can be
represented more compactly in its "normalized" form as <sup>1</sup>/<sub>5</sub>.  You divide by
swapping the numerator and denominator of the right operand and then
multiplying.  For instance <sup>1</sup>/<sub>2</sub> / <sup>3</sup>/<sub>5</sub> is the same as
<sup>1</sup>/<sub>2</sub> * <sup>5</sup>/<sub>3</sub>, or <sup>5</sup>/<sub>6</sub>.</p>

<p>One, maybe rather trivial, observation is that in mathematics, rational numbers do
not have mutable state. You can add one rational number to another, but the
result will be a new rational number.  The original numbers will not
have "changed." The immutable <span class="code">Rational</span> class we'll design in this chapter will have the same
property. Each rational number will be represented by one <span class="code">Rational</span>
object. When you add two
<span class="code">Rational</span> objects, you'll create a new <span class="code">Rational</span> object to hold the sum.</p>

<p>This chapter will give you a glimpse of some of the ways Scala enables you to write libraries 
that feel like native language support. For example, at the end of this chapter you'll
be able to do this with class <span class="code">Rational</span>:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;oneHalf&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <span class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;twoThirds&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <span class="output">twoThirds:&nbsp;Rational&nbsp;=&nbsp;2/3</span>
  <br />  scala&gt;&nbsp;(oneHalf&nbsp;/&nbsp;<span class="literal">7</span>)&nbsp;+&nbsp;(<span class="literal">1</span>&nbsp;-&nbsp;twoThirds)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <span class="output">res0:&nbsp;Rational&nbsp;=&nbsp;17/42</span>
</pre><!-- --></p>

<h3><a name="6.2"></a>6.2 Constructing a <span class="code">Rational</span> <span style="font-size: .5em">[<a href="functional-objects.html#6.2">link</a>]</span></h3>


<p>A good place to start designing class <span class="code">Rational</span> is to consider how client programmers
will create a new <span class="code">Rational</span> object. Given we've decided to make <span class="code">Rational</span> objects immutable,
we'll require that clients provide all data needed by an instance (in this case, a numerator and
a denominator) when they construct the instance. Thus, we will start the
design with this:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)
</pre><!-- -->
One of the first things to note about this line of code is that if a class doesn't have
a body, you don't need to specify empty curly braces (though you could,
of course, if you wanted
to).<a id="i-1274918996-1"></a><a id="i-1738295964-1"></a>
The identifiers <span class="code">n</span> and <span class="code">d</span> in the
parentheses after the class name, <span class="code">Rational</span>, are called <em>class
parameters</em><a id="i177886610-1"></a>. The Scala compiler will gather up these two class
parameters and create a <em>primary constructor</em> that takes the same
two parameters.<a id="i2081307927-1"></a><a id="i161912641-1"></a></p>

<div class="aside">
<h3>Immutable object trade-offs</h3>


<p>Immutable objects offer several advantages over mutable objects, and one
potential disadvantage.<a id="i1835948581-1"></a> First, immutable objects are often easier to reason
about than mutable ones, because they do not have complex state spaces
that change over time. Second, you can pass immutable objects around
quite freely, whereas you may need to make defensive copies<a id="i-1422525536-1"></a> of mutable
objects before passing them to other code.  Third, there is no way for
two threads concurrently accessing an immutable to corrupt its state
once it has been properly constructed, because no thread can change the state of an immutable. Fourth, immutable objects make
safe hashtable keys. If a mutable object is mutated after it is
placed into a <span class="code">HashSet</span>, for example, that object may not be found
the next time you look into the <span class="code">HashSet</span>.</p>

<p><!-- -->The main disadvantage of immutable objects is that they sometimes
require that a large object graph be copied where otherwise an update
could be done in place. In some cases this can be awkward to express
and might also cause a performance bottleneck.  As a result, it is<a id="i-222173474-1"></a>
not uncommon for libraries to provide mutable alternatives to immutable classes. For
example, class <span class="code">StringBuilder</span> is a mutable alternative to the immutable <span class="code">String</span>. We'll
give you more information on designing mutable objects in Scala in
<a href="stateful-objects.html">Chapter 18</a>.</p>

</div>


<div class="note">
<h4>Note</h4>


<p>This initial <span class="code">Rational</span> example highlights a difference between Java and Scala.<a id="i263298648-1"></a>
In Java, classes have constructors, which can take parameters,
whereas in Scala, classes can take parameters directly.
The Scala notation is more concise&mdash;class parameters can be used directly in the 
body of the class; there's no need to define fields and write assignments that copy
constructor parameters into fields. This can yield substantial savings in boilerplate code, 
especially for small classes.</p>

</div>


<p>The Scala compiler will compile any code you place in the class body, which isn't part of a field or a method
definition, into the primary constructor.
For example, you could print a debug message like this:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  &nbsp;&nbsp;println(<span class="quotedstring">"Created&nbsp;"</span>+&nbsp;n&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;d)
  }
</pre><!-- -->
Given this code, the Scala compiler would place the call to <span class="code">println</span> into <span class="code">Rational</span>'s primary constructor.
The <span class="code">println</span> call will, therefore, print its debug message whenever you create a new <span class="code">Rational</span> instance:
<pre>
  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>)
  <span class="output">Created&nbsp;1/2</span>
  <span class="output">res0:&nbsp;Rational&nbsp;=&nbsp;Rational@90110a</span>
</pre><!-- --></p>

<h3><a name="6.3"></a>6.3 Reimplementing the <span class="code">toString</span> method <span style="font-size: .5em">[<a href="functional-objects.html#6.3">link</a>]</span></h3>


<p><a name="sec:reimp-tostring"></a></p>

<p>When we created an instance of <span class="code">Rational</span> in the previous example, the interpreter
printed "Rational@90110a". 
The interpreter obtained this somewhat funny looking string by
calling <span class="code">toString</span> on the <span class="code">Rational</span> object. By default, class <span class="code">Rational</span> 
inherits the implementation of <span class="code">toString</span> defined in class <span class="code">java.lang.Object</span>,
which just prints the class name, an @ sign, and a hexadecimal number.
The result of <span class="code">toString</span> is primarily intended to help programmers by providing information that can be used in
debug print statements, log messages, test failure reports, and interpreter and debugger output. The result currently
provided by <span class="code">toString</span> is not especially helpful, because it doesn't give any clue about the rational number's value. A more useful implementation of <span class="code">toString</span> 
would print out the values of the <span class="code">Rational</span>'s numerator and denominator.
You can <em>override</em> the default implementation by adding a method <span class="code">toString</span>
to class <span class="code">Rational</span>, like this:<a id="i-189935346-1"></a><a id="i-720005867-1"></a>
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;n&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;d
  }
</pre><!-- -->
The <span class="code">override</span> modifier in front of a method definition signals that a previous method definition
is overridden; more on this in <a href="composition-and-inheritance.html">Chapter 10</a>.
Since <span class="code">Rational</span> numbers will display nicely now,
we removed the debug <span class="code">println</span> statement we put into the body of
previous version of class <span class="code">Rational</span>.<a id="i1201360043-1"></a>
You can test the new behavior of <span class="code">Rational</span> in the interpreter:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">1</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">x:&nbsp;Rational&nbsp;=&nbsp;1/3</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;y&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">5</span>,&nbsp;<span class="literal">7</span>)
  <span class="output">y:&nbsp;Rational&nbsp;=&nbsp;5/7</span>
</pre><!-- --></p>

<h3><a name="6.4"></a>6.4 Checking preconditions <span style="font-size: .5em">[<a href="functional-objects.html#6.4">link</a>]</span></h3>


<p><a name="sec:checking-preconditions"></a></p>

<p>As a next step, we will turn our attention to a problem with the<a id="i1294809499-1"></a>
current behavior of the primary constructor.  As mentioned at the
beginning of this chapter, rational numbers may not have a zero in the
denominator. Currently, however, the primary constructor accepts a
zero passed as <span class="code">d</span>:
<pre>
  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">5</span>,&nbsp;<span class="literal">0</span>)
  <span class="output">res1:&nbsp;Rational&nbsp;=&nbsp;5/0</span>
</pre><!-- -->
One of the benefits of object-oriented programming is that it allows
you to encapsulate data inside objects so that you can ensure the data
is valid throughout its lifetime.  In the case of an immutable object
such as <span class="code">Rational</span>, this means that you should ensure the data is
valid when the object is constructed. Given that a zero denominator is
an invalid state for a <span class="code">Rational</span> number, you should not let a
<span class="code">Rational</span> be constructed if a zero is passed in the <span class="code">d</span> parameter.</p>

<p>The best way to approach this problem is to define as a <em>precondition</em> of the primary
constructor that <span class="code">d</span> must be non-zero. A precondition is a constraint on values passed into
a method or constructor, a requirement which callers must fulfill. 
One way to do that is to use <span class="code">require</span>,<a href="functional-objects.html#footnote6-1">[1]</a>
like this:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  &nbsp;&nbsp;require(d&nbsp;!=&nbsp;<span class="literal">0</span>)
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;n&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;d
  }
</pre><!-- -->
The <span class="code">require</span> method takes one boolean parameter. If the passed value
is true, <span class="code">require</span> will return normally<a id="i-2113140869-1"></a>. Otherwise,
<span class="code">require</span> will prevent the object from being constructed by throwing an <span class="code">IllegalArgumentException</span>.</p>

<h3><a name="6.5"></a>6.5 Adding fields <span style="font-size: .5em">[<a href="functional-objects.html#6.5">link</a>]</span></h3>


<p><a name="sec:adding-fields"></a></p>

<p>Now that the primary constructor is properly enforcing its precondition, we will turn our
attention to supporting addition.  To do so, we'll define
a public <span class="code">add</span> method on class <span class="code">Rational</span> that takes another <span class="code">Rational</span> as a parameter.
To keep <span class="code">Rational</span> immutable, the <span class="code">add</span> method must not add the passed rational number to itself.
Rather, it must create and return a new <span class="code">Rational</span> that holds the sum.
You might think you could write <span class="code">add</span> this way:</p>

<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{&nbsp;<span class="comment">//&nbsp;This&nbsp;won't&nbsp;compile</span>
  &nbsp;&nbsp;require(d&nbsp;!=&nbsp;<span class="literal">0</span>)
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;n&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;d
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;add(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  }
</pre><!-- -->
However, given this code the compiler will complain:<a id="i988779894-1"></a>
<pre>
  &lt;console&gt;:11:&nbsp;error:&nbsp;value&nbsp;d&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;Rational
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
  &lt;console&gt;:11:&nbsp;error:&nbsp;value&nbsp;d&nbsp;is&nbsp;not&nbsp;a&nbsp;member&nbsp;of&nbsp;Rational
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Rational(n&nbsp;*&nbsp;that.d&nbsp;+&nbsp;that.n&nbsp;*&nbsp;d,&nbsp;d&nbsp;*&nbsp;that.d)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^
</pre><!-- -->


<p>Although class parameters <span class="code">n</span> and <span class="code">d</span> are in scope in the code of your <span class="code">add</span> method, you
can only access their value on the object on which <span class="code">add</span> was invoked. Thus, when you say <span class="code">n</span> or <span class="code">d</span>
in <span class="code">add</span>'s implementation, the compiler is happy to provide you with the values for
these class parameters. But it won't let you say <span class="code">that.n</span> or <span class="code">that.d</span>, because <span class="code">that</span>
does not refer to the <span class="code">Rational</span> object on which <span class="code">add</span> was invoked.<a href="functional-objects.html#footnote6-2">[2]</a>
To access the numerator and denominator on <span class="code">that</span>, you'll need to make them into fields.
<a href="functional-objects.html#lst:rational-fields">Listing 6.1</a> shows how you could add these fields to class <span class="code">Rational</span>.<a href="functional-objects.html#footnote6-3">[3]</a><a id="i2138903369-1"></a><a id="i-590826255-1"></a></p>

<p><a name="lst:rational-fields"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<span class="literal">0</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numer:&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denom:&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;d
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;denom
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;add(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 6.1 - <span class="code">Rational</span> with fields.</h5>


<p>In the<!-- --> version of <span class="code">Rational</span> shown in <a href="functional-objects.html#lst:rational-fields">Listing 6.1</a>, we added two fields named <span class="code">numer</span> and <span class="code">denom</span>, and initialized
them with the values of class parameters <span class="code">n</span> and <span class="code">d</span>.<a href="functional-objects.html#footnote6-4">[4]</a> We also changed the implementation of
<span class="code">toString</span> and <span class="code">add</span> so that they use the fields, not the class parameters.
This version of class <span class="code">Rational</span> compiles. You can test it by adding some rational numbers:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;oneHalf&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>)
  <span class="output">oneHalf:&nbsp;Rational&nbsp;=&nbsp;1/2</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;twoThirds&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">twoThirds:&nbsp;Rational&nbsp;=&nbsp;2/3</span>
  <br />  scala&gt;&nbsp;oneHalf&nbsp;add&nbsp;twoThirds
  <span class="output">res3:&nbsp;Rational&nbsp;=&nbsp;7/6</span>
</pre><!-- --></p>

<p>One other thing you can do now that you couldn't do before is access the numerator and denominator values from outside
the object. Simply access the public <span class="code">numer</span> and <span class="code">denom</span> fields, like this:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;r&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>)
  <span class="output">r:&nbsp;Rational&nbsp;=&nbsp;1/2</span>
  <br />  scala&gt;&nbsp;r.numer
  <span class="output">res4:&nbsp;Int&nbsp;=&nbsp;1</span>
  <br />  scala&gt;&nbsp;r.denom
  <span class="output">res5:&nbsp;Int&nbsp;=&nbsp;2</span>
</pre><!-- --></p>

<h3><a name="6.6"></a>6.6 Self references <span style="font-size: .5em">[<a href="functional-objects.html#6.6">link</a>]</span></h3>


<p><a name="sec:self-references"></a></p>

<p>The keyword <span class="code">this</span> refers to the<a id="i3559070-1"></a><a id="i423816156-1"></a>
object instance on which the currently executing method was invoked, or if used in
a constructor, the object instance being
constructed.
As an example, consider adding a method, <span class="code">lessThan</span>,
which tests whether the given <span class="code">Rational</span> is smaller than a parameter:
<pre>
  <span class="vem">def</span>&nbsp;lessThan(that:&nbsp;<span class="typename">Rational</span>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<span class="vem">this</span>.numer&nbsp;*&nbsp;that.denom&nbsp;&lt;&nbsp;that.numer&nbsp;*&nbsp;<span class="vem">this</span>.denom
</pre><!-- -->
Here, <span class="code">this.numer</span> refers to the numerator of the object on which
<span class="code">lessThan</span> was invoked.  You can also leave off the <span class="code">this</span> prefix
and write just <span class="code">numer</span>; the two notations are equivalent.</p>

<p>As an example where you can't do without <span class="code">this</span>, consider adding a
<span class="code">max</span> method to class <span class="code">Rational</span> that returns the greater of the
given rational number and an argument:
<pre>
  <span class="vem">def</span>&nbsp;max(that:&nbsp;<span class="typename">Rational</span>)&nbsp;=&nbsp;
  &nbsp;&nbsp;<span class="vem">if</span>&nbsp;(<span class="vem">this</span>.lessThan(that))&nbsp;that&nbsp;<span class="vem">else</span>&nbsp;<span class="vem">this</span>
</pre><!-- -->
Here, the first <span class="code">this</span> is redundant. You could have equally well
left it off and written: <span class="code">lessThan(that)</span>.  But the second <span class="code">this</span> represents the result
of the method in the case where the test returns false; were you to omit
it, there would be nothing left to return!</p>

<h3><a name="6.7"></a>6.7 Auxiliary constructors <span style="font-size: .5em">[<a href="functional-objects.html#6.7">link</a>]</span></h3>


<p><a name="sec:multicons"></a></p>

<p>Sometimes you need multiple constructors in a class.  In Scala,
constructors
other than the primary constructor are called <a href="glossary.html#g729406368"><em>auxiliary constructors</em></a>.<a id="i-717257147-1"></a><a id="i1136761043-1"></a><a id="i-1656673269-1"></a>
For example, a rational number with a denominator of 1 can be written more succinctly as
simply the numerator. Instead of <sup>5</sup>/<sub>1</sub>, for example, you can just write 5.
It might be nice, therefore, if instead of writing <span class="code">new</span>&nbsp;<span class="code">Rational(5,</span>&nbsp;<span class="code">1)</span>, client programmers could simply
write <span class="code">new</span>&nbsp;<span class="code">Rational(5)</span>. This would require adding an auxiliary constructor to <span class="code">Rational</span> that
takes only one argument, the numerator, with the denominator predefined to be 1.
<a href="functional-objects.html#lst:aux-constructor">Listing 6.2</a> shows what that would look like.</p>

<p><a name="lst:aux-constructor"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<span class="literal">0</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numer:&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denom:&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;d
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;<span class="vem">this</span>(n:&nbsp;<span class="typename">Int</span>)&nbsp;=&nbsp;<span class="vem">this</span>(n,&nbsp;<span class="literal">1</span>)&nbsp;<span class="comment">//&nbsp;auxiliary&nbsp;constructor</span>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;add(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 6.2 - <span class="code">Rational</span> with an auxiliary constructor.</h5>


<p>Auxiliary constructors in Scala start with <span class="code">def</span>&nbsp;<span class="code">this(...)</span>. The body of <span class="code">Rational</span>'s auxiliary constructor merely invokes
the primary constructor, passing along its lone argument, <span class="code">n</span>, as the
numerator and <span class="code">1</span> as the denominator.
You can see the auxiliary constructor in action by typing the
following into the interpreter:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;y&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">3</span>)
  <span class="output">y:&nbsp;Rational&nbsp;=&nbsp;3/1</span>
</pre><!-- --></p>

<p>In Scala, every auxiliary constructor must invoke another constructor of the same
class as its first action. In other words, the first statement in every auxiliary
constructor in every Scala class will have the form "<span class="code">this(</span>...<span class="code">)</span>". The invoked constructor is either the
primary constructor (as in the <span class="code">Rational</span> example), or another
auxiliary constructor that comes textually before the calling
constructor. The net effect of this rule is that every constructor
invocation in Scala will end up eventually calling the primary
constructor of the class.  The primary constructor is thus the single
point of entry of a class.</p>

<div class="note">
<h4>Note</h4>


<p>If you're familiar with Java, you may wonder why Scala's rules for constructors are a bit more restrictive than
Java's. In Java, a constructor must either invoke another constructor of the same class, or directly invoke a
constructor of the superclass, as its first action. In a Scala class, only the primary constructor can invoke a
superclass constructor. The increased restriction in Scala is really a design trade-off that needed to be paid 
in exchange for the greater conciseness and simplicity of Scala's constructors compared to Java's.
Superclasses and the details of how constructor invocation
and inheritance interact will be explained in <a href="composition-and-inheritance.html">Chapter 10</a>.</p>

</div>


<h3><a name="6.8"></a>6.8 Private fields and methods <span style="font-size: .5em">[<a href="functional-objects.html#6.8">link</a>]</span></h3>


<p>In the previous version of <span class="code">Rational</span>, we simply initialized <span class="code">numer</span> with <span class="code">n</span> and
<span class="code">denom</span> with <span class="code">d</span>.
As a result, the numerator and
denominator of a <span class="code">Rational</span> can be larger than needed. For example, the fraction <sup>66</sup>/<sub>42</sub>
could be normalized to an equivalent reduced form, <sup>11</sup>/<sub>7</sub>, but <span class="code">Rational</span>'s primary constructor
doesn't currently do this: 
<pre>
  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">66</span>,&nbsp;<span class="literal">42</span>)
  <span class="output">res6:&nbsp;Rational&nbsp;=&nbsp;66/42</span>
</pre><!-- -->
To normalize in this way, you need to divide the numerator and denominator by their <em>greatest common divisor</em>.
For example, the greatest common divisor of 66 and 42 is 6. (In other words, 6 is the largest integer that divides evenly
into both 66 and 42.) Dividing both the numerator and denominator of <sup>66</sup>/<sub>42</sub> by 6 yields its reduced
form, <sup>11</sup>/<sub>7</sub>. <a href="functional-objects.html#lst:private-members">Listing 6.3</a> shows one way to do this:</p>

<p><a name="lst:private-members"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<span class="literal">0</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">val</span>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;<span class="vem">this</span>(n:&nbsp;<span class="typename">Int</span>)&nbsp;=&nbsp;<span class="vem">this</span>(n,&nbsp;<span class="literal">1</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;add(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;gcd(a:&nbsp;<span class="typename">Int</span>,&nbsp;b:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(b&nbsp;==&nbsp;<span class="literal">0</span>)&nbsp;a&nbsp;<span class="vem">else</span>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 6.3 - <span class="code">Rational</span> with a private field and method.<a id="i694224322-2"></a><a id="i1692219636-2"></a><a id="i-1558980393-1"></a><a id="i-1621898821-1"></a></h5>


<p>In this version of <span class="code">Rational</span>, we added a private field, <span class="code">g</span>, and modified the initializers<!-- -->
for <span class="code">numer</span> and <span class="code">denom</span>. (An <em>initializer</em> is the code that initializes a variable, for example, the
"<span class="code">n</span>&nbsp;<span class="code">/</span>&nbsp;<span class="code">g</span>" that initializes <span class="code">numer</span>.) Because <span class="code">g</span> is private, it can be accessed inside the body of the class, but not
outside<a id="i1857067865-1"></a>. We also added a private method, <span class="code">gcd</span>, which calculates the greatest common
divisor of two passed <span class="code">Int</span>s. For example, <span class="code">gcd(12,</span>&nbsp;<span class="code">8)</span> is <span class="code">4</span>. 
As you saw in <a href="classes-and-objects.html#sec:classes-fields-methods">Section 4.1</a>,
to make a field or method private
you simply place the <span class="code">private</span> keyword in front of its definition.
The purpose of the private "helper method" <span class="code">gcd</span> is to factor out code needed by
some other part of the class, in this case, the primary constructor. To ensure <span class="code">g</span> is always positive, we
pass the absolute value of <span class="code">n</span> and <span class="code">d</span>, which we obtain by invoking
<span class="code">abs</span> on them, a method you can invoke on any <span class="code">Int</span> to get its
absolute value.<a id="i-1171773097-1"></a></p>

<p>The Scala compiler will place the code for the initializers of <span class="code">Rational</span>'s three 
fields into the primary constructor in the order in which they appear
in the source code.<a id="i-400083503-1"></a> Thus, <span class="code">g</span>'s initializer, <span class="code">gcd(n.abs,</span>&nbsp;<span class="code">d.abs)</span>, will execute before the other two,
because it appears first in the source. Field <span class="code">g</span> will be initialized with the result, the 
greatest common divisor of the absolute value of the class parameters, <span class="code">n</span> and <span class="code">d</span>.
Field <span class="code">g</span> is then used in the initializers of <span class="code">numer</span> and <span class="code">denom</span>. By dividing <span class="code">n</span> and <span class="code">d</span> by their greatest common divisor, <span class="code">g</span>, every <span class="code">Rational</span> will be constructed in
its normalized form:
<pre>
  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">66</span>,&nbsp;<span class="literal">42</span>)
  <span class="output">res7:&nbsp;Rational&nbsp;=&nbsp;11/7</span>
</pre><!-- --></p>

<h3><a name="6.9"></a>6.9 Defining operators <span style="font-size: .5em">[<a href="functional-objects.html#6.9">link</a>]</span></h3>


<p>The current implementation of <span class="code">Rational</span> addition is OK, but
could be made more convenient to use. You might ask yourself why you
can write:
<pre>
  x&nbsp;+&nbsp;y
</pre><!-- -->
if <span class="code">x</span> and <span class="code">y</span> are integers or floating-point 
numbers, but you have to write:
<pre>
  x.add(y)
</pre><!-- -->
or at least:<span style="color:#fff">$sn8978$</span>
<pre>
  x&nbsp;add&nbsp;y
</pre><!-- -->
if they are rational numbers. There's no convincing reason why this
should be so.  Rational numbers are numbers just like other numbers. In a
mathematical sense they are even more natural than, say, floating-point
numbers. Why should you not use the natural arithmetic operators on
them? In Scala you can do this. In the rest of this chapter, we'll show you how.</p>

<p>The first step is to replace <span class="code">add</span> by the usual
mathematical symbol. This is straightforward, as <span class="code">+</span>
is a legal identifier in Scala. We can simply define a method with
<span class="code">+</span> as its name. While we're at it, you may as well implement a method
named <span class="code">*</span> that performs multiplication. The result is shown in <a href="functional-objects.html#lst:operator-methods">Listing 6.4</a>:</p>

<p><a name="lst:operator-methods"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<span class="literal">0</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">val</span>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;<span class="vem">this</span>(n:&nbsp;<span class="typename">Int</span>)&nbsp;=&nbsp;<span class="vem">this</span>(n,&nbsp;<span class="literal">1</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;*&nbsp;(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(numer&nbsp;*&nbsp;that.numer,&nbsp;denom&nbsp;*&nbsp;that.denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;gcd(a:&nbsp;<span class="typename">Int</span>,&nbsp;b:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(b&nbsp;==&nbsp;<span class="literal">0</span>)&nbsp;a&nbsp;<span class="vem">else</span>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 6.4 - <span class="code">Rational</span> with operator methods.</h5>


<p>With class <span class="code">Rational</span> defined in this manner, you can now write:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>)
  <span class="output">x:&nbsp;Rational&nbsp;=&nbsp;1/2</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;y&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">y:&nbsp;Rational&nbsp;=&nbsp;2/3</span>
  <br />  scala&gt;&nbsp;x&nbsp;+&nbsp;y
  <span class="output">res8:&nbsp;Rational&nbsp;=&nbsp;7/6</span>
</pre><!-- -->
As always, the operator syntax on the last input line is equivalent to 
a method call.<a id="i-614149608-3"></a> You could also write:
<pre>
  scala&gt;&nbsp;x.+(y)
  <span class="output">res9:&nbsp;Rational&nbsp;=&nbsp;7/6</span>
</pre><!-- -->
but this is not as readable.</p>

<p>Another thing to note is that given Scala's rules for operator precedence, which were described
in <a href="basic-types-and-operations.html#sec:precedence">Section 5.8</a>, the <span class="code">*</span> method will bind more tightly than the <span class="code">+</span> method
for <span class="code">Rational</span>s. In other words, expressions involving <span class="code">+</span> and <span class="code">*</span> operations on <span class="code">Rational</span>s will
behave as expected.<a id="i1955596960-2"></a><a id="i2084616098-2"></a> For example, <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">y</span> will execute as <span class="code">x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">(x</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">y)</span>, not <span class="code">(x</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">x)</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">y</span>:
<pre>
  scala&gt;&nbsp;x&nbsp;+&nbsp;x&nbsp;*&nbsp;y
  <span class="output">res10:&nbsp;Rational&nbsp;=&nbsp;5/6</span>
  <br />  scala&gt;&nbsp;(x&nbsp;+&nbsp;x)&nbsp;*&nbsp;y
  <span class="output">res11:&nbsp;Rational&nbsp;=&nbsp;2/3</span>
  <br />  scala&gt;&nbsp;x&nbsp;+&nbsp;(x&nbsp;*&nbsp;y)
  <span class="output">res12:&nbsp;Rational&nbsp;=&nbsp;5/6</span>
</pre><!-- --></p>

<h3><a name="6.10"></a>6.10 Identifiers in Scala <span style="font-size: .5em">[<a href="functional-objects.html#6.10">link</a>]</span></h3>


<p>You have now seen the two most important ways to form an identifier in
Scala: alphanumeric and operator. Scala has very flexible rules for
forming identifiers. Besides the two forms you have seen there are
also two others. All four forms of identifier formation are described in
this section.<a id="i1368189162-1"></a></p>

<p>An <span style="font-style:italic">alphanumeric identifier</span> starts with a letter or underscore, which can be followed by further letters, digits, or
underscores. The `$' character also counts as a letter, however it is reserved for
identifiers generated by the Scala compiler. Identifiers in user
programs should not contain `$' characters, even though it will compile; if they do this might lead to name clashes
with identifiers generated by the Scala compiler.<a id="i-890920833-1"></a></p>

<p>Scala follows Java's convention of using camel-case<a href="functional-objects.html#footnote6-5">[5]</a> identifiers,<a id="i81954455-1"></a> such as <span class="code">toString</span> and <span class="code">HashSet</span>.<a id="i857734909-1"></a><a id="i-917788527-1"></a><a id="i350029111-1"></a><a id="i-1611050102-1"></a>
Although underscores are legal in identifiers, they are not used that often in Scala programs, in part to be
consistent with Java, but also because underscores have many other
non-identifier uses in Scala code<a id="i1978221382-1"></a>. As a result, it
is best to avoid identifiers like <span class="code">to_string</span>, <span class="code">__init__</span>, or <span class="code">name_</span>.
Camel-case names of fields, method parameters, local variables, and functions should start with lower case letter,
for example: <span class="code">length</span>, <span class="code">flatMap</span>, and <span class="code">s</span>. Camel-case names of classes and traits should start with an upper
case letter, for example: <span class="code">BigInt</span>, <span class="code">List</span>, and <span class="code">UnbalancedTreeMap</span>.<a href="functional-objects.html#footnote6-6">[6]</a></p>

<div class="note">
<h4>Note</h4>


<p>One consequence of using a trailing underscore in an identifier is that if you attempt, for example, to write a declaration like this, "<span class="code">val</span>&nbsp;<span class="code">name_:</span>&nbsp;<span class="code">Int</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">1</span>", you'll
get a compiler error. The compiler will think you are trying to declare a <span class="code">val</span> named "<span class="code">name_:</span>". To get this to compile, you would need to insert
an extra space before the colon, as in: "<span class="code">val</span>&nbsp;<span class="code">name_</span>&nbsp;<span class="code">:</span>&nbsp;<span class="code">Int</span>&nbsp;<span class="code">=</span>&nbsp;<span class="code">1</span>".</p>

</div>


<p>One way in which Scala's conventions depart from Java's involves constant names.<a id="i-422276785-1"></a> In Scala, the word <em>constant</em> does not just
mean <span class="code">val</span>. Even though a <span class="code">val</span> does remain constant after it is initialized, it is still a variable. For example, method parameters
are <span class="code">val</span>s, but each time the method is called those <span class="code">val</span>s can hold different values. A constant is more permanent.
For example, <span class="code">scala.Math.Pi</span> is defined to be the
double value closest to the real value of &pi;, the ratio of a circle's circumference to its diameter. 
This value is unlikely to change ever, thus, <span class="code">Pi</span> is clearly a constant. You can also use constants to give names to values
that would otherwise be <em>magic numbers</em> in your code:<a id="i1838929623-1"></a> literal values with no explanation, which in the worst case appear
in multiple places. You may also want to define constants for use in pattern matching, a use case that
will be described in <a href="case-classes-and-pattern-matching.html#subsec:kinds-of-patterns-variables">Section 15.2</a>. In Java, the convention is to give constants names that
are all upper case, with underscores separating the words, such as <span class="code">MAX_VALUE</span> or <span class="code">PI</span>. In Scala, the convention is merely that
the first character should<!-- --> be upper case. Thus, constants named
in the Java style, such as <span class="code">X_OFFSET</span>, will work as Scala constants, but the Scala convention is to use
camel case for constants, such as <span class="code">XOffset</span>.</p>

<p>An <span style="font-style:italic">operator identifier</span> consists of one or more 
operator characters.<a id="i1206563604-1"></a><a id="i-12268236-1"></a> Operator characters are printable ASCII 
characters such as <span class="code">+</span>, <span class="code">:</span>, <span class="code">?</span>, <span class="code"><span style="font-size:large">~</span></span> or <span class="code">#</span>.<a href="functional-objects.html#footnote6-7">[7]</a>
Here are some examples of operator identifiers:</p>

<div align="center">
<span class="code">+</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">++</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">&lt;?&gt;</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">:-&gt;</span>


</div>


<p>The Scala compiler will internally "mangle" operator identifiers to turn
them into legal Java identifiers with embedded <span class="code">$</span> characters. For instance, 
the identifier <span class="code">:-&gt;</span> would be represented internally 
as <span class="code">$colon$minus$greater</span>. If you ever wanted to access this identifier<!-- --> from Java code, 
you'd need to use this internal representation.</p>

<p>Because operator identifiers in Scala can become arbitrarily long,
there is a small difference between Java and Scala.  In Java,
the input <span class="code">x&lt;-y</span> would be parsed as four lexical symbols, so it would be
equivalent to <span class="code">x</span>&nbsp;<span class="code">&lt;</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">y</span>. In Scala, <span class="code">&lt;-</span> would be parsed as a single identifier,
giving <span class="code">x</span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code">y</span>. If you want the first interpretation, you need to separate
the <span class="code">&lt;</span> and the <span class="code">-</span> characters by a space. This is unlikely to 
be a problem in practice, as very few people would write <span class="code">x&lt;-y</span> in Java
without inserting spaces or parentheses between the operators.</p>

<p>A <span style="font-style:italic">mixed identifier</span> consists of an alphanumeric identifier, which is followed by
an underscore and an operator
identifier.<a id="i-1955463099-1"></a><a id="i1641787755-1"></a> For example, <span class="code">unary_+</span><a id="i-1088310403-2"></a> used as a method
name defines a unary <span class="code">+</span> operator. Or, 
<span class="code">myvar_=</span> used as method name defines an assignment operator.
In addition, the mixed identifier form
<span class="code">myvar_=</span> is generated by the Scala compiler to support <span style="font-style:italic">properties</span>; 
more on that in <a href="stateful-objects.html">Chapter 18</a><a id="i-926053069-1"></a>.</p>

<p><a name="sec:literal-identifier"></a>
A <span style="font-style:italic">literal identifier</span> is an arbitrary string enclosed in back ticks
(<span class="code">`</span> ...<span class="code">`</span>).<a id="i-144177089-1"></a><a id="i-1241489226-1"></a><a id="i1204364761-1"></a> Some examples of literal identifiers are:</p>

<div align="center">
<span class="code">`x`</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">`&lt;clinit&gt;`</span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code"></span>&nbsp;<span class="code">`yield`</span>


</div>


<p>The idea is that you can put any string that's accepted by the runtime
as an identifier between back ticks. The result is always a Scala
identifier. This works even if the name contained in the back ticks
would be a Scala reserved word<a id="i1517246665-1"></a>.  
A typical use case is accessing the static <span class="code">yield</span> method in Java's
<span class="code">Thread</span> class. You cannot write <span class="code">Thread.yield()</span> because <span class="code">yield</span> is
a reserved word in Scala. However, you can still name the method
in back ticks, <i>e.g.</i>, <span class="code">Thread.`yield`()</span>.</p>

<h3><a name="6.11"></a>6.11 Method overloading <span style="font-size: .5em">[<a href="functional-objects.html#6.11">link</a>]</span></h3>


<p><a name="sec:method-overloading"></a></p>

<p>Back to class <span class="code">Rational</span>. With the latest changes, you can now do<a id="i-1178969056-1"></a><a id="i1636832800-1"></a>
addition and multiplication operations in a natural style on rational numbers. But
one thing still missing is mixed arithmetic. For instance, you cannot
multiply a rational number by an integer, because the operands of
<span class="code">*</span> always have to be <span class="code">Rational</span>s. So for a rational number <span class="code">r</span> you
can't write <span class="code">r</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span>. You must write <span class="code">r</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">new</span>&nbsp;<span class="code">Rational(2)</span>, which is not as
nice.</p>

<p>To make <span class="code">Rational</span> even more convenient, we'll add new methods
to the class that perform mixed addition and multiplication on rational numbers and integers.
While we're at it, we'll add methods for subtraction and division
too. The result
is shown in <a href="functional-objects.html#lst:overloaded-methods">Listing 6.5</a>.</p>

<p><a name="lst:overloaded-methods"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Rational</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;require(d&nbsp;!=&nbsp;<span class="literal">0</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">val</span>&nbsp;g&nbsp;=&nbsp;gcd(n.abs,&nbsp;d.abs)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numer&nbsp;=&nbsp;n&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denom&nbsp;=&nbsp;d&nbsp;/&nbsp;g
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;<span class="vem">this</span>(n:&nbsp;<span class="typename">Int</span>)&nbsp;=&nbsp;<span class="vem">this</span>(n,&nbsp;<span class="literal">1</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(i:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(numer&nbsp;+&nbsp;i&nbsp;*&nbsp;denom,&nbsp;denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;-&nbsp;(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;-&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;-&nbsp;(i:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(numer&nbsp;-&nbsp;i&nbsp;*&nbsp;denom,&nbsp;denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;*&nbsp;(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(numer&nbsp;*&nbsp;that.numer,&nbsp;denom&nbsp;*&nbsp;that.denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;*&nbsp;(i:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(numer&nbsp;*&nbsp;i,&nbsp;denom)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;/&nbsp;(that:&nbsp;<span class="typename">Rational</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(numer&nbsp;*&nbsp;that.denom,&nbsp;denom&nbsp;*&nbsp;that.numer)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;/&nbsp;(i:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Rational</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(numer,&nbsp;denom&nbsp;*&nbsp;i)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;denom
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;gcd(a:&nbsp;<span class="typename">Int</span>,&nbsp;b:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(b&nbsp;==&nbsp;<span class="literal">0</span>)&nbsp;a&nbsp;<span class="vem">else</span>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 6.5 - <span class="code">Rational</span> with overloaded methods.<a id="i-1789856-1"></a></h5>


<p>There are now two versions each of the arithmetic methods: one
that takes a rational as its argument and another that takes an integer.
In other words, each of these method names is <em>overloaded</em>, because each name is now being used by multiple
methods. For example, the name <span class="code">+</span> is used by one method that takes a <span class="code">Rational</span> and another that takes an <span class="code">Int</span>. In a method call,
the compiler picks the version of an overloaded method that correctly matches the
types of the arguments.  For instance, if the argument <span class="code">y</span> in
<span class="code">x.+(y)</span> is a <span class="code">Rational</span>, the compiler will pick the method <span class="code">+</span> that takes a
<span class="code">Rational</span> parameter. But if the argument is an integer, 
the compiler will pick the method <span class="code">+</span> that takes an <span class="code">Int</span> parameter instead.
If you try this:<!-- -->
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">x:&nbsp;Rational&nbsp;=&nbsp;2/3</span>
  <br />  scala&gt;&nbsp;x&nbsp;*&nbsp;x
  <span class="output">res13:&nbsp;Rational&nbsp;=&nbsp;4/9</span>
  <br />  scala&gt;&nbsp;x&nbsp;*&nbsp;<span class="literal">2</span>
  <span class="output">res14:&nbsp;Rational&nbsp;=&nbsp;4/3</span>
</pre><!-- -->
You'll see that the <span class="code">*</span> method invoked is determined in each case by the type of the right operand.</p>

<div class="note">
<h4>Note</h4>


<p>Scala's process of overloaded method resolution is very similar to Java's.
In every case, the chosen overloaded version is the one that
best matches the static types of the arguments. Sometimes there is no unique
best matching version; in that case the compiler will give you an 
"ambiguous reference" error.<!-- --></p>

</div>


<h3><a name="6.12"></a>6.12 Implicit conversions <span style="font-size: .5em">[<a href="functional-objects.html#6.12">link</a>]</span></h3>


<p>Now that you can write <span class="code">r</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">2</span>, you might also want to swap the operands, as in <span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">r</span>. Unfortunately this does not work yet:<a id="i869323971-1"></a>
<pre>
  scala&gt;&nbsp;<span class="literal">2</span>&nbsp;*&nbsp;r
  <span class="output">&lt;console&gt;:7:&nbsp;error:&nbsp;overloaded&nbsp;method&nbsp;value&nbsp;*&nbsp;with&nbsp;</span>
  <span class="output">alternatives&nbsp;(Double)Double&nbsp;&lt;and&gt;&nbsp;(Float)Float&nbsp;&lt;and&gt;&nbsp;</span>
  <span class="output">(Long)Long&nbsp;&lt;and&gt;&nbsp;(Int)Int&nbsp;&lt;and&gt;&nbsp;(Char)Int&nbsp;&lt;and&gt;&nbsp;(Short)Int&nbsp;</span>
  <span class="output">&lt;and&gt;&nbsp;(Byte)Int&nbsp;cannot&nbsp;be&nbsp;applied&nbsp;to&nbsp;(Rational)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;*&nbsp;r</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<p>The problem here is that <span class="code">2</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">r</span> is equivalent to <span class="code">2.*(r)</span>, so it is
a method call on the number <span class="code">2</span>, which is an integer. But the <span class="code">Int</span>
class contains no multiplication method that takes a <span class="code">Rational</span>
argument&mdash;it couldn't because class <span class="code">Rational</span> is 
not a standard class in the Scala library.</p>

<p>However, there is another way to solve this problem in Scala: You can
create an implicit conversion that automatically converts integers to
rational numbers when needed.<a id="i-2127602858-1"></a> Try adding this line in the interpreter:
<pre>
  scala&gt;&nbsp;<span class="vem">implicit</span>&nbsp;<span class="vem">def</span>&nbsp;intToRational(x:&nbsp;<span class="typename">Int</span>)&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(x)
</pre><!-- -->
This defines a conversion method from <span class="code">Int</span> to <span class="code">Rational</span>. The <span class="code">implicit</span> 
modifier in front of the method tells the compiler to apply it automatically
in a number of situations<a id="i-425423387-1"></a>. With the conversion defined, you can now retry the example that failed before:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;r&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(<span class="literal">2</span>,<span class="literal">3</span>)
  <span class="output">r:&nbsp;Rational&nbsp;=&nbsp;2/3</span>
  <br />  scala&gt;&nbsp;<span class="literal">2</span>&nbsp;*&nbsp;r
  <span class="output">res16:&nbsp;Rational&nbsp;=&nbsp;4/3</span>
</pre><!-- -->
Note that for an implicit conversion to work, it needs to be in scope. If you place the implicit method definition
inside class <span class="code">Rational</span>, it won't be in scope in the interpreter. For now, you'll need to define it directly in the interpreter.</p>

<p>As you can glimpse from this example, implicit conversions are
a very powerful technique for making libraries more flexible and more
convenient to use. Because they are so powerful, they can also 
be easily misused. You'll find out more on implicit
conversions, including ways to  bring them into scope where they are needed, in <a href="implicit-conversions-and-parameters.html">Chapter 21</a>.</p>

<h3><a name="6.13"></a>6.13 A word of caution <span style="font-size: .5em">[<a href="functional-objects.html#6.13">link</a>]</span></h3>


<p>As this chapter has demonstrated, creating methods with operator names<a id="i771080752-1"></a>
and defining implicit conversions can help you design libraries for
which client code is concise and easy to understand. Scala gives
you a great deal of power to design such easy-to-use libraries, but
please bear in mind that with power comes responsibility.</p>

<p>If used unartfully, both operator methods and implicit conversions can give rise to
client code that is hard to read and understand. Because implicit conversions are applied
implicitly by the compiler, not explicitly written down in the source code, it can be
non-obvious to client programmers what implicit conversions are being applied. And although
operator methods will usually make client code more concise, they will only make it more
readable to the extent client programmers will be able to recognize and remember
the meaning of each operator.</p>

<p>The goal you should keep in mind as you design libraries is not merely<a id="i-506868082-1"></a>
enabling concise client code, but readable, understandable client
code. Conciseness will often be a big part of that readability, but
you can take conciseness too far. By designing libraries that enable
tastefully concise and at the same time understandable client code,
you can help those client programmers work productively.</p>

<h3><a name="6.14"></a>6.14 Conclusion <span style="font-size: .5em">[<a href="functional-objects.html#6.14">link</a>]</span></h3>


<p>In this chapter, you saw more aspects of classes in Scala.  You
saw how to add parameters to a class, define several
constructors, define operators as methods, and customize
classes so that they are natural to use.  Maybe most importantly, you saw that defining and using immutable
objects is a quite natural way to code in Scala.</p>

<p>Although the final version of <span class="code">Rational</span> shown in this chapter
fulfills the requirements set forth at the beginning of the chapter,
it could still be improved. We will in fact return to this example
later in the book. For example, in
<a href="object-equality.html">Chapter 28</a>, you'll learn how to
override <span class="code">equals</span> and <span class="code">hashcode</span> to allow <span class="code">Rational</span>s to behave
better when compared with <span class="code">==</span> or placed into hash tables.
In <a href="implicit-conversions-and-parameters.html">Chapter 21</a>, you'll learn
how to place implicit method definitions in a companion object for
<span class="code">Rational</span>, so they can be more easily placed into scope when client
programmers are working with <span class="code">Rational</span>s.</p>

<hr/>
<h4>Footnotes for Chapter 6:</h4>


<p><a name="footnote6-1">[1]</a> The <span class="code">require</span> method is defined in standalone
object, <span class="code">Predef</span>. As mentioned in <a href="classes-and-objects.html#sec:a-scala-application">Section 4.4</a>, <span class="code">Predef</span>'s members are imported automatically
into every Scala source file.</p>

<p><a name="footnote6-2">[2]</a> Actually, you could add
a <span class="code">Rational</span> to itself, in which case <span class="code">that</span> would refer to the object on which <span class="code">add</span> was invoked. But because 
you can pass any <span class="code">Rational</span> object to <span class="code">add</span>, the compiler still won't let you say <span class="code">that.n</span>.</p>

<p><a name="footnote6-3">[3]</a> In <a href="composition-and-inheritance.html#sec:parametric-fields">Section 10.6</a>
you'll find out about <em>parametric fields</em>, which provide a
shorthand for writing the same code.</p>

<p><a name="footnote6-4">[4]</a> Even though <span class="code">n</span> and <span class="code">d</span> are used
in the body of the class, given they are only used inside
constructors, the Scala compiler will not emit fields for them. Thus, given this code the Scala compiler will
generate a class with two <span class="code">Int</span> fields, one for <span class="code">numer</span> and one for <span class="code">denom</span>.</p>

<p><a name="footnote6-5">[5]</a> This style of naming identifiers is called <em>camel case</em> because the identifiersHaveHumps consisting of the embedded capital letters.</p>

<p><a name="footnote6-6">[6]</a> In <a href="working-with-lists.html#sec:list-patterns">Section 16.5</a>, you'll see that sometimes
you may want to give a special kind of class known as a <em>case class</em> a name consisting solely of operator characters. For example,
the Scala API contains a class named <span class="code">::</span>, which facilitates pattern matching on <span class="code">List</span>s.</p>

<p><a name="footnote6-7">[7]</a> More precisely, an operator character
belongs to the Unicode set of mathematical symbols(Sm) or other symbols(So), 
or to the 7-bit ASCII characters that are not letters, digits, 
parentheses, square brackets, curly braces, single or double quote, or an underscore, period, semi-colon, comma,
or back tick character.</p>



<br clear="all">
<p>
<center>
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/functional-objectsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/basic-types-and-operations.html">Previous</a>&nbsp;| 
<a href="/pins1ed/builtin-control-structures.html">Next</a>
</div>
</center>
</div>
<hr width="100%" />
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<br />
<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/custom">
<table border="0" bgcolor="#ffffff">
<tr><td nowrap="nowrap" valign="top" align="left" height="32">
<a href="http://www.google.com/">
<img src="http://www.google.com/logos/Logo_25wht.gif"
border="0" alt="Google"></img></a>
</td>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="Artima.com"></input>
<input type="text" name="q" size="31" maxlength="255" value=""></input>
<input type="submit" name="sa" value="Search"></input>
</td></tr>
<tr>
<td>&nbsp;</td>
<td nowrap="nowrap">
<font size="-1" color="#000000">
<input type="radio" name="sitesearch" value=""></input> Web
<input type="radio" name="sitesearch" value="Artima.com" checked="checked"></input>Artima.com
</font>&nbsp;&nbsp;
<input type="hidden" name="client" value="pub-3911176865765226"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:http://www.artima.com/images/artima150.gif;S:http://www.artima.com;FORID:1;"></input>
<input type="hidden" name="hl" value="en"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</center>
<div class="sp">
<div style="text-align: center">
<a href="http://www.artima.com/copyright.html">Copyright</a> &copy; 1996-2014 Artima, Inc. All Rights Reserved.</a> - <a href="http://www.artima.com/privacy.html">Privacy Policy</a> - <a href="http://www.artima.com/termsofuse.html">Terms of Use</a> - <a href="http://www.artima.com/advertising.html">Advertise with Us</a>
</div>
</div>
<br />
</body>
</html>
