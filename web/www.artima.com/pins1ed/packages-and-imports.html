<html>
<head>
<title>Packages and Imports</title>
<meta name="description" content="
" />
<meta name="keywords" content="scala" />
<meta name="author" content="Martin Odersky, Lex Spoon, and Bill Venners" />
<link rel="stylesheet" type="text/css" href="/artima.css" />
<link rel="shortcut icon" href="/favicon.ico" />
</head>
<body><table width="100%" cellspacing="0">
<tr>
<td align="left" valign="bottom">
<a href="/index.jsp"><img src="/images/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43" /></a>
</td>
</table>
<table width="100%" bgcolor="#333333">
<tr>
<td align="center">
<div class="ml">
<a href="/articles" class="hl">Articles</a>&nbsp;|
<a href="/news/index.jsp" class="hl">News</a>&nbsp;|
<a href="/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;|
<a href="/buzz/index.jsp" class="hl">Buzz</a>&nbsp;|
<a href="/shop/catalog" class="hl">Books</a>&nbsp;|
<a href="/forums/index.jsp" class="hl">Forums</a>
</div>
</td>
</tr>
</table>
<table width="100%" bgcolor="#AACCFF">
<tr>
<td align="center">
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/packages-and-importsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/traits.html">Previous</a>&nbsp;| 
<a href="/pins1ed/assertions-and-unit-testing.html">Next</a>
</div>
</td>
</tr>
</table>
<BR>
<div class="vegies">
<div class="tc">
<span class="sts">Chapter 13 of Programming in Scala, First Edition</span><br />
<span class="ts">Packages and Imports</span><br />
<span class="as">by Martin Odersky, Lex Spoon, and Bill Venners</span><br />
<span class="pd">December 10, 2008</span><br />
</div>




<p>When working on a program, especially a large one,
it is important to minimize <em>coupling</em>&mdash;the extent to which
the various parts of the program rely on the other parts. Low coupling reduces the risk that a small, seemingly innocuous change
in one part of the program will have devastating consequences in another part.  One way to
minimize coupling is to write in a modular style.  You divide the program into a number of smaller modules, each of which has
an inside and an outside.  When working on the inside of a
module&mdash;its <em>implementation</em>&mdash;you need only coordinate with
other programmers working on that very same module.  Only when you must change the outside of a module&mdash;its <em>interface</em>&mdash;is it
necessary to coordinate with developers working on other modules.<a id="i750867693-1"></a></p>

<p>This chapter shows several constructs that help you program in a
modular style.  It shows how to place things in packages, make
names visible through imports, and control the visibility of
definitions through access modifiers.  The constructs are similar in
spirit to constructs in Java, but there are some
differences&mdash;usually ways that are more consistent&mdash;so it's worth reading this
chapter even if you already know Java.</p>

<h3><a name="13.1"></a>13.1 Packages <span style="font-size: .5em">[<a href="packages-and-imports.html#13.1">link</a>]</span></h3>


<p>Scala code resides in the Java platform's global hierarchy of packages.
The example code
you've seen so far in this book has been in the <em>unnamed</em> package.<a id="i305704921-1"></a><a id="i38834278-1"></a>
You can place code into named packages in Scala in two ways. First, you
can place the contents of an entire file into a package<!-- -->
by putting a <span class="code">package</span> clause at the top of the file, as shown in <a href="packages-and-imports.html#lst:entire-file-package">Listing 13.1</a>.</p>

<p><a name="lst:entire-file-package"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;bobsrockets.navigation
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Navigator</span>
</pre><!-- -->


<h5>Listing 13.1 - Placing the contents of an entire file into a package.<a id="i-1154528502-1"></a></h5>


<p>The <span class="code">package</span> clause of <a href="packages-and-imports.html#lst:entire-file-package">Listing 13.1</a> places class <span class="code">Navigator</span> into the package named
<span class="code">bobsrockets.navigation</span>.  Presumably, this is the navigation
software developed by Bob's Rockets, Inc.</p>

<div class="note">
<h4>Note</h4>
Because Scala code is part of the Java ecosystem, it is
recommended to follow Java's reverse-domain-name convention for Scala packages that you release to the public. 
Thus, a better name for <span class="code">Navigator</span>'s package might be <span class="code">com.bobsrockets.navigation</span>. In this chapter, however,
we'll leave off the "<span class="code">com.</span>" to make the examples easier to understand.


</div>


<p>The other way you can place code into packages in Scala is more like C# namespaces.<a id="i-999496559-1"></a> You follow a package clause
by a section in curly braces that contains the
definitions that go into the package.  Among other things, this syntax
lets you put different parts of a file into different packages.  For
example, you might include a class's tests in the same file as the
original code, but put the tests in a different package, as shown<a id="i-1775661018-1"></a>
in <a href="packages-and-imports.html#lst:nesting-packages">Listing 13.2</a>:
<a name="lst:nesting-packages"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;navigation&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Navigator</span>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;tests&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation.tests</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">NavigatorSuite</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.2 - Nesting multiple packages in the same file.</h5>


<p>The Java-like syntax shown in <a href="packages-and-imports.html#lst:entire-file-package">Listing 13.1</a> is
actually just syntactic sugar for the more general nested syntax shown in <a href="packages-and-imports.html#lst:nesting-packages">Listing 13.2</a>. In fact, if you do nothing with a package except nest another package inside it,
you can save a level of indentation using the approach shown in <a href="packages-and-imports.html#lst:dot-and-nested">Listing 13.3</a>:</p>

<p><a name="lst:dot-and-nested"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;bobsrockets.navigation&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Navigator</span>
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;tests&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;In&nbsp;package&nbsp;bobsrockets.navigation.tests</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">NavigatorSuite</span>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.3 - Nesting packages with minimal indentation.</h5>


<p>As this notation hints, Scala's packages truly nest.  That is, package
<span class="code">navigation</span> is semantically <em>inside</em> of package <span class="code">bobsrockets</span>.
Java packages, despite being hierarchical, do not nest.  In Java,
whenever you name a package, you have to start at the root of the
package hierarchy.  Scala uses a more regular rule in order to
simplify the language.</p>

<p>Take a look at <a href="packages-and-imports.html#lst:packages-truly-nest">Listing 13.4</a>.  Inside the
<span class="code">Booster</span> class, it's not necessary to reference <span class="code">Navigator</span>
as <span class="code">bobsrockets.navigation.Navigator</span>, its fully qualified name.
Since packages nest, it can be referred to as simply as
<span class="code">navigation.Navigator</span>.  This shorter name is possible because class
<span class="code">Booster</span> is contained in package <span class="code">bobsrockets</span>, which has
<span class="code">navigation</span> as a member. Therefore, <span class="code">navigation</span> can be referred to
without a prefix, just like the code inside methods of a class can refer to other
methods of that class without a prefix.
<a name="lst:packages-truly-nest"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Navigator</span>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Booster</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;No&nbsp;need&nbsp;to&nbsp;say&nbsp;bobsrockets.navigation.Navigator</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;nav&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">navigation.Navigator</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.4 - Scala packages truly nest.</h5>


<p>Another consequence of Scala's scoping rules is that packages in an
inner scope hide packages of the same name that are defined in an outer scope.<a id="i-370748244-1"></a><a id="i498549358-1"></a>
For instance, consider the code shown in <a href="packages-and-imports.html#lst:hiding-packages">Listing 13.5</a>, which has
three packages named <span class="code">launch</span>. There's one <span class="code">launch</span> in package <span class="code">bobsrockets.navigation</span>,
one in <span class="code">bobsrockets</span>, and one at the top level (in a different file from the other two).  Such repeated names work fine&mdash;after all they are a major
reason to use packages&mdash;but they do mean you must use some care to
access precisely the one you mean.</p>

<p><a name="lst:hiding-packages"></a></p>

<pre>
  &nbsp;&nbsp;<span class="comment">//&nbsp;In&nbsp;file&nbsp;launch.scala</span>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Booster3</span>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<span class="comment">//&nbsp;In&nbsp;file&nbsp;bobsrockets.scala</span>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Booster1</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">MissionControl</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;booster1&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">launch.Booster1</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;booster2&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">bobsrockets.launch.Booster2</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;booster3&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;_root_.launch.Booster3
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Booster2</span>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.5 - Accessing hidden package names.</h5>


<p>To see how to choose the one you mean, take a look at <span class="code">MissionControl</span> in
<a href="packages-and-imports.html#lst:hiding-packages">Listing 13.5</a>.  How would you reference each of <span class="code">Booster1</span>, <span class="code">Booster2</span>,
and <span class="code">Booster3</span>?  Accessing the first one is easiest.  A reference to
<span class="code">launch</span> by itself will get you to package
<span class="code">bobsrockets.navigation.launch</span>, because that is the <span class="code">launch</span> package
defined in the closest enclosing scope.  Thus, you can refer to the
first booster class as simply <span class="code">launch.Booster1</span>.  Referring to the second one
also is not tricky.  You can write <span class="code">bobrockets.launch.Booster2</span> and be
clear about which one you are referencing.  That leaves the question
of the third booster class, however.  How can you access <span class="code">Booster3</span>,
considering that a nested <span class="code">launch</span> package shadows the
top-level one?</p>

<p>To help in this situation, Scala provides a package named <span class="code">_root_</span>
that is outside any package a user can write. Put another way,
every top-level package you can write is treated as a member of
package <span class="code">_root_</span>.  For example, both <span class="code">launch</span> and <span class="code">bobsrockets</span> of <a href="packages-and-imports.html#lst:hiding-packages">Listing 13.5</a> are members
of package <span class="code">_root_</span>. As a result, <span class="code">_root_.launch</span> gives you the top-level
<span class="code">launch</span> package, and <span class="code">_root_.launch.Booster3</span> designates the outermost
booster class.<!-- --></p>

<h3><a name="13.2"></a>13.2 Imports <span style="font-size: .5em">[<a href="packages-and-imports.html#13.2">link</a>]</span></h3>


<p><a name="sec:imports"></a></p>

<p>In Scala, packages and their members can be imported using <span class="code">import</span><a id="i1926037870-2"></a>
clauses.  Imported items can then be accessed by a simple name
like <span class="code">File</span>, as opposed to requiring a qualified name like
<span class="code">java.io.File</span>. For example, consider the code shown in <a href="packages-and-imports.html#lst:bobs-fruits">Listing 13.6</a>:</p>

<p><a name="lst:bobs-fruits"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;bobsdelights
  <br />  &nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Fruit</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;name:&nbsp;<span class="typename">String</span>,
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;color:&nbsp;<span class="typename">String</span>
  &nbsp;&nbsp;)
  <br />  &nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Fruits</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Apple</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Fruit</span>(<span class="quotedstring">"apple"</span>,&nbsp;<span class="quotedstring">"red"</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Orange</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Fruit</span>(<span class="quotedstring">"orange"</span>,&nbsp;<span class="quotedstring">"orange"</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Pear</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Fruit</span>(<span class="quotedstring">"pear"</span>,&nbsp;<span class="quotedstring">"yellowish"</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;menu&nbsp;=&nbsp;<span class="typename">List</span>(<span class="typename">Apple</span>,&nbsp;<span class="typename">Orange</span>,&nbsp;<span class="typename">Pear</span>)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.6 - Bob's delightful fruits, ready for import.</h5>


<p>An <span class="code">import</span> clause makes members of a package or object available by their
names alone without needing to prefix them by the package or object name.
Here are some simple examples:
<pre>
  <span class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;Fruit</span>
  <span class="vem">import</span>&nbsp;bobsdelights.Fruit
  <br />  <span class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;bobsdelights</span>
  <span class="vem">import</span>&nbsp;bobsdelights._
  <br />  <span class="comment">//&nbsp;easy&nbsp;access&nbsp;to&nbsp;all&nbsp;members&nbsp;of&nbsp;Fruits</span>
  <span class="vem">import</span>&nbsp;bobsdelights.Fruits._
</pre><!-- -->
The first of these corresponds to Java's single type import, the second
to Java's <em>on-demand</em> import.<a id="i-410901588-1"></a><a id="i-1858203568-1"></a>
The only difference is that Scala's on-demand
imports are written with a trailing underscore (<span class="code">_</span>) instead of an
asterisk (<span class="code">*</span>) (after all, <span class="code">*</span> is a valid identifier in Scala!).
The third import clause above corresponds to
Java's import of static class fields.</p>

<p>These three imports give you a taste of what imports can do,
but Scala imports are actually much more general.  For one,
imports in Scala can appear anywhere, not just at the beginning of a
compilation unit. Also, they can refer to arbitrary values. For instance,
the import shown in <a href="packages-and-imports.html#lst:importing-object-members">Listing 13.7</a> is possible:
<a name="lst:importing-object-members"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;showFruit(fruit:&nbsp;<span class="typename">Fruit</span>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">import</span>&nbsp;fruit._
  &nbsp;&nbsp;&nbsp;&nbsp;println(name&nbsp;+<span class="quotedstring">"s&nbsp;are&nbsp;"</span>+&nbsp;color)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.7 - Importing the members of a regular (not singleton) object.</h5>


<p>Method <span class="code">showFruit</span> imports all members of its parameter <span class="code">fruit</span>,
which is of type <span class="code">Fruit</span>. The subsequent <span class="code">println</span> statement can
refer to <span class="code">name</span> and <span class="code">color</span> directly. These two references are
equivalent to <span class="code">fruit.name</span> and <span class="code">fruit.color</span>.
This syntax is particularly
useful when you use objects as modules, which will be described in
<a href="modular-programming-using-objects.html">Chapter 27</a>.</p>

<div class="aside">
<h3>Scala's flexible imports</h3>


<p>Scala's <span class="code">import</span> clauses are quite a bit more flexible than
Java's. There are three principal differences. In Scala, imports:</p>

<ul>
<li>may appear anywhere
</li>
<li>may refer to objects (singleton or regular)
in addition to packages
</li>
<li>let you rename and hide some of the imported members
</li></ul>


</div>


<p>Another way Scala's imports are flexible is that
they can import packages themselves, not just their non-package
members.  This is only natural if you think of nested packages
being contained in their surrounding package. For example, in <a href="packages-and-imports.html#lst:importing-package-name">Listing 13.8</a>, 
the package <span class="code">java.util.regex</span> is imported. This makes <span class="code">regex</span> usable as a simple name. To access
the <span class="code">Pattern</span> singleton object from the <span class="code">java.util.regex</span> package, you can just say, <span class="code">regex.Pattern</span>,
as shown in <a href="packages-and-imports.html#lst:importing-package-name">Listing 13.8</a>:</p>

<p><a name="lst:importing-package-name"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">import</span>&nbsp;java.util.regex
  <br />  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">AStarB</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;Accesses&nbsp;java.util.regex.Pattern</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;pat&nbsp;=&nbsp;regex.Pattern.compile(<span class="quotedstring">"a*b"</span>)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.8 - Importing a package name.</h5>


<p>Imports in Scala can also rename or hide members. This is done with an
<span style="font-style:italic">import selector clause</span> enclosed in braces, which follows the
object from which members are imported. Here are some examples:<a id="i-1172048805-1"></a><a id="i-303565265-1"></a><a id="i1981623788-1"></a><a id="i-1574838534-1"></a></p>

<p><!-- --><span class="code">import</span>&nbsp;<span class="code">Fruits.{Apple,</span>&nbsp;<span class="code">Orange}</span></p>

<p><br />
This imports just members <span class="code">Apple</span> and <span class="code">Orange</span> from object
<span class="code">Fruits</span>.</p>

<p><!-- --><span class="code">import</span>&nbsp;<span class="code">Fruits.{Apple</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">McIntosh,</span>&nbsp;<span class="code">Orange}</span></p>

<p><br />
This imports the two members <span class="code">Apple</span> and <span class="code">Orange</span> from object<a id="i1446749334-1"></a><a id="i-1444404533-1"></a>
<span class="code">Fruits</span>. However, the <span class="code">Apple</span> object is renamed to <span class="code">McIntosh</span>.
So this object can be accessed with either <span class="code">Fruits.Apple</span> or
<span class="code">McIntosh</span>. A renaming clause is always of the form 
"<span class="code">&lt;original-name&gt;</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">&lt;new-name&gt;</span>".</p>

<p><!-- --><span class="code">import</span>&nbsp;<span class="code">java.sql.{Date</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">SDate}</span></p>

<p><br />
This imports the SQL date class as <span class="code">SDate</span>, so that you
can simultaneously import the normal Java date class
as simply <span class="code">Date</span>.</p>

<p><!-- --><span class="code">import</span>&nbsp;<span class="code">java.{sql</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">S}</span></p>

<p><br />
This imports the <span class="code">java.sql</span> package as <span class="code">S</span>, so that you
can write things like <span class="code">S.Date</span>.</p>

<p><!-- --><span class="code">import</span>&nbsp;<span class="code">Fruits.{_}</span></p>

<p><br />
This imports all members from object <span class="code">Fruits</span>. It means the same
thing as <span class="code">import</span>&nbsp;<span class="code">Fruits._</span>.<a id="i91932059-1"></a></p>

<p><!-- --><span class="code">import</span>&nbsp;<span class="code">Fruits.{Apple</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">McIntosh,</span>&nbsp;<span class="code">_}</span></p>

<p><br />
This imports all members from object <span class="code">Fruits</span> but renames <span class="code">Apple</span> to <span class="code">McIntosh</span>.</p>

<p><!-- --><span class="code">import</span>&nbsp;<span class="code">Fruits.{Pear</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">_,</span>&nbsp;<span class="code">_}</span><a id="i1258079951-1"></a></p>

<p><br />
This imports all members of <span class="code">Fruits</span> <span style="font-style:italic">except</span> <span class="code">Pear</span>.
A clause of the form "<span class="code">&lt;original-name&gt;</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">_</span>"
excludes <span class="code">&lt;original-name&gt;</span> from the names that are imported. In a sense, renaming 
something to `<span class="code">_</span>' means hiding it altogether. This is useful to avoid<a id="i-236944399-1"></a>
ambiguities. Say you have two packages, <span class="code">Fruits</span> and <span class="code">Notebooks</span>, which both define a class
<span class="code">Apple</span>. If you want to get just the notebook named <span class="code">Apple</span>, and not the fruit, 
you could still use two imports on demand like this:
<pre>
  <span class="vem">import</span>&nbsp;Notebooks._
  <span class="vem">import</span>&nbsp;Fruits.{<span class="typename">Apple</span>&nbsp;=&gt;&nbsp;_,&nbsp;_}
</pre><!-- -->
This would import all <span class="code">Notebooks</span> and all <span class="code">Fruits</span> except for <span class="code">Apple</span>.</p>

<p><br />
These examples demonstrate the great flexibility Scala offers
when it comes to importing members selectively and possibly under
different names.  In summary, an import selector can
consist of the following:</p>

<ul>
<li>A simple name <span class="code">x</span>. This includes <span class="code">x</span> in the set of imported names.
</li>
<li>A renaming clause <span class="code">x</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">y</span>. This makes the member named <span class="code">x</span> visible
      under the name <span class="code">y</span>.
</li>
<li>A hiding clause  <span class="code">x</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">_</span>. This excludes <span class="code">x</span> from the set of imported names.
</li>
<li>A <em>catch-all</em> `<span class="code">_</span>'. This imports all members except those members
      mentioned in a preceding clause. If a catch-all is given, it must come
      last in the list of import selectors.
</li></ul>
The simpler import clauses shown at the beginning of this section
can be seen as special abbreviations of 
import clauses with a selector clause. For example, "<span class="code">import</span>&nbsp;<span class="code">p._</span>" is equivalent to
"<span class="code">import</span>&nbsp;<span class="code">p.{_}</span>" and "<span class="code">import</span>&nbsp;<span class="code">p.n</span>" is equivalent to "<span class="code">import</span>&nbsp;<span class="code">p.{n}</span>".


<h3><a name="13.3"></a>13.3 Implicit imports <span style="font-size: .5em">[<a href="packages-and-imports.html#13.3">link</a>]</span></h3>


<p>Scala adds some imports implicitly to every program. In essence, it is as if<a id="i-1027603681-1"></a><a id="i586706545-2"></a><a id="i1384274725-1"></a>
the following three import clauses had been added to the top of every source file with 
extension "<span class="code">.scala</span>":
<pre>
  <span class="vem">import</span>&nbsp;java.lang._&nbsp;<span class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;java.lang&nbsp;package</span>
  <span class="vem">import</span>&nbsp;scala._&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;scala&nbsp;package</span>
  <span class="vem">import</span>&nbsp;Predef._&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;everything&nbsp;in&nbsp;the&nbsp;Predef&nbsp;object</span>
</pre><!-- --></p>

<p>The <span class="code">java.lang</span> package contains standard Java classes. It is always
implicitly imported on the JVM implementation of Scala. The <span class="code">.NET</span><a id="i77181-3"></a>
implementation would import package <span class="code">system</span> instead, which is
the <span class="code">.NET</span> analogue of <span class="code">java.lang</span>. Because <span class="code">java.lang</span> is imported implicitly, 
you can write <span class="code">Thread</span> instead of <span class="code">java.lang.Thread</span>, for instance.<!-- --><!-- --></p>

<p>As you have no doubt realized by now, the <span class="code">scala</span> package contains
the standard Scala library, with many common classes and
objects. Because <span class="code">scala</span> is imported implicitly, you can write
<span class="code">List</span> instead of <span class="code">scala.List</span>, for instance.</p>

<p>The <span class="code">Predef</span> object contains many definitions of types, methods, and
implicit conversions that are commonly used on Scala programs. For example, because
<span class="code">Predef</span> is imported implicitly, you can write <span class="code">assert</span> instead of
<span class="code">Predef.assert</span>.</p>

<p>The three import clauses above are treated a bit specially in that
later imports overshadow earlier ones. For instance, the
<span class="code">StringBuilder</span> class is defined both in package <span class="code">scala</span> and, from
Java version 1.5 on, also in package <span class="code">java.lang</span>.  Because the
<span class="code">scala</span> import overshadows the <span class="code">java.lang</span> import, the simple name
<span class="code">StringBuilder</span> will refer to <span class="code">scala.StringBuilder</span>, not
<span class="code">java.lang.StringBuilder</span>.</p>

<h3><a name="13.4"></a>13.4 Access modifiers <span style="font-size: .5em">[<a href="packages-and-imports.html#13.4">link</a>]</span></h3>


<p><a name="sec:access-modifiers"></a></p>

<p>Members of packages, classes, or objects can be labeled with the<a id="i436061376-1"></a>
access modifiers <span class="code">private</span> and <span class="code">protected</span>. These modifiers restrict
accesses to the members to certain regions of code.  Scala's
treatment of access modifiers roughly follows Java's but there are
some important differences which are explained in this section.</p>

<h4>Private members</h4>


<p>Private members are treated similarly to Java. A member labeled<a id="i-698337515-1"></a><a id="i835454125-1"></a>
<span class="code">private</span> is visible only inside the class or
object that contains the member definition. 
In Scala, this rule applies
also for inner classes.  This treatment is more consistent, but
differs from Java.  Consider the example shown in <a href="packages-and-imports.html#lst:private-access-differs">Listing 13.9</a>:</p>

<p><a name="lst:private-access-differs"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Outer</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Inner</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;f()&nbsp;{&nbsp;println(<span class="quotedstring">"f"</span>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">InnerMost</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()&nbsp;<span class="comment">//&nbsp;OK</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;(<span class="vem">new</span>&nbsp;<span class="typename">Inner</span>).f()&nbsp;<span class="comment">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</span>
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.9 - How private access differs in Scala and Java.</h5>


<p>In Scala, the access <span class="code">(new</span>&nbsp;<span class="code">Inner).f()</span> is illegal because <span class="code">f</span> is declared <span class="code">private</span>
in <span class="code">Inner</span> and the access is not from within class <span class="code">Inner</span>. By contrast,
the first access to <span class="code">f</span> in class <span class="code">InnerMost</span> is OK, because that access is 
contained in the body of class <span class="code">Inner</span>. Java would permit both accesses 
because it lets an outer class access private members of its inner
classes.</p>

<h4>Protected members</h4>


<p>Access to <span class="code">protected</span> members is also a bit more restrictive than in Java.<a id="i-711542007-1"></a>
In Scala, a <span class="code">protected</span> member is only accessible from subclasses of
the class in which the member is defined.  In Java such accesses are
also possible from other classes in the same package. In Scala, there
is another way to achieve this effect, as described below, so <span class="code">protected</span>
is free to be left as is. The example shown
in <a href="packages-and-imports.html#lst:protected-access-differs">Listing 13.10</a> illustrates protected accesses:
<a name="lst:protected-access-differs"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;p&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Super</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">protected</span>&nbsp;<span class="vem">def</span>&nbsp;f()&nbsp;{&nbsp;println(<span class="quotedstring">"f"</span>)&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Sub</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Super</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Other</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="vem">new</span>&nbsp;<span class="typename">Super</span>).f()&nbsp;&nbsp;<span class="comment">//&nbsp;error:&nbsp;f&nbsp;is&nbsp;not&nbsp;accessible</span>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.10 - How protected access differs in Scala and Java.</h5>


<p>In <a href="packages-and-imports.html#lst:protected-access-differs">Listing 13.10</a>, the access to <span class="code">f</span> in class <span class="code">Sub</span> is OK because <span class="code">f</span> is
declared <span class="code">protected</span> in <span class="code">Super</span> and <span class="code">Sub</span> is a subclass of
<span class="code">Super</span>. By contrast the access to <span class="code">f</span> in <span class="code">Other</span> is not permitted,
because <span class="code">Other</span> does not inherit from <span class="code">Super</span>. In Java, the latter
access would be still permitted because <span class="code">Other</span> is in the same
package as <span class="code">Sub</span>.</p>

<h4>Public members</h4>


<p>Every member not labeled <span class="code">private</span> or <span class="code">protected</span> is
public.  There is no explicit modifier for public members.  Such
members can be accessed from anywhere.</p>

<p><a name="lst:access-qualifiers"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">package</span>&nbsp;bobsrockets&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;navigation&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>[bobsrockets]&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Navigator</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">protected</span>[navigation]&nbsp;<span class="vem">def</span>&nbsp;useStarChart()&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">LegOfJourney</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>[<span class="typename">Navigator</span>]&nbsp;<span class="vem">val</span>&nbsp;distance&nbsp;=&nbsp;<span class="literal">100</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>[<span class="vem">this</span>]&nbsp;<span class="vem">var</span>&nbsp;speed&nbsp;=&nbsp;<span class="literal">200</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">package</span>&nbsp;launch&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">import</span>&nbsp;navigation._
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Vehicle</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>[launch]&nbsp;<span class="vem">val</span>&nbsp;guide&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Navigator</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}</pre><!-- -->


<h5>Listing 13.11 - Flexible scope of protection with access qualifiers.</h5>


<h4>Scope of protection</h4>


<p>Access modifiers in Scala can be augmented with qualifiers. A modifier
of the form <span class="code">private[X]</span> or <span class="code">protected[X]</span> means that access is private or protected
"up to" <span class="code">X</span>, where <span class="code">X</span> designates some enclosing package, class or singleton object.<a id="i488929967-1"></a></p>

<p>Qualified access modifiers give you very fine-grained control over
visibility. In particular they enable you to express Java's
accessibility notions such as package private, package protected, or
private up to outermost class, which are not directly expressible with
simple modifiers in Scala. But they also let you express accessibility
rules that cannot be expressed in Java.
<a href="packages-and-imports.html#lst:access-qualifiers">Listing 13.11</a> presents an example with many access qualifiers being used. 
In this listing, class <span class="code">Navigator</span> is labeled <span class="code">private[bobsrockets]</span>.
This means that this class is visible in all classes and objects
that are contained in package <span class="code">bobsrockets</span>. In particular, the access
to <span class="code">Navigator</span> in object <span class="code">Vehicle</span> is permitted, because <span class="code">Vehicle</span> is
contained 
in package <span class="code">launch</span>, which is contained in
<span class="code">bobsrockets</span>.  On the other hand, all code outside the
package <span class="code">bobsrockets</span> cannot access class <span class="code">Navigator</span>.</p>

<p>This technique is quite useful in large projects that span several
packages. It allows you to define things that are visible in several
sub-packages of your project but that remain hidden from clients
external to your project. The same technique is not possible in Java.
There, once a definition escapes its immediate package boundary, it is
visible to the world at large.</p>

<p>Of course, the qualifier of a <span class="code">private</span> may also be the directly
enclosing package. An example is the access modifier of <span class="code">guide</span>
in object <span class="code">Vehicle</span> in <a href="packages-and-imports.html#lst:access-qualifiers">Listing 13.11</a>. Such an access modifier is equivalent to Java's
package-private access.<a id="i908525335-1"></a></p>

<p><a name="tab:leg-of-journey-private"></a></p>

<h5>Table 13.1 - Effects of private qualifiers on <span class="code">LegOfJourney.distance</span></h5>


<div align="center">
<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <em>no access modifier</em>
  </td>
  <td>
    public access
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">private[bobsrockets]</span>
  </td>
  <td>
    access within outer package
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">private[navigation]</span>
  </td>
  <td>
    same as package visibility in Java
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">private[Navigator]</span>
  </td>
  <td>
    same as <span class="code">private</span> in Java
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">private[LegOfJourney]</span>
  </td>
  <td>
    same as <span class="code">private</span> in Scala
  </td>
</tr>
<tr class="bottomline">
  <td>
    <span class="code">private[this]</span>
  </td>
  <td>
    access only from same object
  </td>
</tr>
</table>


</div>


<p>All qualifiers can also be applied to <span class="code">protected</span>, with the same
meaning as <span class="code">private</span>. That is, a modifier <span class="code">protected[X]</span> in a
class <span class="code">C</span> allows access to the labeled definition in all subclasses
of <span class="code">C</span> and also within the enclosing package, class, or object <span class="code">X</span>.
For instance, the <span class="code">useStarChart</span> method in <a href="packages-and-imports.html#lst:access-qualifiers">Listing 13.11</a>
is accessible in all subclasses of <span class="code">Navigator</span> and also in all
code contained in the enclosing package <span class="code">navigation</span>. It thus
corresponds exactly to the meaning of <span class="code">protected</span> in Java.</p>

<p>The qualifiers of <span class="code">private</span> can also refer to an enclosing class or
object.  For instance the <span class="code">distance</span> variable in class <span class="code">LegOfJourney</span> in <a href="packages-and-imports.html#lst:access-qualifiers">Listing 13.11</a> is
labeled <span class="code">private[Navigator]</span>, so it is visible from everywhere in
class <span class="code">Navigator</span>. This gives the same access capabilities as for
private members of inner classes in Java. A <span class="code">private[C]</span> where <span class="code">C</span>
is the outermost enclosing class is the same as just <span class="code">private</span> in
Java.<a id="i570723644-1"></a><a id="i-1579182668-1"></a></p>

<p>Finally, Scala also has an access modifier that is even more<a id="i-1909160422-1"></a><a id="i623710400-1"></a>
restrictive than <span class="code">private</span>.  A definition labeled <span class="code">private[this]</span>
is accessible only from within the same object that contains the
definition. Such a definition is called <span style="font-style:italic">object-private</span>.
For instance, the definition of <span class="code">speed</span>
in class <span class="code">Navigator</span> in <a href="packages-and-imports.html#lst:access-qualifiers">Listing 13.11</a> is
object-private. This means that any access must not only
be within class <span class="code">Navigator</span>, but it must also be made from
the very same instance of <span class="code">Navigator</span>.  Thus 
the accesses "<span class="code">speed</span>" and "<span class="code">this.speed</span>" would be
legal from within <span class="code">Navigator</span>.
The following access, though, would not be allowed, even if it
appeared inside class <span class="code">Navigator</span>:
<pre>
  <span class="vem">val</span>&nbsp;other&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Navigator</span>
  other.speed&nbsp;<span class="comment">//&nbsp;this&nbsp;line&nbsp;would&nbsp;not&nbsp;compile</span>
</pre><!-- -->
Marking a member <span class="code">private[this]</span> is a guarantee that 
it will not be seen from other objects of the same class. This can be
useful for documentation. It also sometimes lets
you write 
more general variance annotations (see
<a href="type-parameterization.html#variance-object-local">Section 19.7</a> for details).</p>

<p>To summarize, <a href="packages-and-imports.html#tab:leg-of-journey-private">Table 13.1</a> <a href="packages-and-imports.html#tab:leg-of-journey-private">here</a> lists the effects of <span class="code">private</span>
qualifiers. Each line shows a qualified private modifier and what it
would mean if such a modifier were attached to
the <span class="code">distance</span> variable declared in class
<span class="code">LegOfJourney</span> in <a href="packages-and-imports.html#lst:access-qualifiers">Listing 13.11</a>.</p>

<h4>Visibility and companion objects</h4>


<p><a id="i-565810484-1"></a></p>

<p>In Java, static members and instance members belong to the same class,
so access modifiers apply uniformly to them. You have already seen
that in Scala there are no static members; instead you can have a
companion object that contains members that exist only once.<!-- -->
For instance, in <a href="packages-and-imports.html#lst:companion-private">Listing 13.12</a> object <span class="code">Rocket</span> is a companion
of class <span class="code">Rocket</span>:
<a name="lst:companion-private"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Rocket</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">import</span>&nbsp;Rocket.fuel
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;canGoHomeAgain&nbsp;=&nbsp;fuel&nbsp;&gt;&nbsp;<span class="literal">20</span>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Rocket</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;fuel&nbsp;=&nbsp;<span class="literal">10</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;chooseStrategy(rocket:&nbsp;<span class="typename">Rocket</span>)&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(rocket.canGoHomeAgain)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goHome()
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">else</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pickAStar()
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;goHome()&nbsp;{}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;pickAStar()&nbsp;{}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 13.12 - Accessing private members of companion classes and objects.</h5>


<p>Scala's access rules privilege companion objects and classes when it
comes to private or protected accesses. A class shares all its access
rights with its companion object and <i>vice versa</i>.  In particular,
an object can access all private members of its companion class, just
as a class can access all private members of its companion object.</p>

<p>For instance, the <span class="code">Rocket</span> class above can access method <span class="code">fuel</span>,
which is declared <span class="code">private</span> in object <span class="code">Rocket</span>. Analogously, the
<span class="code">Rocket</span> object can access the private method <span class="code">canGetHome</span>
in class <span class="code">Rocket</span>.</p>

<p>One exception where the similarity between Scala and Java breaks down
concerns <span class="code">protected</span> <span class="code">static</span> members.  A protected static member of
a Java class <span class="code">C</span> can be accessed in all subclasses of <span class="code">C</span>.  By
contrast, a <span class="code">protected</span> member in a companion object makes no sense,
as singleton objects don't have any subclasses.</p>

<h3><a name="13.5"></a>13.5 Conclusion <span style="font-size: .5em">[<a href="packages-and-imports.html#13.5">link</a>]</span></h3>


<p>In this chapter, you saw the basic constructs for dividing a program into
packages.  This gives you a simple and useful kind of modularity, so
that you can work with very large bodies of code without different
parts of the code trampling on each other.  This system is the same
in spirit as Java's packages, but there are some
differences where Scala chooses to be more consistent or more general.</p>

<p>Looking ahead, <a href="modular-programming-using-objects.html">Chapter 27</a> describes a more flexible module
system than division into packages.  In addition to letting you
separate code into several namespaces, that approach allows modules to
be parameterized and to inherit from each other. In the next chapter, we'll turn our attention
to assertions and unit testing.</p>



<br clear="all">
<p>
<center>
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/packages-and-importsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/traits.html">Previous</a>&nbsp;| 
<a href="/pins1ed/assertions-and-unit-testing.html">Next</a>
</div>
</center>
</div>
<hr width="100%" />
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<br />
<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/custom">
<table border="0" bgcolor="#ffffff">
<tr><td nowrap="nowrap" valign="top" align="left" height="32">
<a href="http://www.google.com/">
<img src="http://www.google.com/logos/Logo_25wht.gif"
border="0" alt="Google"></img></a>
</td>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="Artima.com"></input>
<input type="text" name="q" size="31" maxlength="255" value=""></input>
<input type="submit" name="sa" value="Search"></input>
</td></tr>
<tr>
<td>&nbsp;</td>
<td nowrap="nowrap">
<font size="-1" color="#000000">
<input type="radio" name="sitesearch" value=""></input> Web
<input type="radio" name="sitesearch" value="Artima.com" checked="checked"></input>Artima.com
</font>&nbsp;&nbsp;
<input type="hidden" name="client" value="pub-3911176865765226"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:http://www.artima.com/images/artima150.gif;S:http://www.artima.com;FORID:1;"></input>
<input type="hidden" name="hl" value="en"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</center>
<div class="sp">
<div style="text-align: center">
<a href="http://www.artima.com/copyright.html">Copyright</a> &copy; 1996-2014 Artima, Inc. All Rights Reserved.</a> - <a href="http://www.artima.com/privacy.html">Privacy Policy</a> - <a href="http://www.artima.com/termsofuse.html">Terms of Use</a> - <a href="http://www.artima.com/advertising.html">Advertise with Us</a>
</div>
</div>
<br />
</body>
</html>
