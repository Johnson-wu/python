<html>
<head>
<title>Working with Lists</title>
<meta name="description" content="
" />
<meta name="keywords" content="scala" />
<meta name="author" content="Martin Odersky, Lex Spoon, and Bill Venners" />
<link rel="stylesheet" type="text/css" href="/artima.css" />
<link rel="shortcut icon" href="/favicon.ico" />
</head>
<body><table width="100%" cellspacing="0">
<tr>
<td align="left" valign="bottom">
<a href="/index.jsp"><img src="/images/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43" /></a>
</td>
</table>
<table width="100%" bgcolor="#333333">
<tr>
<td align="center">
<div class="ml">
<a href="/articles" class="hl">Articles</a>&nbsp;|
<a href="/news/index.jsp" class="hl">News</a>&nbsp;|
<a href="/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;|
<a href="/buzz/index.jsp" class="hl">Buzz</a>&nbsp;|
<a href="/shop/catalog" class="hl">Books</a>&nbsp;|
<a href="/forums/index.jsp" class="hl">Forums</a>
</div>
</td>
</tr>
</table>
<table width="100%" bgcolor="#AACCFF">
<tr>
<td align="center">
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/working-with-listsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/case-classes-and-pattern-matching.html">Previous</a>&nbsp;| 
<a href="/pins1ed/collections.html">Next</a>
</div>
</td>
</tr>
</table>
<BR>
<div class="vegies">
<div class="tc">
<span class="sts">Chapter 16 of Programming in Scala, First Edition</span><br />
<span class="ts">Working with Lists</span><br />
<span class="as">by Martin Odersky, Lex Spoon, and Bill Venners</span><br />
<span class="pd">December 10, 2008</span><br />
</div>




<p>Lists are probably the most commonly used data structure in Scala
programs<a id="i102982549-2"></a>.  This chapter explains lists in detail. It presents many
common operations that can be performed on lists. It also teaches some
important design principles for programs working on lists.</p>

<h3><a name="16.1"></a>16.1 List literals <span style="font-size: .5em">[<a href="working-with-lists.html#16.1">link</a>]</span></h3>


<p>You saw lists already in the preceding chapters, so you know that
a list containing the elements <span class="code">'a'</span>, <span class="code">'b'</span>, and <span class="code">'c'</span> is written
<span class="code">List('a',</span>&nbsp;<span class="code">'b',</span>&nbsp;<span class="code">'c')</span>.<a id="i-2038506824-1"></a> Here are some other examples:
<pre>
  <span class="vem">val</span>&nbsp;fruit&nbsp;=&nbsp;<span class="typename">List</span>(<span class="quotedstring">"apples"</span>,&nbsp;<span class="quotedstring">"oranges"</span>,&nbsp;<span class="quotedstring">"pears"</span>)
  <span class="vem">val</span>&nbsp;nums&nbsp;=&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">4</span>)
  <span class="vem">val</span>&nbsp;diag3&nbsp;=
  &nbsp;&nbsp;<span class="typename">List</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">0</span>,&nbsp;<span class="literal">0</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">0</span>,&nbsp;<span class="literal">1</span>,&nbsp;<span class="literal">0</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">0</span>,&nbsp;<span class="literal">0</span>,&nbsp;<span class="literal">1</span>)
  &nbsp;&nbsp;)
  <span class="vem">val</span>&nbsp;empty&nbsp;=&nbsp;<span class="typename">List</span>()
</pre><!-- -->
Lists are quite similar to arrays, but there
are two important differences. First, lists are immutable. That
is, elements of a list cannot be changed by assignment. Second, 
lists have a recursive structure (<i>i.e.</i>, a <em>linked
list</em><a id="i594306766-1"></a>),<a href="working-with-lists.html#footnote16-1">[1]</a>
whereas arrays are flat.</p>

<h3><a name="16.2"></a>16.2 The <span class="code">List</span> type <span style="font-size: .5em">[<a href="working-with-lists.html#16.2">link</a>]</span></h3>


<p>Like arrays, lists are <span style="font-style:italic">homogeneous</span>: the elements of a
list all have the same type.  The type of a list that has elements of type
<span class="code">T</span> is written <span class="code">List[T]</span>. For instance, here are the same four lists
with explicit types added:
<pre>
  <span class="vem">val</span>&nbsp;fruit:&nbsp;<span class="typename">List[String]</span>&nbsp;=&nbsp;<span class="typename">List</span>(<span class="quotedstring">"apples"</span>,&nbsp;<span class="quotedstring">"oranges"</span>,&nbsp;<span class="quotedstring">"pears"</span>)
  <span class="vem">val</span>&nbsp;nums:&nbsp;<span class="typename">List[Int]</span>&nbsp;=&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">4</span>)
  <span class="vem">val</span>&nbsp;diag3:&nbsp;<span class="typename">List[List[Int]]</span>&nbsp;=
  &nbsp;&nbsp;<span class="typename">List</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">0</span>,&nbsp;<span class="literal">0</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">0</span>,&nbsp;<span class="literal">1</span>,&nbsp;<span class="literal">0</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">0</span>,&nbsp;<span class="literal">0</span>,&nbsp;<span class="literal">1</span>)
  &nbsp;&nbsp;)
  <span class="vem">val</span>&nbsp;empty:&nbsp;<span class="typename">List[Nothing]</span>&nbsp;=&nbsp;<span class="typename">List</span>()
</pre><!-- --></p>

<p>The list type in Scala is <span style="font-style:italic">covariant</span><a id="i-1469695991-1"></a>. This means 
that for each pair of types <span class="code">S</span> and <span class="code">T</span>, if <span class="code">S</span> is a subtype of <span class="code">T</span>, then
<span class="code">List[S]</span> is a subtype of <span class="code">List[T]</span>. For instance, <span class="code">List[String]</span> 
is a subtype of <span class="code">List[Object]</span>. This is natural because every list of 
strings can also be seen as a list of
objects.<a href="working-with-lists.html#footnote16-2">[2]</a></p>

<p>Note that the empty list has type
<span class="code">List[Nothing]</span>.<a id="i-727376847-1"></a> You saw in <a href="scalas-hierarchy.html#sec:bottom-types">Section 11.3</a>
that <span class="code">Nothing</span> is the bottom type in Scala's class hierarchy. It
is a subtype of every other Scala type.
Because lists are covariant, it follows that <span class="code">List[Nothing]</span> is a subtype of <span class="code">List[T]</span>, 
for any type <span class="code">T</span>. So the empty list object, which has type <span class="code">List[Nothing]</span>,
can also be seen as an object of every other list type of the form  <span class="code">List[T]</span>. 
That's why it is permissible to write code like:
<pre>
  <span class="comment">//&nbsp;List()&nbsp;is&nbsp;also&nbsp;of&nbsp;type&nbsp;List[String]!</span>
  <span class="vem">val</span>&nbsp;xs:&nbsp;<span class="typename">List[String]</span>&nbsp;=&nbsp;<span class="typename">List</span>()&nbsp;&nbsp;
</pre><!-- --></p>

<h3><a name="16.3"></a>16.3 Constructing lists <span style="font-size: .5em">[<a href="working-with-lists.html#16.3">link</a>]</span></h3>


<p>All lists are built from two fundamental building blocks, <span class="code">Nil</span><a id="i1899558990-2"></a>
and <span class="code">:: </span>(pronounced "cons").<a id="i1411857630-2"></a><a id="i1674095775-2"></a> <span class="code">Nil</span> represents the empty
list. The infix operator, <span class="code">::</span>, expresses list extension at the front. That is,
<span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> represents a list whose first element is <span class="code">x</span>, followed by (the elements of) list <span class="code">xs</span>.  Hence, the previous
list values could also have been defined as follows:
<pre>
  <span class="vem">val</span>&nbsp;fruit&nbsp;=&nbsp;<span class="quotedstring">"apples"</span>&nbsp;::&nbsp;(<span class="quotedstring">"oranges"</span>&nbsp;::&nbsp;(<span class="quotedstring">"pears"</span>&nbsp;::&nbsp;<span class="typename">Nil</span>))
  <span class="vem">val</span>&nbsp;nums&nbsp;&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;::&nbsp;(<span class="literal">2</span>&nbsp;::&nbsp;(<span class="literal">3</span>&nbsp;::&nbsp;(<span class="literal">4</span>&nbsp;::&nbsp;<span class="typename">Nil</span>)))
  <span class="vem">val</span>&nbsp;diag3&nbsp;=&nbsp;(<span class="literal">1</span>&nbsp;::&nbsp;(<span class="literal">0</span>&nbsp;::&nbsp;(<span class="literal">0</span>&nbsp;::&nbsp;<span class="typename">Nil</span>)))&nbsp;::
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">0</span>&nbsp;::&nbsp;(<span class="literal">1</span>&nbsp;::&nbsp;(<span class="literal">0</span>&nbsp;::&nbsp;<span class="typename">Nil</span>)))&nbsp;::
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">0</span>&nbsp;::&nbsp;(<span class="literal">0</span>&nbsp;::&nbsp;(<span class="literal">1</span>&nbsp;::&nbsp;<span class="typename">Nil</span>)))&nbsp;::&nbsp;<span class="typename">Nil</span>
  <span class="vem">val</span>&nbsp;empty&nbsp;=&nbsp;<span class="typename">Nil</span>
</pre><!-- -->
In fact the previous definitions of <span class="code">fruit</span>, <span class="code">nums</span>, <span class="code">diag3</span>, and <span class="code">empty</span> 
in terms of <span class="code">List(...)</span> are just wrappers that expand to these definitions.
For instance, <span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span> creates the list 
<span class="code">1</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">(2</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">(3</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">Nil))</span>.</p>

<p>Because it ends in a colon, the <span class="code">:: </span>operation associates to the right: <span class="code">A</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">B</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">C</span> is
interpreted as <span class="code">A</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">(B</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">C)</span>.<a id="i-1491182453-2"></a><a id="i620923488-2"></a>  Therefore, you can drop the
parentheses in the previous definitions. For instance:
<pre>
  <span class="vem">val</span>&nbsp;nums&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;::&nbsp;<span class="literal">2</span>&nbsp;::&nbsp;<span class="literal">3</span>&nbsp;::&nbsp;<span class="literal">4</span>&nbsp;::&nbsp;<span class="typename">Nil</span>
</pre><!-- -->
is equivalent to the previous definition of <span class="code">nums</span>.</p>

<h3><a name="16.4"></a>16.4 Basic operations on lists <span style="font-size: .5em">[<a href="working-with-lists.html#16.4">link</a>]</span></h3>


<p>All operations on lists can be expressed in terms of the following
three:<a id="i-735890706-2"></a><a id="i849842526-2"></a><a id="i1657074897-2"></a><a id="i-1093268841-2"></a><a id="i1464399372-2"></a><a id="i1464753276-2"></a></p>

<table style="border-collapse: collapse">
<tr class="">
  <td>
    <span class="code">head</span>
  </td>
  <td>
    returns the first element of a list
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">tail</span>
  </td>
  <td>
    returns a list consisting of all elements except the first
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">isEmpty</span>
  </td>
  <td>
    returns <span class="code">true</span> if the list is empty
  </td>
</tr>
</table>


<p>These operations are defined as methods of class <span class="code">List</span>.
Some examples are shown in <a href="working-with-lists.html#tab:lists:basics">Table 16.1</a>.</p>

<p><a name="tab:lists:basics"></a></p>

<h5>Table 16.1 - Basic list operations</h5>


<div align="center">
<table style="border-collapse: collapse">
<tr class="topline ">
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">What it is</span></span>
  </td>
  <td>
    <span style="font-size:medium"><span style="font-weight:bold">What it does</span></span>
  </td>
</tr>
<tr class="topline ">
  <td>
    <span class="code">empty.isEmpty</span>
  </td>
  <td>
    returns <span class="code">true</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">fruit.isEmpty</span>
  </td>
  <td>
    returns <span class="code">false</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">fruit.head</span>
  </td>
  <td>
    returns <span class="code">"apples"</span>
  </td>
</tr>
<tr class="">
  <td>
    <span class="code">fruit.tail.head</span>
  </td>
  <td>
    returns <span class="code">"oranges"</span>
  </td>
</tr>
<tr class="bottomline">
  <td>
    <span class="code">diag3.head</span>
  </td>
  <td>
    returns <span class="code">List(1,</span>&nbsp;<span class="code">0,</span>&nbsp;<span class="code">0)</span>
  </td>
</tr>
</table>


</div>


<p>The <span class="code">head</span> and <span class="code">tail</span> methods are defined only for non-empty
lists.  When selected from an empty list, they throw an exception. For instance:</p>

<pre>
  scala&gt;&nbsp;Nil.head
  <span class="output">java.util.NoSuchElementException:&nbsp;head&nbsp;of&nbsp;empty&nbsp;list</span>
</pre><!-- -->
As an example of how lists can be processed, consider sorting the
elements of a list of numbers into ascending order. One simple way to
do so is <span style="font-style:italic">insertion sort</span>,<a id="i132601811-1"></a><a id="i-1814033297-1"></a> which works as follows: To sort a
non-empty list <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span>, sort
the remainder <span class="code">xs</span> and insert the first element <span class="code">x</span> at the right
position in the result. Sorting an empty list yields the
empty list. Expressed as Scala code, the insertion sort algorithm looks like:
<pre>
  <span class="vem">def</span>&nbsp;isort(xs:&nbsp;<span class="typename">List[Int]</span>):&nbsp;<span class="typename">List[Int]</span>&nbsp;=
  &nbsp;&nbsp;<span class="vem">if</span>&nbsp;(xs.isEmpty)&nbsp;<span class="typename">Nil</span>
  &nbsp;&nbsp;<span class="vem">else</span>&nbsp;insert(xs.head,&nbsp;isort(xs.tail))
  <br />  <span class="vem">def</span>&nbsp;insert(x:&nbsp;<span class="typename">Int</span>,&nbsp;xs:&nbsp;<span class="typename">List[Int]</span>):&nbsp;<span class="typename">List[Int]</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;<span class="vem">if</span>&nbsp;(xs.isEmpty&nbsp;||&nbsp;x&nbsp;&lt;=&nbsp;xs.head)&nbsp;x&nbsp;::&nbsp;xs
  &nbsp;&nbsp;<span class="vem">else</span>&nbsp;xs.head&nbsp;::&nbsp;insert(x,&nbsp;xs.tail)
</pre><!-- -->


<h3><a name="16.5"></a>16.5 List patterns <span style="font-size: .5em">[<a href="working-with-lists.html#16.5">link</a>]</span></h3>


<p><a name="sec:list-patterns"></a></p>

<p>Lists can also be taken apart using pattern matching<a id="i1817770109-1"></a>. List patterns
correspond one-by-one to list expressions. You can either match on all
elements of a list using a pattern of the form <span class="code">List(...)</span>, or you 
take lists apart bit by bit using patterns composed from the
<span class="code">::</span> operator and the <span class="code">Nil</span> constant.</p>

<p>Here's an example of the first kind of pattern:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">List</span>(a,&nbsp;b,&nbsp;c)&nbsp;=&nbsp;fruit
  <span class="output">a:&nbsp;String&nbsp;=&nbsp;apples</span>
  <span class="output">b:&nbsp;String&nbsp;=&nbsp;oranges</span>
  <span class="output">c:&nbsp;String&nbsp;=&nbsp;pears</span>
</pre><!-- -->
The pattern List(a, b, c) matches lists of length 3, and binds the three elements
to the pattern variables <span class="code">a</span>, <span class="code">b</span>, and <span class="code">c</span>. 
If you don't know the number of list elements beforehand, it's better to match with 
<span class="code">::</span> instead. For instance, the pattern <span class="code">a</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">rest</span>
matches lists of length 2 or greater:</p>

<div class="aside">
<h3>About pattern matching on <span class="code">List</span>s</h3>


<p>If you review the possible forms of patterns explained in 
<a href="case-classes-and-pattern-matching.html">Chapter 15</a>, you might find that neither <span class="code">List(...)</span> nor
<span class="code">::</span> looks like it fits one of the kinds of patterns defined there.
In fact, <span class="code">List(...)</span> is an instance of a library-defined
<em>extractor</em> pattern<a id="i-1414877783-1"></a>.
Such patterns will be treated in <a href="extractors.html">Chapter 24</a>.
The "cons" pattern  <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> is a special case of an infix operation pattern.
You know already that, when seen as an expression, an infix operation is equivalent to a method call.
For patterns, the rules are different: When seen as a pattern, an infix operation
such as <span class="code">p</span>&nbsp;<span class="code">op</span>&nbsp;<span class="code">q</span> is equivalent to <span class="code">op(p,</span>&nbsp;<span class="code">q)</span>. That is, the infix operator
<span class="code">op</span> is treated as a constructor pattern. In particular, a cons pattern such as <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">xs</span> is
treated as <span class="code">::(x,</span>&nbsp;<span class="code">xs)</span>. This hints that there should be a class named <span class="code">::</span> that 
corresponds to the pattern constructor. Indeed there is such as class. It is named
<span class="code">scala.::</span> and is exactly the class that builds non-empty lists. So <span class="code">::</span> exists twice
in Scala, once as a name of a class in package <span class="code">scala</span>, and again
as a method in class <span class="code">List</span>. The effect of the method <span class="code">::</span> is to produce an 
instance of the class <span class="code">scala.::</span>. You'll find out more details about how the List class
is implemented in <a href="implementing-lists.html">Chapter 22</a>.</p>

</div>


<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;a&nbsp;::&nbsp;b&nbsp;::&nbsp;rest&nbsp;=&nbsp;fruit
  <span class="output">a:&nbsp;String&nbsp;=&nbsp;apples</span>
  <span class="output">b:&nbsp;String&nbsp;=&nbsp;oranges</span>
  <span class="output">rest:&nbsp;List[String]&nbsp;=&nbsp;List(pears)</span>
</pre><!-- -->
Taking<a id="i-986649610-1"></a><!-- --> lists apart with patterns is an alternative to taking them apart with
the basic methods <span class="code">head</span>, <span class="code">tail</span>, and <span class="code">isEmpty</span>. For instance, here's insertion sort<a id="i132601811-2"></a><a id="i-1814033297-2"></a> again, 
this time written with pattern matching: 
<pre>
  <span class="vem">def</span>&nbsp;isort(xs:&nbsp;<span class="typename">List[Int]</span>):&nbsp;<span class="typename">List[Int]</span>&nbsp;=&nbsp;xs&nbsp;<span class="vem">match</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;<span class="typename">List</span>()&nbsp;&nbsp;&nbsp;=&gt;&nbsp;<span class="typename">List</span>()
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;insert(x,&nbsp;isort(xs1))
  }
  <br />  <span class="vem">def</span>&nbsp;insert(x:&nbsp;<span class="typename">Int</span>,&nbsp;xs:&nbsp;<span class="typename">List[Int]</span>):&nbsp;<span class="typename">List[Int]</span>&nbsp;=&nbsp;xs&nbsp;<span class="vem">match</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;<span class="typename">List</span>()&nbsp;&nbsp;=&gt;&nbsp;<span class="typename">List</span>(x)
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;y&nbsp;::&nbsp;ys&nbsp;=&gt;&nbsp;<span class="vem">if</span>&nbsp;(x&nbsp;&lt;=&nbsp;y)&nbsp;x&nbsp;::&nbsp;xs&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">else</span>&nbsp;y&nbsp;::&nbsp;insert(x,&nbsp;ys)
  }
</pre><!-- -->


<p>Often, pattern matching over lists is clearer than decomposing them with methods,
so pattern matching should be a part of your list processing toolbox.</p>

<p>This is all you need to know about lists in Scala to be able to use
them correctly. However, there are also a large number of methods
that capture common patterns of operations over lists. 
These methods make list processing programs more concise
and often clearer. The next two sections present the most
important methods defined in the <span class="code">List</span> class.</p>

<h3><a name="16.6"></a>16.6 First-order methods on class <span class="code">List</span> <span style="font-size: .5em">[<a href="working-with-lists.html#16.6">link</a>]</span></h3>


<p>This section explains most first-order methods defined in the <span class="code">List</span><a id="i-570225502-1"></a><a id="i254621440-1"></a>
class. A method is <em>first-order</em> if it does not take any functions as
arguments<a id="i-461147607-1"></a>.  The section also introduces by means of two examples some
recommended techniques to structure programs that operate on lists.</p>

<h4>Concatenating lists</h4>


<p>An operation similar to <span class="code">::</span> is list concatenation, written<a id="i-1839436249-2"></a>
`<span class="code">:::</span>'. Unlike <span class="code">::</span>, <span class="code">:::</span> takes two lists as
operands<a id="i55390901-2"></a><a id="i-1436258358-1"></a>.
The result of <span class="code">xs</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">ys</span> is a new list that contains all the elements
of <span class="code">xs</span>, followed by all the elements of <span class="code">ys</span>. Here are some examples:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>)&nbsp;:::&nbsp;<span class="typename">List</span>(<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)
  <span class="output">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5)</span>
  <br />  scala&gt;&nbsp;<span class="typename">List</span>()&nbsp;:::&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">res1:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</span>
  <br />  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;:::&nbsp;<span class="typename">List</span>(<span class="literal">4</span>)
  <span class="output">res2:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)</span>
</pre><!-- -->
Like cons, list concatenation associates to the right. An expression like this:
<pre>
  xs&nbsp;:::&nbsp;ys&nbsp;:::&nbsp;zs
</pre><!-- -->
is interpreted like this:
<pre>
  xs&nbsp;:::&nbsp;(ys&nbsp;:::&nbsp;zs)
</pre><!-- --></p>

<h4>The Divide and Conquer principle</h4>


<p>Concatenation (<span class="code">:::</span>) is implemented as a method in class <span class="code">List</span>.  It<a id="i673902975-1"></a><a id="i1224006146-1"></a>
would also be possible to implement concatenation "by hand," using
pattern matching on lists. It's instructive to try to do that
yourself, because it shows a common way to implement algorithms using lists.  First, we'll settle on a signature for the concatenation
method, which we'll call <span class="code">append</span>.  In order not to mix things up too much, assume that
<span class="code">append</span> is defined outside the <span class="code">List</span> class. So it will take the two
lists to be concatenated as parameters. These two lists 
must agree on their element type,
but that element type can be arbitrary. This can be expressed by giving
<span class="code">append</span> a type parameter<a href="working-with-lists.html#footnote16-3">[3]</a><a id="i-940554758-1"></a> that represents the element type of the
two input lists:
<pre>
  <span class="vem">def</span>&nbsp;append[T](xs:&nbsp;<span class="typename">List[T]</span>,&nbsp;ys:&nbsp;<span class="typename">List[T]</span>):&nbsp;<span class="typename">List[T]</span>
</pre><!-- -->
To design the implementation of <span class="code">append</span>, it pays to remember the
"divide and conquer" design principle for programs over recursive
data structures such as lists. Many algorithms over lists first split
an input list into simpler cases using a pattern match. That's the
<span style="font-style:italic">divide</span> part of the principle.  They then construct a result for
each case. If the result is a non-empty list, some of its parts may be
constructed by recursive invocations of the same algorithm.  That's the
<span style="font-style:italic">conquer</span> part of the principle.</p>

<p>To apply this principle to the implementation of the <span class="code">append</span> method,<!-- -->
the first question to ask is on which list to
match. This is less trivial in the case of <span class="code">append</span> 
than for many other methods because there
are two choices. However, the subsequent "conquer" phase tells you
that you need to construct a list consisting of all elements of both
input lists. Since lists are constructed from the back towards the front, <span class="code">ys</span> can
remain intact whereas <span class="code">xs</span> will need to be taken apart and prepended to <span class="code">ys</span>. Thus, it makes sense to concentrate on
<span class="code">xs</span> as a source for a pattern match.  The most common pattern
match over lists simply distinguishes an empty from a non-empty
list. So this gives the following outline of an <span class="code">append</span> method:
<pre>
  <span class="vem">def</span>&nbsp;append[T](xs:&nbsp;<span class="typename">List[T]</span>,&nbsp;ys:&nbsp;<span class="typename">List[T]</span>):&nbsp;<span class="typename">List[T]</span>&nbsp;=
  &nbsp;&nbsp;xs&nbsp;<span class="vem">match</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">case</span>&nbsp;<span class="typename">List</span>()&nbsp;=&gt;&nbsp;<span class="comment">//&nbsp;??</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">case</span>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;<span class="comment">//&nbsp;??</span>
  &nbsp;&nbsp;}
</pre><!-- -->
All that remains is to fill in the two places marked with "<span class="code">??</span>".
The first such place is the alternative where the input list <span class="code">xs</span> is empty.
In this case concatenation yields the second list:
<pre>
  <span class="vem">case</span>&nbsp;<span class="typename">List</span>()&nbsp;=&gt;&nbsp;ys
</pre><!-- -->
The second place left open is the alternative where the input list <span class="code">xs</span>
consists of some head <span class="code">x</span> followed by a tail <span class="code">xs1</span>. In this
case the result is also a non-empty list. To construct a non-empty list
you need to know what the head and the tail of that list should be.
You know that the first element of the result list is <span class="code">x</span>.
As for the remaining elements, these can be computed by appending
the rest of the first list,
<span class="code">xs1</span>, to the second
list <span class="code">ys</span>. This completes the design and gives:
<pre>
  <span class="vem">def</span>&nbsp;append[T](xs:&nbsp;<span class="typename">List[T]</span>,&nbsp;ys:&nbsp;<span class="typename">List[T]</span>):&nbsp;<span class="typename">List[T]</span>&nbsp;=
  &nbsp;&nbsp;xs&nbsp;<span class="vem">match</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">case</span>&nbsp;<span class="typename">List</span>()&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">case</span>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;x&nbsp;::&nbsp;append(xs1,&nbsp;ys)
  &nbsp;&nbsp;}
</pre><!-- -->
The computation of the second alternative illustrated the "conquer" part of the 
divide and conquer principle: 
Think first what the shape of the desired output should be,
then compute the individual parts of that shape, using recursive invocations
of the algorithm where appropriate. Finally, construct the output
from these parts.</p>

<h4>Taking the length of a list: <span class="code">length</span></h4>


<p>The <span class="code">length</span> method computes the length of a list.<a id="i1353349876-2"></a><a id="i-1852559773-2"></a>
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>).length
  <span class="output">res3:&nbsp;Int&nbsp;=&nbsp;3</span>
</pre><!-- -->
On lists, unlike arrays, <span class="code">length</span> is a relatively expensive operation.
It needs to traverse the whole list to find its end 
and therefore takes time proportional to the number of elements in the list.
That's why it's not a good idea to replace a test such as 
<span class="code">xs.isEmpty</span> by <span class="code">xs.length</span>&nbsp;<span class="code">==</span>&nbsp;<span class="code">0</span>. The result of the two tests are equivalent, but
the second one is slower, in particular if the list <span class="code">xs</span> is long.</p>

<h4>Accessing the end of a list: <span class="code">init</span> and <span class="code">last</span></h4>


<p>You know already the basic operations <span class="code">head</span> and <span class="code">tail</span>, which
respectively take the first element of a list, and the rest of the
list except the first element. They each have a dual operation:<a id="i-1293540834-2"></a><a id="i1464438076-2"></a><a id="i1113811620-2"></a><a id="i1464515266-2"></a>
<span class="code">last</span> returns the last element of a (non-empty) list, whereas
<span class="code">init</span> returns a list consisting of all elements except the last one:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;abcde&nbsp;=&nbsp;<span class="typename">List</span>(<span class="quotedstring">'a'</span>,&nbsp;<span class="quotedstring">'b'</span>,&nbsp;<span class="quotedstring">'c'</span>,&nbsp;<span class="quotedstring">'d'</span>,&nbsp;<span class="quotedstring">'e'</span>)
  <span class="output">abcde:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
  <br />  scala&gt;&nbsp;abcde.last
  <span class="output">res4:&nbsp;Char&nbsp;=&nbsp;e</span>
  <br />  scala&gt;&nbsp;abcde.init
  <span class="output">res5:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d)</span>
</pre><!-- -->
Like <span class="code">head</span> and <span class="code">tail</span>, these methods throw an exception when 
applied to an empty list:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>().init
  <span class="output">java.lang.UnsupportedOperationException:&nbsp;Nil.init</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.List.init(List.scala:544)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;...</span>
  <br />  scala&gt;&nbsp;<span class="typename">List</span>().last
  <span class="output">java.util.NoSuchElementException:&nbsp;Nil.last</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.List.last(List.scala:563)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;...</span>
</pre><!-- -->
Unlike <span class="code">head</span> and <span class="code">tail</span>, which both run in constant time, <span class="code">init</span> and <span class="code">last</span> 
need to traverse the whole list to compute their result. They 
therefore take time proportional to the length of the list.</p>

<div class="callout">


<p><br />
It's a good idea to organize your data so that
most accesses are at the head of a list, rather than the last element.
<br /></p>

</div>


<h4>Reversing lists: <span class="code">reverse</span></h4>


<p>If at some point in the computation an algorithm demands frequent
accesses to the end of a list, it's sometimes better to reverse the
list first and work with the result instead. Here's how to do the reversal:<a id="i1817641200-2"></a><a id="i-2051462346-2"></a>
<pre>
  scala&gt;&nbsp;abcde.reverse&nbsp;
  <span class="output">res6:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</span>
</pre><!-- -->
Note that, like all other list operations, <span class="code">reverse</span> creates a new
list rather than changing the one it operates on.  Since lists are
immutable, such a change would not be possible, anyway.  To verify
this, check that the original value of <span class="code">abcde</span> is unchanged after the
<span class="code">reverse</span> operation:
<pre>
  scala&gt;&nbsp;abcde
  <span class="output">res7:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
</pre><!-- -->
The <span class="code">reverse</span>, <span class="code">init</span>, and <span class="code">last</span> operations satisfy some 
laws which can be used for reasoning about computations and for
simplifying programs.</p>

<ol>
<li><span class="code">reverse</span> is its own inverse:
<pre>
  xs.reverse.reverse&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;xs
</pre><!-- -->


</li>
<li><span class="code">reverse</span> turns <span class="code">init</span> to <span class="code">tail</span> and <span class="code">last</span> to <span class="code">head</span>,
  except that the elements are reversed:
<pre>
  xs.reverse.init&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;xs.tail.reverse
  xs.reverse.tail&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;xs.init.reverse
  xs.reverse.head&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;xs.last
  xs.reverse.last&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;xs.head
</pre><!-- -->
</li></ol>
Reverse could be implemented using concatenation (<span class="code">:::</span>), 
like in the following method, <span class="code">rev</span>:
<pre>
  <span class="vem">def</span>&nbsp;rev[T](xs:&nbsp;<span class="typename">List[T]</span>):&nbsp;<span class="typename">List[T]</span>&nbsp;=&nbsp;xs&nbsp;<span class="vem">match</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;<span class="typename">List</span>()&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;x&nbsp;::&nbsp;xs1&nbsp;=&gt;&nbsp;rev(xs1)&nbsp;:::&nbsp;<span class="typename">List</span>(x)
  }
</pre><!-- -->
However, this method is less efficient than one would hope for.  To
study the complexity of <span class="code">rev</span>, assume that the list <span class="code">xs</span> has length
<span class="code">n</span>.  Notice that there are <span class="code">n</span> recursive calls to <span class="code">rev</span>. Each
call except the last involves a list concatenation. List concatenation
<span class="code">xs</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">ys</span> takes time proportional to the length of its first
argument <span class="code">xs</span>. Hence, the total complexity of <span class="code">rev</span> is:


<div align="center">
<i>n</i> + (<i>n</i> - 1) + ... + 1 = (1 + <i>n</i>) * <i>n</i> / 2


</div>


<p>In other words, <span class="code">rev</span>'s complexity is quadratic in the length of its input
argument.  This is disappointing when compared to the standard
reversal of a mutable, linked list, which has linear
complexity. However, the current implementation of <span class="code">rev</span> is not the
best implementation possible. You will see in <a href="working-with-lists.html#sec:fastrev">Section 16.7</a> how to speed it up.</p>

<h4>Prefixes and suffixes: <span class="code">drop</span>, <span class="code">take</span> and <span class="code">splitAt</span></h4>


<p>The <span class="code">drop</span> and <span class="code">take</span> operations<a id="i-1134266499-1"></a><a id="i1464293147-2"></a><a id="i425822536-1"></a><a id="i-1852559773-3"></a><a id="i1464753331-1"></a><a id="i-567585630-1"></a><a id="i-858153663-1"></a> generalize <span class="code">tail</span> and <span class="code">init</span> in that they
return arbitrary prefixes or suffixes of a list.
The expression "<span class="code">xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n</span>" returns the 
first <span class="code">n</span> elements of the list <span class="code">xs</span>.
If <span class="code">n</span> is greater than <span class="code">xs.length</span>, the whole list <span class="code">xs</span> is returned.
The operation "<span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n</span>" returns all elements of the list <span class="code">xs</span> 
except the first <span class="code">n</span> ones. 
If <span class="code">n</span> is greater than <span class="code">xs.length</span>, the empty list is returned.</p>

<p>The <span class="code">splitAt</span> operation splits the list at a given index, returning
a pair of two lists.<a href="working-with-lists.html#footnote16-4">[4]</a>
It is defined by the equality:</p>

<div align="center">
<span class="code">xs</span>&nbsp;<span class="code">splitAt</span>&nbsp;<span class="code">n</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">take</span>&nbsp;<span class="code">n,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n)</span>


</div>


<p>However, <span class="code">splitAt</span> avoids traversing the list <span class="code">xs</span> twice.
Here are some examples of these three methods:
<pre>
  scala&gt;&nbsp;abcde&nbsp;take&nbsp;<span class="literal">2</span>
  <span class="output">res8:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b)</span>
  <br />  scala&gt;&nbsp;abcde&nbsp;drop&nbsp;<span class="literal">2</span>
  <span class="output">res9:&nbsp;List[Char]&nbsp;=&nbsp;List(c,&nbsp;d,&nbsp;e)</span>
  <br />  scala&gt;&nbsp;abcde&nbsp;splitAt&nbsp;<span class="literal">2</span>
  <span class="output">res10:&nbsp;(List[Char],&nbsp;List[Char])&nbsp;=&nbsp;(List(a,&nbsp;b),List(c,&nbsp;d,&nbsp;e))</span>
</pre><!-- --></p>

<h4>Element selection: <span class="code">apply</span> and <span class="code">indices</span></h4>


<p>Random element selection is supported through the <span class="code">apply</span> method;<a id="i-1534184650-1"></a><a id="i-1854381886-1"></a> however
it is a less common operation for lists than it
is for arrays.
<pre>
  scala&gt;&nbsp;abcde&nbsp;apply&nbsp;<span class="literal">2</span>&nbsp;<span class="comment">//&nbsp;rare&nbsp;in&nbsp;Scala</span>
  <span class="output">res11:&nbsp;Char&nbsp;=&nbsp;c</span>
</pre><!-- -->
As for all other types, <span class="code">apply</span> is implicitly inserted
when an object appears in the function position in a method call, 
so the line above can be shortened to:
<pre>
  scala&gt;&nbsp;abcde(<span class="literal">2</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;rare&nbsp;in&nbsp;Scala</span>
  <span class="output">res12:&nbsp;Char&nbsp;=&nbsp;c</span>
</pre><!-- -->
One reason why random element selection is less popular 
for lists than for arrays is that <span class="code">xs(n)</span> takes time proportional
to the index <span class="code">n</span>. In fact, <span class="code">apply</span> is simply 
defined by a combination of <span class="code">drop</span> and <span class="code">head</span>:</p>

<div align="center">
<span class="code">xs</span>&nbsp;<span class="code">apply</span>&nbsp;<span class="code">n</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">drop</span>&nbsp;<span class="code">n).head</span>


</div>


<p>This definition also makes clear that list indices range from
0 up to the length of the list minus one, the same as for arrays. The <span class="code">indices</span> method<a id="i552445480-1"></a><a id="i-1207917573-1"></a>
returns a list consisting of all valid indices of a given list:
<pre>
  scala&gt;&nbsp;abcde.indices
  <span class="output">res13:&nbsp;List[Int]&nbsp;=&nbsp;List(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4)</span>
</pre><!-- --></p>

<h4>Zipping lists: <span class="code">zip</span></h4>


<p>The <span class="code">zip</span> operation takes two lists and forms a list of pairs:<a id="i50424558-1"></a><a id="i1986918773-1"></a>
<pre>
  scala&gt;&nbsp;abcde.indices&nbsp;zip&nbsp;abcde
  <span class="output">res14:&nbsp;List[(Int,&nbsp;Char)]&nbsp;=&nbsp;List((0,a),&nbsp;(1,b),&nbsp;(2,c),&nbsp;(3,d),&nbsp;</span>
  <span class="output">(4,e))</span>
</pre><!-- -->
If the two lists are of different length, any unmatched elements are dropped:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;zipped&nbsp;=&nbsp;abcde&nbsp;zip&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">zipped:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,1),&nbsp;(b,2),&nbsp;(c,3))</span>
</pre><!-- -->
A useful special case is to zip a list with its index. This is 
done most efficiently with
the <span class="code">zipWithIndex</span> method, which pairs every element
of a list with the position where it appears in the
list<a id="i1217066692-1"></a>.
<pre>
  scala&gt;&nbsp;abcde.zipWithIndex
  <span class="output">res15:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,0),&nbsp;(b,1),&nbsp;(c,2),&nbsp;(d,3),&nbsp;</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;(e,4))</span>
</pre><!-- --></p>

<h4>Displaying lists: <span class="code">toString</span> and <span class="code">mkString</span></h4>


<p>The <span class="code">toString</span> operation returns the canonical string representation
of a list:<a id="i-683244392-1"></a>
<pre>
  scala&gt;&nbsp;abcde.toString
  <span class="output">res16:&nbsp;String&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
</pre><!-- -->
If you want a different representation you can use the <span class="code">mkString</span><a id="i1357784029-2"></a><a id="i746937723-2"></a>
method. The operation <span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">(pre,</span>&nbsp;<span class="code">sep,</span>&nbsp;<span class="code">post)</span> involves four<a id="i-205371607-1"></a>
operands:<!-- -->
the list <span class="code">xs</span> to be displayed, a prefix string <span class="code">pre</span> to be
displayed in front of all elements, a separator string <span class="code">sep</span> to be displayed
between successive elements, and a postfix string <span class="code">post</span> to be
displayed at the end. The result of the operation is the string:</p>

<div align="center">
<span class="code">pre</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">xs(0)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">sep</span>&nbsp;<span class="code">+</span> ...<span class="code">+</span>&nbsp;<span class="code">sep</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">xs(xs.length</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1)</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">post</span>


</div>


<p>The <span class="code">mkString</span> method has two overloaded variants that let you drop
some or all of its arguments. The first variant only takes a separator
string:</p>

<div align="center">
<span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">sep</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">("",</span>&nbsp;<span class="code">sep,</span>&nbsp;<span class="code">"")</span>


</div>


<p>The second variant lets you omit all arguments:</p>

<div align="center">
<span class="code">xs.mkString</span>&nbsp;<span class="code"></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">xs</span>&nbsp;<span class="code">mkString</span>&nbsp;<span class="code">""</span>


</div>


<p>Here are some examples:
<pre>
  scala&gt;&nbsp;abcde&nbsp;mkString&nbsp;(<span class="quotedstring">"["</span>,&nbsp;<span class="quotedstring">","</span>,&nbsp;<span class="quotedstring">"]"</span>)
  <span class="output">res17:&nbsp;String&nbsp;=&nbsp;[a,b,c,d,e]</span>
  <br />  scala&gt;&nbsp;abcde&nbsp;mkString&nbsp;<span class="quotedstring">""</span>
  <span class="output">res18:&nbsp;String&nbsp;=&nbsp;abcde</span>
  <br />  scala&gt;&nbsp;abcde.mkString
  <span class="output">res19:&nbsp;String&nbsp;=&nbsp;abcde</span>
  <br />  scala&gt;&nbsp;abcde&nbsp;mkString&nbsp;(<span class="quotedstring">"List("</span>,&nbsp;<span class="quotedstring">",&nbsp;"</span>,&nbsp;<span class="quotedstring">")"</span>)
  <span class="output">res20:&nbsp;String&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
</pre><!-- -->
There are also variants of the <span class="code">mkString</span> methods called
<span class="code">addString</span><a id="i-1095177571-1"></a><a id="i-454878362-1"></a> which append the
constructed string to a <span class="code">StringBuilder</span> object,<a href="working-with-lists.html#footnote16-5">[5]</a><!-- --><!-- --><!-- -->
 rather than returning
them as a result:<a id="i-2123413502-1"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;buf&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">StringBuilder</span>
  <span class="output">buf:&nbsp;StringBuilder&nbsp;=&nbsp;</span>
  <br />  scala&gt;&nbsp;abcde&nbsp;addString&nbsp;(buf,&nbsp;<span class="quotedstring">"("</span>,&nbsp;<span class="quotedstring">";"</span>,&nbsp;<span class="quotedstring">")"</span>)
  <span class="output">res21:&nbsp;StringBuilder&nbsp;=&nbsp;(a;b;c;d;e)</span>
</pre><!-- -->
The <span class="code">mkString</span> and <span class="code">addString</span> methods are inherited from <span class="code">List</span>'s
super trait <span class="code">Iterable</span>, so they are applicable to all sorts of iterable collections.</p>

<h4>Converting lists: <span class="code">elements</span>, <span class="code">toArray</span>,
  <span class="code">copyToArray</span></h4>


<p>To convert data between the flat world of arrays and the
recursive world of lists, you can use method <span class="code">toArray</span>
in class <span class="code">List</span> and <span class="code">toList</span> in class <span class="code">Array</span>:<a id="i-1473690452-1"></a><a id="i-1723195748-1"></a><a id="i-38723342-1"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;arr&nbsp;=&nbsp;abcde.toArray
  <span class="output">arr:&nbsp;Array[Char]&nbsp;=&nbsp;Array(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
  <br />  scala&gt;&nbsp;arr.toString
  <span class="output">res22:&nbsp;String&nbsp;=&nbsp;Array(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
  <br />  scala&gt;&nbsp;arr.toList
  <span class="output">res23:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
</pre><!-- -->
There's also a method <span class="code">copyToArray</span>,<a id="i1315859366-1"></a><a id="i-1677368899-1"></a> which copies list elements to
successive array positions within some destination array. The
operation:
<pre>
  xs&nbsp;copyToArray&nbsp;(arr,&nbsp;start)
</pre><!-- -->
copies all elements of the
list <span class="code">xs</span> to the array <span class="code">arr</span>, beginning with position <span class="code">start</span>.
You must ensure that the destination array <span class="code">arr</span> is large enough to
hold the list in full. Here's an example:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;arr2&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Array[Int]</span>(<span class="literal">10</span>)
  <span class="output">arr2:&nbsp;Array[Int]&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</span>
  <br />  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;copyToArray&nbsp;(arr2,&nbsp;<span class="literal">3</span>)
  <br />  scala&gt;&nbsp;arr2.toString
  <span class="output">res25:&nbsp;String&nbsp;=&nbsp;Array(0,&nbsp;0,&nbsp;0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;0,&nbsp;0,&nbsp;0,&nbsp;0)</span>
</pre><!-- -->
Finally, if you need to access list elements via an iterator, you can use the 
<span class="code">elements</span> method:<a id="i1760043736-1"></a><a id="i1085338403-1"></a> 
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;it&nbsp;=&nbsp;abcde.elements
  <span class="output">it:&nbsp;Iterator[Char]&nbsp;=&nbsp;non-empty&nbsp;iterator</span>
  <br />  scala&gt;&nbsp;it.next
  <span class="output">res26:&nbsp;Char&nbsp;=&nbsp;a</span>
  <br />  scala&gt;&nbsp;it.next
  <span class="output">res27:&nbsp;Char&nbsp;=&nbsp;b</span>
</pre><!-- --></p>

<h4>Example: Merge sort</h4>


<p>The insertion sort presented earlier is concise to write, but
it is not very efficient. Its average complexity is proportional to the<a id="i-2095646335-1"></a>
square of the length of the input list. A more efficient algorithm
is <span style="font-style:italic">merge sort</span>.<a id="i-1435795620-1"></a><a id="i-1149295482-1"></a></p>

<div class="pointofinterest">
<h3>The fast track</h3>


<p>This example provides another illustration of the divide and conquer principle and currying, as well as a useful discussion of algorithmic complexity. If you
prefer to move a bit faster on your first pass through this book, however, you can safely skip to <a href="working-with-lists.html#sec:higher-order-methods">Section 16.7</a>.</p>

</div>


<p>Merge sort works as follows: First, if the list has zero or one elements, it is already sorted, so
the list can be returned unchanged. Longer lists are split into two
sub-lists, each containing about half the elements of the original
list. Each sub-list is sorted by a recursive call to the sort
function, and the resulting two sorted lists are then combined in a
merge operation.</p>

<p>For a general implementation of merge sort, you want to leave open
the type of list elements to be sorted, and also want to leave open the function to be
used for the comparison of elements. You obtain a function of maximal
generality by passing these two items as parameters. This leads to the
implementation shown in <a href="working-with-lists.html#lst:merge-sort-function">Listing 16.1</a>.</p>

<p><a name="lst:merge-sort-function"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;msort[T](less:&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<span class="typename">Boolean</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xs:&nbsp;<span class="typename">List[T]</span>):&nbsp;<span class="typename">List[T]</span>&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;merge(xs:&nbsp;<span class="typename">List[T]</span>,&nbsp;ys:&nbsp;<span class="typename">List[T]</span>):&nbsp;<span class="typename">List[T]</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xs,&nbsp;ys)&nbsp;<span class="vem">match</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">case</span>&nbsp;(<span class="typename">Nil</span>,&nbsp;_)&nbsp;=&gt;&nbsp;ys
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">case</span>&nbsp;(_,&nbsp;<span class="typename">Nil</span>)&nbsp;=&gt;&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">case</span>&nbsp;(x&nbsp;::&nbsp;xs1,&nbsp;y&nbsp;::&nbsp;ys1)&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(less(x,&nbsp;y))&nbsp;x&nbsp;::&nbsp;merge(xs1,&nbsp;ys)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">else</span>&nbsp;y&nbsp;::&nbsp;merge(xs,&nbsp;ys1)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;n&nbsp;=&nbsp;xs.length&nbsp;/&nbsp;<span class="literal">2</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(n&nbsp;==&nbsp;<span class="literal">0</span>)&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">else</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;(ys,&nbsp;zs)&nbsp;=&nbsp;xs&nbsp;splitAt&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge(msort(less)(ys),&nbsp;msort(less)(zs))
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 16.1 - A merge sort function for <span class="code">List</span>s.</h5>


<p>The complexity of <span class="code">msort</span> is order (<i>n</i>\;<i>log</i>(<i>n</i>)), where <i>n</i> is the
length of the input list. To see why, note that splitting a list in
two and merging two sorted lists each take time proportional to the
length of the argument list(s). Each recursive call of <span class="code">msort</span>
halves the number of elements in its input, so there are about <i>log</i>(<i>n</i>)
consecutive recursive calls until the base case of lists of length 1
is reached.  However, for longer lists each call spawns off two
further calls. Adding everything up we obtain that at each of the
<i>log</i>(<i>n</i>) call levels, every element of the original lists takes
part in one split operation and in one merge operation. Hence, every
call level has a total cost proportional to <i>n</i>. Since there are
<i>log</i>(<i>n</i>) call levels, we obtain an overall cost proportional to
<i>n</i>\;<i>log</i>(<i>n</i>). That cost does not depend on the initial distribution
of elements in the list, so the worst case cost is the same as the
average case cost. This property makes merge sort an attractive algorithm for
sorting lists.</p>

<p>Here is an example of how <span class="code">msort</span> is used:
<pre>
  scala&gt;&nbsp;msort((x:&nbsp;<span class="typename">Int</span>,&nbsp;y:&nbsp;<span class="typename">Int</span>)&nbsp;=&gt;&nbsp;x&nbsp;&lt;&nbsp;y)(<span class="typename">List</span>(<span class="literal">5</span>,&nbsp;<span class="literal">7</span>,&nbsp;<span class="literal">1</span>,&nbsp;<span class="literal">3</span>))
  <span class="output">res28:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;3,&nbsp;5,&nbsp;7)</span>
</pre><!-- --></p>

<p>The <span class="code">msort</span> function is a classical example of the currying concept discussed
in <a href="control-abstraction.html#sec:currying">Section 9.3</a>.  
Currying<a id="i575993339-2"></a> makes it easy
to specialize the function for particular comparison functions. Here's an example:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;intSort&nbsp;=&nbsp;msort((x:&nbsp;<span class="typename">Int</span>,&nbsp;y:&nbsp;<span class="typename">Int</span>)&nbsp;=&gt;&nbsp;x&nbsp;&lt;&nbsp;y)&nbsp;_
  <span class="output">intSort:&nbsp;(List[Int])&nbsp;=&gt;&nbsp;List[Int]&nbsp;=&nbsp;&lt;function&gt;</span>
</pre><!-- -->
The <span class="code">intSort</span> variable refers to a function that takes a list of integers and sorts them in numerical order.<a id="i1128745740-2"></a><a id="i1834060518-2"></a><a id="i1842232449-2"></a>
As described in <a href="functions-and-closures.html#sec:partially-applied-functions">Section 8.6</a>,
an underscore stands for a missing argument list.  In this
case, the missing argument is the list that should be sorted. As another example, here's
how you could define a function that sorts a list of integers in reverse numerical order:


<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;reverseIntSort&nbsp;=&nbsp;msort((x:&nbsp;<span class="typename">Int</span>,&nbsp;y:&nbsp;<span class="typename">Int</span>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;y)&nbsp;_
  <span class="output">reverseIntSort:&nbsp;(List[Int])&nbsp;=&gt;&nbsp;List[Int]&nbsp;=&nbsp;&lt;function&gt;</span>
</pre><!-- -->


<p>Because you provided the comparison function already via currying, you now need only provide the 
list to sort when you invoke the <span class="code">intSort</span> or <span class="code">reverseIntSort</span> functions. Here are some
examples:</p>

<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;mixedInts&nbsp;=&nbsp;<span class="typename">List</span>(<span class="literal">4</span>,&nbsp;<span class="literal">1</span>,&nbsp;<span class="literal">9</span>,&nbsp;<span class="literal">0</span>,&nbsp;<span class="literal">5</span>,&nbsp;<span class="literal">8</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">6</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">7</span>)
  <span class="output">mixedInts:&nbsp;List[Int]&nbsp;=&nbsp;List(4,&nbsp;1,&nbsp;9,&nbsp;0,&nbsp;5,&nbsp;8,&nbsp;3,&nbsp;6,&nbsp;2,&nbsp;7)</span>
  <br />  scala&gt;&nbsp;intSort(mixedInts)
  <span class="output">res0:&nbsp;List[Int]&nbsp;=&nbsp;List(0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9)</span>
  <br />  scala&gt;&nbsp;reverseIntSort(mixedInts)
  <span class="output">res1:&nbsp;List[Int]&nbsp;=&nbsp;List(9,&nbsp;8,&nbsp;7,&nbsp;6,&nbsp;5,&nbsp;4,&nbsp;3,&nbsp;2,&nbsp;1,&nbsp;0)</span>
</pre><!-- -->


<h3><a name="16.7"></a>16.7 Higher-order methods on class <span class="code">List</span> <span style="font-size: .5em">[<a href="working-with-lists.html#16.7">link</a>]</span></h3>


<p><a name="sec:higher-order-methods"></a></p>

<p>Many operations over lists have a similar structure. Several patterns
appear time and time again.<a id="i-1450817245-1"></a><a id="i1952802169-1"></a> Some examples are:
transforming every element of a list in some way,
verifying whether a property holds for all elements of a list,
extracting from a list elements satisfying a certain criterion, or
combining the elements of a list using some operator.  In Java, such patterns would usually be expressed by idiomatic
combinations of <span class="code">for</span> or <span class="code">while</span> loops. In Scala, they can be
expressed more concisely and directly using higher-order operators,<a href="working-with-lists.html#footnote16-6">[6]</a>
which are implemented as methods in class <span class="code">List</span>.  These higher-order operators are
discussed in this section.<!-- --><!-- --></p>

<h4>Mapping over lists: <span class="code">map</span>, <span class="code">flatMap</span> and <span class="code">foreach</span></h4>


<p>The operation <span class="code">xs</span>&nbsp;<span class="code">map</span>&nbsp;<span class="code">f</span><a id="i395196522-2"></a><a id="i1986906032-2"></a>
takes as operands a list <span class="code">xs</span> of type <span class="code">List[T]</span> 
and a function <span class="code">f</span> of type <span class="code">T</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">U</span>. It returns the list resulting
from applying the function <span class="code">f</span> to each list element in <span class="code">xs</span>. For instance:</p>

<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)&nbsp;map&nbsp;(_&nbsp;+&nbsp;<span class="literal">1</span>)
  <span class="output">res29:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;3,&nbsp;4)</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;words&nbsp;=&nbsp;<span class="typename">List</span>(<span class="quotedstring">"the"</span>,&nbsp;<span class="quotedstring">"quick"</span>,&nbsp;<span class="quotedstring">"brown"</span>,&nbsp;<span class="quotedstring">"fox"</span>)
  <span class="output">words:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(the,&nbsp;quick,&nbsp;brown,&nbsp;fox)</span>
  <br />  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.length)
  <span class="output">res30:&nbsp;List[Int]&nbsp;=&nbsp;List(3,&nbsp;5,&nbsp;5,&nbsp;3)</span>
  <br />  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.toList.reverse.mkString)
  <span class="output">res31:&nbsp;List[String]&nbsp;=&nbsp;List(eht,&nbsp;kciuq,&nbsp;nworb,&nbsp;xof)</span>
</pre><!-- -->
The <span class="code">flatMap</span><a id="i535160876-1"></a><a id="i364816247-1"></a> operator is similar to <span class="code">map</span>, but it takes a function
returning a list of elements as its right operand. It applies the
function to each list element and returns the concatenation of all function
results. The difference between <span class="code">map</span> and <span class="code">flatMap</span> is illustrated
in the following example:


<pre>
  scala&gt;&nbsp;words&nbsp;map&nbsp;(_.toList)
  <span class="output">res32:&nbsp;List[List[Char]]&nbsp;=&nbsp;List(List(t,&nbsp;h,&nbsp;e),&nbsp;List(q,&nbsp;u,&nbsp;i,&nbsp;</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;k),&nbsp;List(b,&nbsp;r,&nbsp;o,&nbsp;w,&nbsp;n),&nbsp;List(f,&nbsp;o,&nbsp;x))</span>
  <br />  scala&gt;&nbsp;words&nbsp;flatMap&nbsp;(_.toList)
  <span class="output">res33:&nbsp;List[Char]&nbsp;=&nbsp;List(t,&nbsp;h,&nbsp;e,&nbsp;q,&nbsp;u,&nbsp;i,&nbsp;c,&nbsp;k,&nbsp;b,&nbsp;r,&nbsp;o,&nbsp;w,&nbsp;</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;n,&nbsp;f,&nbsp;o,&nbsp;x)</span>
</pre><!-- -->
You see that where <span class="code">map</span> returns a list of lists, <span class="code">flatMap</span> returns
a single list in which all element lists are concatenated.


<p>The differences and interplay between <span class="code">map</span> and <span class="code">flatMap</span> are also demonstrated by the
following expression, which constructs a list of all pairs (<i>i</i>, <i>j</i>)
such that 1 &le; <i>j</i> &lt; <i>i</i> &lt; 5:
<pre>
  scala&gt;&nbsp;List.range(<span class="literal">1</span>,&nbsp;<span class="literal">5</span>)&nbsp;flatMap&nbsp;(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&gt;&nbsp;List.range(<span class="literal">1</span>,&nbsp;i)&nbsp;map&nbsp;(j&nbsp;=&gt;&nbsp;(i,&nbsp;j))
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  <span class="output">res34:&nbsp;List[(Int,&nbsp;Int)]&nbsp;=&nbsp;List((2,1),&nbsp;(3,1),&nbsp;(3,2),&nbsp;(4,1),&nbsp;</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;(4,2),&nbsp;(4,3))</span>
</pre><!-- -->
<span class="code">List.range</span> is a utility method that creates a list
of all integers in some range.<a id="i2103556958-1"></a><a id="i1320308892-1"></a>  It is used twice in this
example: once to generate a list of integers from 1 (including) until 5 (excluding),
and in a second time to generate a list of integers from 1
until <i>i</i>, for each value of <i>i</i> taken from the first list.  
The <span class="code">map</span> in this expression
generates a list of tuples (<i>i</i>, <i>j</i>) where <i>j</i> &lt; <i>i</i>.
The outer
<span class="code">flatMap</span> in this example generates this list for each <span class="code">i</span> between
1 and 5, and then concatenates all the results.</p>

<p>Note that the same list can alternatively be constructed with a <span class="code">for</span> expression:
<pre>
  <span class="vem">for</span>&nbsp;(i&nbsp;&lt;-&nbsp;List.range(<span class="literal">1</span>,&nbsp;<span class="literal">5</span>);&nbsp;j&nbsp;&lt;-&nbsp;List.range(<span class="literal">1</span>,&nbsp;i))&nbsp;<span class="vem">yield</span>&nbsp;(i,&nbsp;j)
</pre><!-- -->
You'll learn more about the interplay of <span class="code">for</span> expressions and list operations in 
<a href="for-expressions-revisited.html">Chapter 23</a>.</p>

<p>The third map-like operation is <span class="code">foreach</span>.<a id="i331113560-2"></a><a id="i465975966-2"></a> Unlike <span class="code">map</span>
and <span class="code">flatMap</span>, however, <span class="code">foreach</span> takes a procedure (a function with result type
<span class="code">Unit</span>) as right operand. It simply applies the procedure to each
list element. The result of the operation itself is again <span class="code">Unit</span>; no
list of results is assembled. As an example, here is a concise way of
summing up all numbers in a list:
<pre>
  scala&gt;&nbsp;<span class="vem">var</span>&nbsp;sum&nbsp;=&nbsp;<span class="literal">0</span>
  <span class="output">sum:&nbsp;Int&nbsp;=&nbsp;0</span>
  <br />  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)&nbsp;foreach&nbsp;(sum&nbsp;+=&nbsp;_)
  <br />  scala&gt;&nbsp;sum
  <span class="output">res36:&nbsp;Int&nbsp;=&nbsp;15</span>
</pre><!-- --></p>

<h4>Filtering lists: <span class="code">filter</span>, <span class="code">partition</span>, <span class="code">find</span>,
  <span class="code">takeWhile</span>, <span class="code">dropWhile</span>, and <span class="code">span</span></h4>


<p>The operation "<span class="code">xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p</span>" takes as operands a list <span class="code">xs</span> of type <span class="code">List[T]</span><a id="i1807572102-2"></a><a id="i-1514694492-2"></a>
and a predicate function <span class="code">p</span> of type <span class="code">T</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span>. It yields the list of all
elements <span class="code">x</span> in <span class="code">xs</span> for which <span class="code">p(x)</span> is <span class="code">true</span>. For instance:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)&nbsp;filter&nbsp;(_&nbsp;%&nbsp;<span class="literal">2</span>&nbsp;==&nbsp;<span class="literal">0</span>)
  <span class="output">res37:&nbsp;List[Int]&nbsp;=&nbsp;List(2,&nbsp;4)</span>
  <br />  scala&gt;&nbsp;words&nbsp;filter&nbsp;(_.length&nbsp;==&nbsp;<span class="literal">3</span>)
  <span class="output">res38:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(the,&nbsp;fox)</span>
</pre><!-- -->
The <span class="code">partition</span><a id="i-944990523-1"></a><a id="i2039424574-1"></a> method is like filter, but it returns a pair of lists.
One list contains all elements for which the predicate is true, while the other
list contains all elements for which the predicate is false.
It is defined by the equality:</p>

<div align="center">
<span class="code">xs</span>&nbsp;<span class="code">partition</span>&nbsp;<span class="code">p</span>&nbsp;<span class="code"></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">p,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">filter</span>&nbsp;<span class="code">(!p(_)))</span>


</div>


<p>Here's an example:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)&nbsp;partition&nbsp;(_&nbsp;%&nbsp;<span class="literal">2</span>&nbsp;==&nbsp;<span class="literal">0</span>)
  <span class="output">res39:&nbsp;(List[Int],&nbsp;List[Int])&nbsp;=&nbsp;(List(2,&nbsp;4),List(1,&nbsp;3,&nbsp;5))</span>
</pre><!-- -->
The <span class="code">find</span><a id="i383310678-1"></a><a id="i1464344037-1"></a> method is also similar to <span class="code">filter</span> but it returns the
first element satisfying a given predicate, rather than all such elements.
The operation <span class="code">xs</span>&nbsp;<span class="code">find</span>&nbsp;<span class="code">p</span> takes a list <span class="code">xs</span> and a predicate <span class="code">p</span> as
operands. It returns an optional value. If there is an element <span class="code">x</span>
in <span class="code">xs</span> for which <span class="code">p(x)</span> is true, <span class="code">Some(x)</span> is returned. Otherwise,
<span class="code">p</span> is false for all elements, and <span class="code">None</span> is returned.
Here are some examples:
<pre>
  scala&gt;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)&nbsp;find&nbsp;(_&nbsp;%&nbsp;<span class="literal">2</span>&nbsp;==&nbsp;<span class="literal">0</span>)
  <span class="output">res40:&nbsp;Option[Int]&nbsp;=&nbsp;Some(2)</span>
  <br />  scala&gt;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)&nbsp;find&nbsp;(_&nbsp;&lt;=&nbsp;<span class="literal">0</span>)
  <span class="output">res41:&nbsp;Option[Int]&nbsp;=&nbsp;None</span>
</pre><!-- -->
The <span class="code">takeWhile</span><a id="i-334215483-1"></a><a id="i1035564606-1"></a> and <span class="code">dropWhile</span><a id="i-648573139-1"></a><a id="i-976962346-1"></a> operators also take a predicate as
their right operand. The operation <span class="code">xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p</span> takes the longest prefix of list
<span class="code">xs</span> such that every element in the prefix satisfies <span class="code">p</span>.
Analogously, the operation <span class="code">xs</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p</span> removes the longest prefix from list
<span class="code">xs</span> such that every element in the prefix satisfies <span class="code">p</span>. Here are some examples:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;-<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)&nbsp;takeWhile&nbsp;(_&nbsp;&gt;&nbsp;<span class="literal">0</span>)
  <span class="output">res42:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</span>
  <br />  scala&gt;&nbsp;words&nbsp;dropWhile&nbsp;(_&nbsp;startsWith&nbsp;<span class="quotedstring">"t"</span>)
  <span class="output">res43:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(quick,&nbsp;brown,&nbsp;fox)</span>
</pre><!-- -->
The <span class="code">span</span><a id="i772550245-1"></a><a id="i1464737654-1"></a> method combines <span class="code">takeWhile</span> and <span class="code">dropWhile</span> in one
operation, just like <span class="code">splitAt</span> combines <span class="code">take</span> and <span class="code">drop</span>.
It returns a pair of two lists, defined by the equality:</p>

<div align="center">
<span class="code">xs</span>&nbsp;<span class="code">span</span>&nbsp;<span class="code">p</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">(xs</span>&nbsp;<span class="code">takeWhile</span>&nbsp;<span class="code">p,</span>&nbsp;<span class="code">xs</span>&nbsp;<span class="code">dropWhile</span>&nbsp;<span class="code">p)</span>


</div>


<p>Like <span class="code">splitAt</span>, <span class="code">span</span> avoids traversing the list <span class="code">xs</span>
twice: 
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>,&nbsp;-<span class="literal">4</span>,&nbsp;<span class="literal">5</span>)&nbsp;span&nbsp;(_&nbsp;&gt;&nbsp;<span class="literal">0</span>)
  <span class="output">res44:&nbsp;(List[Int],&nbsp;List[Int])&nbsp;=&nbsp;(List(1,&nbsp;2,&nbsp;3),List(-4,&nbsp;5))</span>
</pre><!-- --></p>

<h4>Predicates over lists: <span class="code">forall</span> and <span class="code">exists</span></h4>


<p>The operation <span class="code">xs</span>&nbsp;<span class="code">forall</span>&nbsp;<span class="code">p</span><a id="i260029766-2"></a><a id="i-1508992668-2"></a> takes as arguments a list <span class="code">xs</span> and a
predicate <span class="code">p</span>. Its result is <span class="code">true</span> if all elements in the list
satisfy <span class="code">p</span>. Conversely, the operation <span class="code">xs</span>&nbsp;<span class="code">exists</span>&nbsp;<span class="code">p</span><a id="i339085162-2"></a><a id="i-1529560696-2"></a> returns <span class="code">true</span>
if there is an element in <span class="code">xs</span> that satisfies the predicate <span class="code">p</span>. For
instance, to find out whether a matrix represented as a list of lists
has a row with only zeroes as elements:
<pre>
  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;hasZeroRow(m:&nbsp;<span class="typename">List[List[Int]]</span>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;exists&nbsp;(row&nbsp;=&gt;&nbsp;row&nbsp;forall&nbsp;(_&nbsp;==&nbsp;<span class="literal">0</span>))
  <span class="output">hasZeroRow:&nbsp;(List[List[Int]])Boolean</span>
  <br />  scala&gt;&nbsp;hasZeroRow(diag3)
  <span class="output">res45:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- --></p>

<h4>Folding lists: <span class="code">/:</span> and <span class="code">:\</span></h4>


<p>Another common kind of operation combines the elements of a list with
some operator.  For instance:</p>

<div align="center">
<span class="code">sum(List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c))</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">0</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">a</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">c</span>


</div>


<p>This is a special instance of a fold operation:
<pre>
  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;sum(xs:&nbsp;<span class="typename">List[Int]</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;(<span class="literal">0</span>&nbsp;/:&nbsp;xs)&nbsp;(_&nbsp;+&nbsp;_)&nbsp;
  <span class="output">sum:&nbsp;(List[Int])Int</span>
</pre><!-- -->
Similarly:</p>

<div align="center">
<span class="code">product(List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c))</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">1</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">a</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">b</span>&nbsp;<span class="code">*</span>&nbsp;<span class="code">c</span>


</div>


<p>is a special instance of this fold operation:
<pre>
  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;product(xs:&nbsp;<span class="typename">List[Int]</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;(<span class="literal">1</span>&nbsp;/:&nbsp;xs)&nbsp;(_&nbsp;*&nbsp;_)&nbsp;
  <span class="output">product:&nbsp;(List[Int])Int</span>
</pre><!-- -->
A <span style="font-style:italic">fold left</span> operation "<span class="code">(z</span>&nbsp;<span class="code">/:</span>&nbsp;<span class="code">xs)</span>&nbsp;<span class="code">(op)</span>" involves<a id="i-1160692124-1"></a><a id="i-1069108030-1"></a> three objects:
a start value <span class="code">z</span>, a list <span class="code">xs</span>, and a binary operation <span class="code">op</span>.
The result of the fold<a id="i487604192-1"></a> is <span class="code">op</span> applied between successive
elements of the list prefixed by <span class="code">z</span>. For instance:</p>

<div align="center">
<span class="code">(z</span>&nbsp;<span class="code">/:</span>&nbsp;<span class="code">List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c))</span>&nbsp;<span class="code">(op)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">op(op(op(z,</span>&nbsp;<span class="code">a),</span>&nbsp;<span class="code">b),</span>&nbsp;<span class="code">c)</span>


</div>


<p>Or, graphically:</p>

<div align="center">
<img src="images/optree1.jpg" alt="image images/optree1.jpg"/>


</div>


<p>Here's another example that illustrates how <span class="code">/:</span> is used. To concatenate all 
words in a list of strings with spaces between them and in front, you
can write this:
<pre>
  scala&gt;&nbsp;&nbsp;(<span class="quotedstring">""</span>&nbsp;/:&nbsp;words)&nbsp;(_&nbsp;+<span class="quotedstring">"&nbsp;"</span>+&nbsp;_)
  <span class="output">res46:&nbsp;java.lang.String&nbsp;=&nbsp;&nbsp;the&nbsp;quick&nbsp;brown&nbsp;fox</span>
</pre><!-- -->
This gives an extra space at the beginning. To remove the space, you
can use this slight variation:
<pre>
  scala&gt;&nbsp;(words.head&nbsp;/:&nbsp;words.tail)&nbsp;&nbsp;(_&nbsp;+<span class="quotedstring">"&nbsp;"</span>+&nbsp;_)
  <span class="output">res47:&nbsp;java.lang.String&nbsp;=&nbsp;the&nbsp;quick&nbsp;brown&nbsp;fox</span>
</pre><!-- -->
The <span class="code">/:</span> operator produces left-leaning operation trees (its syntax
with the slash rising forward is intended to be a reflection of that).
The operator has <span class="code">:\</span> as an analog that produces right-leaning
trees. For instance:</p>

<div align="center">
<span class="code">(List(a,</span>&nbsp;<span class="code">b,</span>&nbsp;<span class="code">c)</span>&nbsp;<span class="code">:\</span>&nbsp;<span class="code">z)</span>&nbsp;<span class="code">(op)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">op(a,</span>&nbsp;<span class="code">op(b,</span>&nbsp;<span class="code">op(c,</span>&nbsp;<span class="code">z)))</span>


</div>


<p>Or, graphically:</p>

<div align="center">
<img src="images/optree2.jpg" alt="image images/optree2.jpg"/>


</div>


<p>The <span class="code">:\</span> operator is pronounced <span style="font-style:italic">fold right</span>.<a id="i-1517880440-1"></a><a id="i-2058478237-1"></a><a id="i1039328969-1"></a>
It involves the same three operands as fold left, but the first two 
appear in reversed order: The first operand is the list to
fold, the second is the start value.</p>

<p>For associative operations, fold left and fold right are
equivalent, but there might be a difference in efficiency.<a id="i-1099454431-1"></a>
Consider for instance an operation corresponding 
to the <span class="code">List.flatten</span> method, which
concatenates all
elements in a list of lists.<a id="i434218046-1"></a><a id="i44703139-1"></a><a href="working-with-lists.html#footnote16-7">[7]</a> This could be implemented with either
fold left or fold right:
<pre>
  <span class="vem">def</span>&nbsp;flattenLeft[T](xss:&nbsp;<span class="typename">List[List[T]]</span>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(<span class="typename">List[T]</span>()&nbsp;/:&nbsp;xss)&nbsp;(_&nbsp;:::&nbsp;_)
  <br />  <span class="vem">def</span>&nbsp;flattenRight[T](xss:&nbsp;<span class="typename">List[List[T]]</span>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;(xss&nbsp;:~<span class="typename">List[T]</span>())&nbsp;(_&nbsp;:::&nbsp;_)
</pre><!-- -->
Because list concatenation, <span class="code">xs</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">ys</span>, takes time proportional to its
first argument <span class="code">xs</span>, the implementation in terms of fold right in  
<span class="code">flattenRight</span> is more efficient than the fold left implementation in
<span class="code">flattenLeft</span>. The problem is that <span class="code">flattenLeft(xss)</span> copies the first
element list <span class="code">xss.head</span> <i>n</i>-1 times, where <i>n</i> is the length of the
list <span class="code">xss</span>.</p>

<p>Note that both versions of <span class="code">flatten</span> require a type annotation 
on the empty list that is the start value of the fold. 
This is due to a limitation in Scala's type
inferencer, which fails to infer the correct type of the list
automatically.  If you try to leave out the annotation, you get the
following:
<pre>
  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;flattenRight[T](xss:&nbsp;<span class="typename">List[List[T]]</span>)&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xss&nbsp;:~<span class="typename">List</span>())&nbsp;(_&nbsp;:::&nbsp;_)
  <span class="output">&lt;console&gt;:15:&nbsp;error:&nbsp;type&nbsp;mismatch;</span>
  <span class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;List[T]</span>
  <span class="output">&nbsp;required:&nbsp;List[Nothing]</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xss&nbsp;:~List())&nbsp;(_&nbsp;:::&nbsp;_)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<p>To find out why the type inferencer goes wrong, you'll need to know
about the types of the fold methods and how they are implemented. More
on this in <a href="implementing-lists.html">Chapter 22</a>.
Lastly, although the <span class="code">/:</span> and <span class="code">:\</span> operators have the advantage that the direction
of the slash resembles the graphical depiction of their respective left or right-leaning trees, and the associativity of
the colon character places the start value in the same position in the
expression as it is in the tree, some may find the resulting code less than intuitive. If you prefer, you can alternatively
use the methods named <span class="code">foldLeft</span><a id="i-1740081977-1"></a><a id="i1387030996-1"></a>
and <span class="code">foldRight</span><a id="i411005876-1"></a>, which are also defined on class <span class="code">List</span>.<a id="i53948911-1"></a></p>

<h4>Example: List reversal using fold</h4>


<p><a name="sec:fastrev"></a></p>

<p>Earlier in the chapter you saw an implementation of method
<span class="code">reverse</span>, named <span class="code">rev</span>, whose running time was quadratic in the length of the list
to be reversed. Here is now a different implementation of <span class="code">reverse</span>
that has linear cost.  The idea is to use a fold left
operation based on the following scheme:
<pre>
  <span class="vem">def</span>&nbsp;reverseLeft[T](xs:&nbsp;<span class="typename">List[T]</span>)&nbsp;=&nbsp;(<i>startvalue</i>&nbsp;/:&nbsp;xs)(<i>operation</i>)
</pre><!-- -->
It only remains to fill in the <i>startvalue</i> and <i>operation</i> parts.  In fact, you can 
try to deduce these parts from some simple examples. To deduce the correct
value of <i>startvalue</i>, you can start with the smallest possible list, <span class="code">List()</span>, and
calculate as follows:
<pre>
  <span class="typename">List</span>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;<span class="rm">(by the properties of <span class="code">reverseLeft</span>)</span>
  <br />  reverseLeft(<span class="typename">List</span>())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;<span class="rm">(by the template for <span class="code">reverseLeft</span>)</span>
  <br />  (<i>startvalue</i>&nbsp;/:&nbsp;<span class="typename">List</span>())(<i>operation</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;<span class="rm">(by the definition of <span class="code">/:</span>)</span>
  <br />  <i>startvalue</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</pre><!-- -->
Hence, <i>startvalue</i> must be <span class="code">List()</span>. To deduce the second operand, you can
pick the next smallest list as an example case. You know already that 
<i>startvalue</i> is <span class="code">List()</span>, so you can calculate as follows:
<pre>
  <span class="typename">List</span>(x)
  &nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;<span class="rm">(by the properties of <span class="code">reverseLeft</span>)</span>
  <br />  reverseLeft(<span class="typename">List</span>(x))
  &nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;<span class="rm">(by the template for <span class="code">reverseLeft</span>, with</span> <span class="rm"><em>startvalue</em></span><!-- --> <span class="rm"><span class="code">= List()</span>)</span>
  <br />  (<span class="typename">List</span>()&nbsp;/:&nbsp;<span class="typename">List</span>(x))&nbsp;(<i>operation</i>)&nbsp;
  &nbsp;&nbsp;<span class="rm"><em>equals</em></span>&nbsp;<span class="rm">(by the definition of <span class="code">/:</span>)</span>
  <br />  <i>operation</i>(<span class="typename">List</span>(),&nbsp;x)
</pre><!-- -->
Hence, <i>operation</i><span class="code">(List(),</span>&nbsp;<span class="code">x)</span> equals <span class="code">List(x)</span>, which can also be written
as <span class="code">x</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">List()</span>. This suggests taking as <i>operation</i> the
<span class="code">::</span> operator with its operands exchanged. (This operation is
sometimes called "snoc," in reference<a id="i3535215-1"></a> to <span class="code">::</span>, which is
called cons.) We arrive then at
the following implementation for <span class="code">reverseLeft</span>:
<pre>
  <span class="vem">def</span>&nbsp;reverseLeft[T](xs:&nbsp;<span class="typename">List[T]</span>)&nbsp;=
  &nbsp;&nbsp;(<span class="typename">List[T]</span>()&nbsp;/:&nbsp;xs)&nbsp;{(ys,&nbsp;y)&nbsp;=&gt;&nbsp;y&nbsp;::&nbsp;ys}
</pre><!-- -->
(Again, the type annotation in <span class="code">List[T]()</span> is necessary to make the
type inferencer work.) If you analyze the complexity of <span class="code">reverseLeft</span>,
you'll find that it applies a constant-time operation ("snoc") <i>n</i>
times, where <i>n</i> is the length of the argument list. Hence, the
complexity of <span class="code">reverseLeft</span> is linear, as hoped for.</p>

<h4>Sorting lists: <span class="code">sort</span></h4>


<p>The operation <span class="code">xs</span>&nbsp;<span class="code">sort</span>&nbsp;<span class="code">before</span>, where "xs" is a list and
"<span class="code">before</span>" is a function that can be used to compare two elements,
sorts the elements of list <span class="code">xs</span>.<a id="i1988049794-1"></a><a id="i1464737226-2"></a>
The expression <span class="code">x</span>&nbsp;<span class="code">before</span>&nbsp;<span class="code">y</span> should return
<span class="code">true</span> if <span class="code">x</span> should come before <span class="code">y</span> in the intended ordering for the sort.
For instance:
<pre>
  scala&gt;&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;-<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">6</span>)&nbsp;sort&nbsp;(_&nbsp;&lt;&nbsp;_)
  <span class="output">res48:&nbsp;List[Int]&nbsp;=&nbsp;List(-3,&nbsp;1,&nbsp;2,&nbsp;4,&nbsp;6)</span>
  <br />  scala&gt;&nbsp;words&nbsp;sort&nbsp;(_.length&nbsp;&gt;&nbsp;_.length)
  <span class="output">res49:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(quick,&nbsp;brown,&nbsp;fox,&nbsp;the)</span>
</pre><!-- -->
Note that <span class="code">sort</span> performs a merge sort similar to the
<span class="code">msort</span> algorithm shown in the last section, but it is a method of class <span class="code">List</span> 
whereas <span class="code">msort</span> was defined outside lists.</p>

<h3><a name="16.8"></a>16.8 Methods of the <span class="code">List</span> object <span style="font-size: .5em">[<a href="working-with-lists.html#16.8">link</a>]</span></h3>


<p>So far, all operations you have seen in this chapter are implemented
as methods of class <span class="code">List</span>, so you invoke them on individual list
objects. There are also a number of methods in the globally accessible
object <span class="code">scala.List</span>, which is the companion object of class <span class="code">List</span>.
Some of these operations are factory methods that create lists.
Others are operations that work on lists of some specific shape.
Both kinds of methods will be presented in this section.</p>

<h4>Creating lists from their elements: <span class="code">List.apply</span></h4>


<p>You've already seen on several occasions list literals such as
<span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>.
There's nothing special about their syntax. A literal like
<span class="code">List(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span><a id="i19484993-2"></a><a id="i1305057997-2"></a> is simply the application of the object <span class="code">List</span> to
the elements <span class="code">1</span>, <span class="code">2</span>, <span class="code">3</span>. That is, it is equivalent to <span class="code">List.apply(1,</span>&nbsp;<span class="code">2,</span>&nbsp;<span class="code">3)</span>:
<pre>
  scala&gt;&nbsp;List.apply(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">res50:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3)</span>
</pre><!-- --></p>

<h4>Creating a range of numbers: <span class="code">List.range</span></h4>


<p>The <span class="code">range</span> method, which you saw briefly earlier in the chapter in the discussion of <span class="code">map</span> and <span class="code">flatmap</span>,
creates a list consisting of a range of numbers.
Its simplest form is <span class="code">List.range(from,</span>&nbsp;<span class="code">until)</span>,<a id="i648409480-1"></a><a id="i1320308892-2"></a> which creates a list of all 
numbers starting at <span class="code">from</span> and going up to <span class="code">until</span> minus one. So the
end value, <span class="code">until</span>, does not form part of the range.</p>

<p>There's also a version of <span class="code">range</span> that takes a <span class="code">step</span> value as 
third parameter. This operation will yield list elements
that are <span class="code">step</span> values apart, starting at <span class="code">from</span>. The <span class="code">step</span> can be positive 
or negative: 
<pre>
  scala&gt;&nbsp;List.range(<span class="literal">1</span>,&nbsp;<span class="literal">5</span>)
  <span class="output">res51:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;2,&nbsp;3,&nbsp;4)</span>
  <br />  scala&gt;&nbsp;List.range(<span class="literal">1</span>,&nbsp;<span class="literal">9</span>,&nbsp;<span class="literal">2</span>)
  <span class="output">res52:&nbsp;List[Int]&nbsp;=&nbsp;List(1,&nbsp;3,&nbsp;5,&nbsp;7)</span>
  <br />  scala&gt;&nbsp;List.range(<span class="literal">9</span>,&nbsp;<span class="literal">1</span>,&nbsp;-<span class="literal">3</span>)
  <span class="output">res53:&nbsp;List[Int]&nbsp;=&nbsp;List(9,&nbsp;6,&nbsp;3)</span>
</pre><!-- --></p>

<h4>Creating uniform lists: <span class="code">List.make</span></h4>


<p>The <span class="code">make</span><a id="i1831752402-1"></a><a id="i-1204484433-1"></a> method creates a list consisting of 
zero or more copies of the same element. It takes two parameters:
the length of the list to be created, and the element to be repeated:
<pre>
  scala&gt;&nbsp;List.make(<span class="literal">5</span>,&nbsp;<span class="quotedstring">'a'</span>)
  <span class="output">res54:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;a,&nbsp;a,&nbsp;a,&nbsp;a)</span>
  <br />  scala&gt;&nbsp;List.make(<span class="literal">3</span>,&nbsp;<span class="quotedstring">"hello"</span>)
  <span class="output">res55:&nbsp;List[java.lang.String]&nbsp;=&nbsp;List(hello,&nbsp;hello,&nbsp;hello)</span>
</pre><!-- --></p>

<h4>Unzipping lists: <span class="code">List.unzip</span></h4>


<p>The <span class="code">unzip</span><a id="i-1041609908-1"></a><a id="i1323478343-1"></a> operation is the inverse of <span class="code">zip</span>. Where <span class="code">zip</span> takes two lists
and forms a list of pairs, <span class="code">unzip</span> takes a list of pairs and 
returns two lists, one consisting of the first element of each pair, 
the other consisting of the second element:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;zipped&nbsp;=&nbsp;<span class="quotedstring">"abcde"</span>.toList&nbsp;zip&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>,&nbsp;<span class="literal">3</span>)
  <span class="output">zipped:&nbsp;List[(Char,&nbsp;Int)]&nbsp;=&nbsp;List((a,1),&nbsp;(b,2),&nbsp;(c,3))</span>
  <br />  scala&gt;&nbsp;List.unzip(zipped)
  <span class="output">res56:&nbsp;(List[Char],&nbsp;List[Int])&nbsp;=&nbsp;(List(a,&nbsp;b,&nbsp;c),</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;List(1,&nbsp;2,&nbsp;3))</span>
</pre><!-- -->
<br /></p>

<div class="note">
<h4>Note</h4>


<p>You might wonder why <span class="code">unzip</span> 
is a method of the global <span class="code">List</span> object, instead of being a method
of class <span class="code">List</span>. The problem is that <span class="code">unzip</span> does not work on any list
but only on a list of pairs, whereas Scala's type system requires every method
of a class to be available on every instance of that class.
Thus, <span class="code">unzip</span> cannot go in the <span class="code">List</span> class.
It might be possible to extend Scala's type system in the future so that it 
accepts methods that only apply to some instances of a class, but so far
this has not been done.</p>

</div>


<h4>Concatenating lists: <span class="code">List.flatten</span>, <span class="code">List.concat</span></h4>


<p>The <span class="code">flatten</span><a id="i-1020929432-1"></a><a id="i44703139-2"></a> method takes a list of lists and concatenates all
element lists of the main list. For example:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;xss&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="typename">List</span>(<span class="quotedstring">'a'</span>,&nbsp;<span class="quotedstring">'b'</span>),&nbsp;<span class="typename">List</span>(<span class="quotedstring">'c'</span>),&nbsp;<span class="typename">List</span>(<span class="quotedstring">'d'</span>,&nbsp;<span class="quotedstring">'e'</span>))
  <span class="output">xss:&nbsp;List[List[Char]]&nbsp;=&nbsp;List(List(a,&nbsp;b),&nbsp;List(c),&nbsp;List(d,&nbsp;e))</span>
  <br />  scala&gt;&nbsp;List.flatten(xss)
  <span class="output">res57:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e)</span>
</pre><!-- --></p>

<p><br /></p>

<div class="note">
<h4>Note</h4>


<p>The <span class="code">flatten</span> method is packaged in the global <span class="code">List</span> object for the same reason as <span class="code">unzip</span>:
it does not operate on any list, but only on lists with lists as elements,
so it can't be a method of the generic <span class="code">List</span> class.</p>

</div>


<p>The <span class="code">concat</span><a id="i-214121608-1"></a><a id="i1858358165-1"></a> method is similar to <span class="code">flatten</span> in that it concatenates
a number of element lists. The element lists are given directly 
as repeated parameters. The number of lists to be passed to <span class="code">concat</span> is arbitrary:
<pre>
  scala&gt;&nbsp;List.concat(<span class="typename">List</span>(<span class="quotedstring">'a'</span>,&nbsp;<span class="quotedstring">'b'</span>),&nbsp;<span class="typename">List</span>(<span class="quotedstring">'c'</span>))
  <span class="output">res58:&nbsp;List[Char]&nbsp;=&nbsp;List(a,&nbsp;b,&nbsp;c)</span>
  <br />  scala&gt;&nbsp;List.concat(<span class="typename">List</span>(),&nbsp;<span class="typename">List</span>(<span class="quotedstring">'b'</span>),&nbsp;<span class="typename">List</span>(<span class="quotedstring">'c'</span>))
  <span class="output">res59:&nbsp;List[Char]&nbsp;=&nbsp;List(b,&nbsp;c)</span>
  <br />  scala&gt;&nbsp;List.concat()
  <span class="output">res60:&nbsp;List[Nothing]&nbsp;=&nbsp;List()</span>
</pre><!-- --></p>

<h4>Mapping and testing pairs of lists: <span class="code">List.map2</span>, <span class="code">List.forall2</span>, <span class="code">List.exists2</span></h4>


<p>The <span class="code">map2</span><a id="i-1856727750-1"></a><a id="i-1204484329-1"></a> method is similar to <span class="code">map</span>, but it takes two lists as arguments together
with a function that maps two element values to a result. The function
gets applied to corresponding elements of the two lists, and a list is formed from the results:
<pre>
  scala&gt;&nbsp;List.map2(<span class="typename">List</span>(<span class="literal">10</span>,&nbsp;<span class="literal">20</span>),&nbsp;<span class="typename">List</span>(<span class="literal">3</span>,&nbsp;<span class="literal">4</span>,&nbsp;<span class="literal">5</span>))&nbsp;(_&nbsp;*&nbsp;_)
  <span class="output">res61:&nbsp;List[Int]&nbsp;=&nbsp;List(30,&nbsp;80)</span>
</pre><!-- -->
The <span class="code">exists2</span><a id="i281503290-1"></a><a id="i-491891979-1"></a> and <span class="code">forall2</span><a id="i-1614645538-1"></a><a id="i145716889-1"></a> methods are similar to <span class="code">exists</span> and <span class="code">forall</span>, 
respectively, but they also take two lists and a boolean predicate that takes 
two arguments. The predicate is applied to corresponding arguments:
<pre>
  scala&gt;&nbsp;List.forall2(<span class="typename">List</span>(<span class="quotedstring">"abc"</span>,&nbsp;<span class="quotedstring">"de"</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">3</span>,&nbsp;<span class="literal">2</span>))&nbsp;(_.length&nbsp;==&nbsp;_)
  <span class="output">res62:&nbsp;Boolean&nbsp;=&nbsp;true</span>
  <br />  scala&gt;&nbsp;List.exists2(<span class="typename">List</span>(<span class="quotedstring">"abc"</span>,&nbsp;<span class="quotedstring">"de"</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="literal">3</span>,&nbsp;<span class="literal">2</span>))&nbsp;(_.length&nbsp;!=&nbsp;_)
  <span class="output">res63:&nbsp;Boolean&nbsp;=&nbsp;false</span>
</pre><!-- --></p>

<div class="pointofinterest">
<h3>The fast track</h3>


<p>In the next (and final) section of this chapter, we provide insight into Scala's type inference algorithm. You can safely
skip the entire section if you're not interested in such details right now, and instead go straight to the conclusion
<a href="working-with-lists.html#sec:list-conclusion">here</a>.</p>

</div>


<h3><a name="16.9"></a>16.9 Understanding Scala's type inference algorithm <span style="font-size: .5em">[<a href="working-with-lists.html#16.9">link</a>]</span></h3>


<p>One difference<a id="i2062825537-1"></a><a id="i2147374841-1"></a> between the previous uses of <span class="code">sort</span> and <span class="code">msort</span> concerns the 
admissible syntactic forms of the comparison function. Compare:
<pre>
  scala&gt;&nbsp;msort((x:&nbsp;<span class="typename">Char</span>,&nbsp;y:&nbsp;<span class="typename">Char</span>)&nbsp;=&gt;&nbsp;x&nbsp;&gt;&nbsp;y)(abcde)
  <span class="output">res64:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</span>
</pre><!-- -->
with:
<pre>
  scala&gt;&nbsp;abcde&nbsp;sort&nbsp;(_&nbsp;&gt;&nbsp;_)
  <span class="output">res65:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</span>
</pre><!-- -->
The two expressions are equivalent, but the first uses a 
longer form of comparison function with named parameters and explicit types whereas
the second uses the concise form, <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>, where named 
parameters are replaced by underscores. Of course, you could 
also use the first, longer form of comparison with <span class="code">sort</span>. 
However, the short form cannot be used with <span class="code">msort</span>:</p>

<pre>
  scala&gt;&nbsp;msort(_&nbsp;&gt;&nbsp;_)(abcde)
  <span class="output">&lt;console&gt;:12:&nbsp;error:&nbsp;missing&nbsp;parameter&nbsp;type&nbsp;for&nbsp;expanded&nbsp;</span>
  <span class="output">function&nbsp;((x$1,&nbsp;x$2)&nbsp;=&gt;&nbsp;x$1.$greater(x$2))</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msort(_&nbsp;&gt;&nbsp;_)(abcde)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- -->


<p>To understand why, you need to know some details of Scala's type inference algorithm.
Type inference in Scala is flow based. In a method application <span class="code">m(args)</span>, 
the inferencer first checks whether the method <span class="code">m</span> has a known type.  
If it has, that type is used to infer the expected type of the arguments.
For instance, in <span class="code">abcde.sort(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>, the type of <span class="code">abcde</span> is <span class="code">List[Char]</span>, 
hence <span class="code">sort</span> is known to be a method that takes an argument
of type <span class="code">(Char,</span>&nbsp;<span class="code">Char)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span> and produces a result of type <span class="code">List[Char]</span>.
Since the parameter types of the function arguments are thus
known, they need not be written explicitly. 
With what it knows about <span class="code">sort</span>, the inferencer can deduce 
that <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span> should expand to <span class="code">((x:</span>&nbsp;<span class="code">Char,</span>&nbsp;<span class="code">y:</span>&nbsp;<span class="code">Char)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">x</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">y)</span> where
<span class="code">x</span> and <span class="code">y</span> are some arbitrary fresh names.</p>

<p>Now consider the second case, <span class="code">msort(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)(abcde)</span>. 
The type of <span class="code">msort</span> is a curried, polymorphic method type
that takes an argument of type <span class="code">(T,</span>&nbsp;<span class="code">T)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">Boolean</span> to a function from
<span class="code">List[T]</span> to <span class="code">List[T]</span> <span style="font-style:italic">where <span class="code">T</span> is some as-yet unknown type</span>. 
The <span class="code">msort</span> method needs to be instantiated with a type parameter 
before it can be applied to its arguments. 
Because the precise instance type of <span class="code">msort</span> in the application is not yet known, 
it cannot be used to infer the type of its first argument.
The type inferencer changes its strategy 
in this case; it first type checks method arguments to determine 
the proper instance type of the method. However, when tasked to 
type check the short-hand function literal, <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>, it fails because it 
has no information about the 
types of the implicit function parameters that are indicated by underscores.</p>

<p>One way to resolve the problem is to pass an explicit type 
parameter to <span class="code">msort</span>, as in:
<pre>
  scala&gt;&nbsp;msort[<span class="typename">Char</span>](_&nbsp;&gt;&nbsp;_)(abcde)
  <span class="output">res66:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</span>
</pre><!-- -->
Because the correct instance type of <span class="code">msort</span> is now known, 
it can be used to infer the type of the arguments.</p>

<p>Another possible solution is to rewrite the <span class="code">msort</span> method so 
that its parameters are swapped:
<pre>
  <span class="vem">def</span>&nbsp;msortSwapped[T](xs:&nbsp;<span class="typename">List[T]</span>)(less:
  &nbsp;&nbsp;&nbsp;&nbsp;(T,&nbsp;T)&nbsp;=&gt;&nbsp;<span class="typename">Boolean</span>):&nbsp;<span class="typename">List[T]</span>&nbsp;=&nbsp;{
  <br />  &nbsp;&nbsp;<span class="comment">//&nbsp;same&nbsp;implementation&nbsp;as&nbsp;msort,</span>
  &nbsp;&nbsp;<span class="comment">//&nbsp;but&nbsp;with&nbsp;arguments&nbsp;swapped</span>
  }
</pre><!-- -->
Now type inference would succeed:
<pre>
  scala&gt;&nbsp;msortSwapped(abcde)(_&nbsp;&gt;&nbsp;_)
  <span class="output">res67:&nbsp;List[Char]&nbsp;=&nbsp;List(e,&nbsp;d,&nbsp;c,&nbsp;b,&nbsp;a)</span>
</pre><!-- -->
What has happened is that the inferencer used the known type of 
the first parameter <span class="code">abcde</span> to determine the type
parameter of <span class="code">msortSwapped</span>. Once the precise type of <span class="code">msortSwapped</span> was known, 
it could be used in turn to infer the type of the second parameter, <span class="code">(_</span>&nbsp;<span class="code">&gt;</span>&nbsp;<span class="code">_)</span>.</p>

<p>Generally, when tasked to infer the type parameters of a polymorphic
method, the type inferencer consults the types of all value arguments
in the first parameter list but no arguments beyond
that. Since <span class="code">msortSwapped</span> is a curried method with two parameter lists,
the second argument (<i>i.e.</i>, the function value) did not need to be consulted
to determine the type parameter of the method.</p>

<p>This inference scheme suggests the following library design principle:
When designing a polymorphic method that takes some non-function
arguments and a function argument, place the function argument last in a
curried parameter list by its own<a id="i-1510488017-1"></a>. That way, the method's correct
instance type can be inferred from the non-function arguments, and
that type can in turn be used to type check the function argument. The
net effect is that users of the method will be able to give less type
information and write function literals in more compact ways.</p>

<p>Now to the more complicated case of a <span style="font-style:italic">fold</span> operation. 
Why is there the need for an explicit type parameter in an expression like 
the body of the <span class="code">flattenRight</span> method shown previously?
<pre>
  (xss&nbsp;:~<span class="typename">List[T]</span>())&nbsp;(_&nbsp;:::&nbsp;_)
</pre><!-- -->
The type of the fold-right operation is polymorphic in two type variables.
Given an expression:
<pre>
  (xs&nbsp;:~z)&nbsp;(op)
</pre><!-- -->
The type of <span class="code">xs</span> must be a list of some arbitrary type <span class="code">A</span>, 
say <span class="code">xs:</span>&nbsp;<span class="code">List[A]</span>. The start value <span class="code">z</span> can be of some other type <span class="code">B</span>.
The operation <span class="code">op</span> must then take two arguments of type <span class="code">A</span> and <span class="code">B</span> 
and must return a result of type <span class="code">B</span>, <i>i.e.</i>, <span class="code">op:</span>&nbsp;<span class="code">(A,</span>&nbsp;<span class="code">B)</span>&nbsp;<span class="code">=&gt;</span>&nbsp;<span class="code">B</span>.
Because the type of <span class="code">z</span> is not related to the type of the list
<span class="code">xs</span>, type inference has no context information for <span class="code">z</span>.
Now consider the erroneous expression in the method <span class="code">flattenRight</span> above:
<pre>
  (xss&nbsp;:~<span class="typename">List</span>())&nbsp;(_&nbsp;:::&nbsp;_)&nbsp;&nbsp;<span class="comment">//&nbsp;this&nbsp;won't&nbsp;compile</span>
</pre><!-- -->
The start value <span class="code">z</span> in this fold is an empty list, <span class="code">List()</span>,
so without additional type information its type is inferred to 
be a <span class="code">List[Nothing]</span>. 
Hence, the inferencer will infer that the <span class="code">B</span> type of the fold is 
<span class="code">List[Nothing]</span>. Therefore, the operation <span class="code">(_</span>&nbsp;<span class="code">:::</span>&nbsp;<span class="code">_)</span> of the fold
is expected to be of the following type:
<pre>
  (<span class="typename">List[T]</span>,&nbsp;<span class="typename">List[Nothing]</span>)&nbsp;=&gt;&nbsp;<span class="typename">List[Nothing]</span>
</pre><!-- -->
This is indeed a possible type for the operation in that fold but it
is not a very useful one! It says that the operation always takes an
empty list as second argument and always produces an empty list as
result.  In other words, the type inference settled too early on a
type for <span class="code">List()</span>, it should have waited until it had seen
the type of the operation <span class="code">op</span>.  So the (otherwise very useful) rule
to only consider the first argument section in a curried method
application for determining the method's type is at the root of the
problem here.  On the other hand, even if that rule were relaxed, the
inferencer still could not come up with a type for <span class="code">op</span> because its
parameter types are not given. Hence, there is a Catch-22
situation which can only be resolved by an explicit type annotation
from the programmer.</p>

<p>This example highlights some limitations of the local, flow-based type
inference scheme of Scala. It is not present in the more global
Hindley-Milner style of type inference used in functional
languages such as ML or
Haskell.<a id="i281902151-1"></a><a id="i-402843137-1"></a>  However, Scala's local type inference
deals much more gracefully with object-oriented subtyping than the
Hindley-Milner style does.  Fortunately, the
limitations show up only in some corner cases, and are usually easily
fixed by adding an explicit type annotation.</p>

<p>Adding type annotations<a id="i-250763219-1"></a><a id="i-2128117477-1"></a> is also a useful debugging technique when you
get confused by type error messages related to polymorphic methods. If
you are unsure what caused a particular type error, just add some type
arguments or other type annotations, which you think are correct. Then
you should be able to quickly see where the real problem is.</p>

<h3><a name="16.10"></a>16.10 Conclusion <span style="font-size: .5em">[<a href="working-with-lists.html#16.10">link</a>]</span></h3>


<p><a name="sec:list-conclusion"></a></p>

<p>Now you have seen many ways to work with lists.  You have seen the
basic operations like <span class="code">head</span> and <span class="code">tail</span>, the first-order operations
like <span class="code">reverse</span>, the higher-order operations like <span class="code">map</span>, and the
utility methods in the <span class="code">List</span> object.  Along the way, you
learned a bit about how Scala's type inference works.</p>

<p>Lists are a real work horse in Scala, so you will benefit from knowing
how to use them.  For that reason, this chapter has delved deeply into
how to use lists.  Lists are just one kind of collection that Scala
supports, however.  The next chapter is broad, rather than deep, and
shows you how to use a variety of Scala's collection types.</p>

<hr/>
<h4>Footnotes for Chapter 16:</h4>


<p><a name="footnote16-1">[1]</a> For a graphical
depiction of the structure of a <span class="code">List</span>, see <a href="implementing-lists.html#fig:more-fruit">Figure 22.2</a> <a href="implementing-lists.html#fig:more-fruit">here</a>.</p>

<p><a name="footnote16-2">[2]</a> <a href="type-parameterization.html">Chapter 19</a> gives more details on covariance and other kinds of variance.</p>

<p><a name="footnote16-3">[3]</a> Type parameters will be explained in
more detail in <a href="type-parameterization.html">Chapter 19</a>.</p>

<p><a name="footnote16-4">[4]</a> As mentioned in <a href="composition-and-inheritance.html#sec:impl-above-beside-tostring">Section 10.12</a>, the term <em>pair</em> is an
informal name for <span class="code">Tuple2</span>.</p>

<p><a name="footnote16-5">[5]</a> This is class 
<span class="code">scala.StringBuilder</span>, not <span class="code">java.lang.StringBuilder</span>.</p>

<p><a name="footnote16-6">[6]</a> By <em>higher-order operators</em>, we mean higher-order functions used in
operator notation. As mentioned in <a href="control-abstraction.html#sec:reducing-code-dup">Section 9.1</a>, higher-order functions are functions that take other functions
as parameters.</p>

<p><a name="footnote16-7">[7]</a> <span class="code">List.flatten</span> will be explained in the next section of this chapter.</p>



<br clear="all">
<p>
<center>
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/working-with-listsP.html">Print</a>&nbsp;| 
<a href="/pins1ed/case-classes-and-pattern-matching.html">Previous</a>&nbsp;| 
<a href="/pins1ed/collections.html">Next</a>
</div>
</center>
</div>
<hr width="100%" />
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<br />
<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/custom">
<table border="0" bgcolor="#ffffff">
<tr><td nowrap="nowrap" valign="top" align="left" height="32">
<a href="http://www.google.com/">
<img src="http://www.google.com/logos/Logo_25wht.gif"
border="0" alt="Google"></img></a>
</td>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="Artima.com"></input>
<input type="text" name="q" size="31" maxlength="255" value=""></input>
<input type="submit" name="sa" value="Search"></input>
</td></tr>
<tr>
<td>&nbsp;</td>
<td nowrap="nowrap">
<font size="-1" color="#000000">
<input type="radio" name="sitesearch" value=""></input> Web
<input type="radio" name="sitesearch" value="Artima.com" checked="checked"></input>Artima.com
</font>&nbsp;&nbsp;
<input type="hidden" name="client" value="pub-3911176865765226"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:http://www.artima.com/images/artima150.gif;S:http://www.artima.com;FORID:1;"></input>
<input type="hidden" name="hl" value="en"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</center>
<div class="sp">
<div style="text-align: center">
<a href="http://www.artima.com/copyright.html">Copyright</a> &copy; 1996-2014 Artima, Inc. All Rights Reserved.</a> - <a href="http://www.artima.com/privacy.html">Privacy Policy</a> - <a href="http://www.artima.com/termsofuse.html">Terms of Use</a> - <a href="http://www.artima.com/advertising.html">Advertise with Us</a>
</div>
</div>
<br />
</body>
</html>
