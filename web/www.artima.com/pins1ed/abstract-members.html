<html>
<head>
<title>Abstract Members</title>
<meta name="description" content="
" />
<meta name="keywords" content="scala" />
<meta name="author" content="Martin Odersky, Lex Spoon, and Bill Venners" />
<link rel="stylesheet" type="text/css" href="/artima.css" />
<link rel="shortcut icon" href="/favicon.ico" />
</head>
<body><table width="100%" cellspacing="0">
<tr>
<td align="left" valign="bottom">
<a href="/index.jsp"><img src="/images/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43" /></a>
</td>
</table>
<table width="100%" bgcolor="#333333">
<tr>
<td align="center">
<div class="ml">
<a href="/articles" class="hl">Articles</a>&nbsp;|
<a href="/news/index.jsp" class="hl">News</a>&nbsp;|
<a href="/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;|
<a href="/buzz/index.jsp" class="hl">Buzz</a>&nbsp;|
<a href="/shop/catalog" class="hl">Books</a>&nbsp;|
<a href="/forums/index.jsp" class="hl">Forums</a>
</div>
</td>
</tr>
</table>
<table width="100%" bgcolor="#AACCFF">
<tr>
<td align="center">
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/abstract-membersP.html">Print</a>&nbsp;| 
<a href="/pins1ed/type-parameterization.html">Previous</a>&nbsp;| 
<a href="/pins1ed/implicit-conversions-and-parameters.html">Next</a>
</div>
</td>
</tr>
</table>
<BR>
<div class="vegies">
<div class="tc">
<span class="sts">Chapter 20 of Programming in Scala, First Edition</span><br />
<span class="ts">Abstract Members</span><br />
<span class="as">by Martin Odersky, Lex Spoon, and Bill Venners</span><br />
<span class="pd">December 10, 2008</span><br />
</div>




<p>A member of a class or trait is <span style="font-style:italic">abstract</span> if the member does not
have a complete definition in the class.<a id="i785070065-1"></a><a id="i184187235-1"></a> Abstract members are intended
to be implemented in subclasses of the class in which they are
declared. This idea is found in many object-oriented languages. For
instance, Java lets you declare abstract methods.  Scala also lets you
declare such methods, as you saw in
<a href="composition-and-inheritance.html#sec:abstract-classes">Section 10.2</a>. But Scala goes beyond
that and implements the idea in its full generality: besides methods,
you can also declare abstract fields and even abstract types
as members of classes and traits.</p>

<p>In this chapter we'll describe all four kinds of abstract member: <span class="code">val</span>s, <span class="code">var</span>s, methods, and types. Along the way we'll discuss
pre-initialized fields, lazy <span class="code">val</span>s, path-dependent types, and enumerations.</p>

<h3><a name="20.1"></a>20.1 A quick tour of abstract members <span style="font-size: .5em">[<a href="abstract-members.html#20.1">link</a>]</span></h3>


<p>The following trait declares one of each kind of abstract member: an abstract type (<span class="code">T</span>), method (<span class="code">transform</span>), <span class="code">val</span> (<span class="code">initial</span>), and <span class="code">var</span> (<span class="code">current</span>):<a id="i-1463644999-1"></a>
<pre>
  <span class="vem">trait</span>&nbsp;<span class="typename">Abstract</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;T
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;transform(x:&nbsp;T):&nbsp;T
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;initial:&nbsp;T
  &nbsp;&nbsp;<span class="vem">var</span>&nbsp;current:&nbsp;T
  }
</pre><!-- -->
A concrete implementation of <span class="code">Abstract</span> needs to fill in definitions for each of its
abstract members. Here is an example implementation that provides these definitions:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Concrete</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Abstract</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;T&nbsp;=&nbsp;<span class="typename">String</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;transform(x:&nbsp;<span class="typename">String</span>)&nbsp;=&nbsp;x&nbsp;+&nbsp;x
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;initial&nbsp;=&nbsp;<span class="quotedstring">"hi"</span>
  &nbsp;&nbsp;<span class="vem">var</span>&nbsp;current&nbsp;=&nbsp;initial
  }
</pre><!-- -->
The implementation gives a concrete meaning to the type name <span class="code">T</span> by
defining it as an alias of type <span class="code">String</span>.<a id="i1803174454-1"></a><a id="i22781976-1"></a> The <span class="code">transform</span> operation
concatenates a given string with itself, and the <span class="code">initial</span> and
<span class="code">current</span> values are both set to <span class="code">"hi"</span>.</p>

<p>This example gives you a rough first idea of what kinds of abstract
members exist in Scala. The remainder of the chapter will present the details and
explain what the new forms of abstract members, as well as type members in general, are good for.</p>

<h3><a name="20.2"></a>20.2 Type members <span style="font-size: .5em">[<a href="abstract-members.html#20.2">link</a>]</span></h3>


<p><a name="sec:abstract-vals"></a></p>

<p>As you can see from the example in the previous section, the term <em>abstract type</em> in Scala means a type<a id="i1886198323-1"></a>
declared (with the "<span class="code">type</span>" keyword) to be a member
of a class or trait, without specifying a
definition.<a id="i475521275-1"></a><a id="i-1569140754-2"></a> Classes themselves may be abstract, and traits are by definition abstract, but neither of these are what are referred to as <em>abstract
types</em> in Scala. An abstract type in Scala is always a member of some class or trait, such as type <span class="code">T</span> in trait <span class="code">Abstract</span>.</p>

<p>You can think of a non-abstract (or, "concrete") type member, such as
type <span class="code">T</span> in class <span class="code">Concrete</span>, as a way to define a new name, or
<em>alias</em>, for a type.<a id="i22781976-2"></a><a id="i1803174454-2"></a> In class
<span class="code">Concrete</span>, for example, the type <span class="code">String</span> is given the alias <span class="code">T</span>. As a result, anywhere <span class="code">T</span> appears in the definition of class <span class="code">Concrete</span>, it
means <span class="code">String</span>. This includes the parameter and result types of <span class="code">transform</span>, <span class="code">initial</span>, and <span class="code">current</span>, which mention <span class="code">T</span> when
they are declared in supertrait <span class="code">Abstract</span>. Thus, when class <span class="code">Concrete</span> implements these methods, those <span class="code">T</span>s are interpreted to mean <span class="code">String</span>.</p>

<p>One reason to use a type member is to define a short, descriptive alias<a id="i22781976-3"></a><a id="i1803174454-3"></a> for a type whose real name is more verbose, or
less obvious in meaning, than the alias. Such type members can help clarify the code of a class or trait. The other main use of
type members is to declare abstract types that must be defined
in subclasses. This use, which was demonstrated in the previous section, will be described in detail later in this chapter.</p>

<h3><a name="20.3"></a>20.3 Abstract <span class="code">val</span>s <span style="font-size: .5em">[<a href="abstract-members.html#20.3">link</a>]</span></h3>


<p><a name="sec:abstract-vals"></a></p>

<p>An abstract <span class="code">val</span> declaration has a form like:
<pre>
  <span class="vem">val</span>&nbsp;initial:&nbsp;<span class="typename">String</span>
</pre><!-- -->
It gives a name and type for a <span class="code">val</span>, but not its
value.<a id="i1727592746-1"></a>
This value has to be provided by a concrete <span class="code">val</span> definition in a subclass.
For instance, class <span class="code">Concrete</span> implemented the <span class="code">val</span> using:
<pre>
  <span class="vem">val</span>&nbsp;initial&nbsp;=&nbsp;<span class="quotedstring">"hi"</span>
</pre><!-- -->
You use an abstract <span class="code">val</span> declaration in a class when you do not know
the correct value in the class, but you do know that the variable will have an 
unchangeable value in each instance of the class.</p>

<p>An abstract <span class="code">val</span> declaration resembles an abstract parameterless<a id="i1692897037-1"></a><a id="i748048051-1"></a><a id="i84167179-1"></a>
method declaration such as:
<pre>
  <span class="vem">def</span>&nbsp;initial:&nbsp;<span class="typename">String</span>
</pre><!-- -->
Client code would refer to both the <span class="code">val</span> and the method in exactly the
same way, <i>i.e.</i>, <span class="code">obj.initial</span>. However, if <span class="code">initial</span> is an abstract <span class="code">val</span>,
the client is guaranteed that <span class="code">obj.initial</span> will yield the
same value every time it is referenced.  If <span class="code">initial</span> were an abstract
method, that guarantee would not hold, because in that case
<span class="code">initial</span> could be implemented by a concrete method that returns a
different value every time it's called.</p>

<p>In other words, an abstract <span class="code">val</span> constrains its legal implementation:
any implementation must be a <span class="code">val</span> definition; it may not be a <span class="code">var</span>
or a <span class="code">def</span>. Abstract method declarations, on the other hand,
may be implemented by both concrete method definitions and concrete
<span class="code">val</span> definitions.  Given the abstract class <span class="code">Fruit</span> shown in <a href="abstract-members.html#lst:bad-apple">Listing 20.1</a>, class <span class="code">Apple</span>
would be a legal subclass implementation, but class <span class="code">BadApple</span> would not.
<a name="lst:bad-apple"></a></p>

<pre>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Fruit</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;v:&nbsp;<span class="typename">String</span>&nbsp;<span class="comment">//&nbsp;`v'&nbsp;for&nbsp;value</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;m:&nbsp;<span class="typename">String</span>&nbsp;<span class="comment">//&nbsp;`m'&nbsp;for&nbsp;method</span>
  }
  <br />  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Apple</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Fruit</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;v:&nbsp;<span class="typename">String</span>
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;m:&nbsp;<span class="typename">String</span>&nbsp;<span class="comment">//&nbsp;OK&nbsp;to&nbsp;override&nbsp;a&nbsp;`def'&nbsp;with&nbsp;a&nbsp;`val'</span>
  }
  <br />  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">BadApple</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Fruit</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;v:&nbsp;<span class="typename">String</span>&nbsp;<span class="comment">//&nbsp;ERROR:&nbsp;cannot&nbsp;override&nbsp;a&nbsp;`val'&nbsp;with&nbsp;a&nbsp;`def'</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;m:&nbsp;<span class="typename">String</span>
  }
</pre><!-- -->


<h5>Listing 20.1 - Overriding abstract <span class="code">val</span>s and parameterless methods.</h5>


<h3><a name="20.4"></a>20.4 Abstract <span class="code">var</span>s <span style="font-size: .5em">[<a href="abstract-members.html#20.4">link</a>]</span></h3>


<p>Like an abstract <span class="code">val</span>, an abstract <span class="code">var</span> declares just a name and a
type, but not an initial value<a id="i-464180816-1"></a>. For instance, <a href="abstract-members.html#lst:abstract-vars">Listing 20.2</a> shows a trait
<span class="code">AbstractTime</span>, which declares two abstract variables named <span class="code">hour</span> and
<span class="code">minute</span>:</p>

<p><a name="lst:abstract-vars"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">trait</span>&nbsp;<span class="typename">AbstractTime</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">var</span>&nbsp;hour:&nbsp;<span class="typename">Int</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">var</span>&nbsp;minute:&nbsp;<span class="typename">Int</span>
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.2 - Declaring abstract <span class="code">var</span>s.</h5>


<p>What is the meaning of abstract <span class="code">var</span>s
like <span class="code">hour</span> and
<span class="code">minute</span>?  You saw in <a href="stateful-objects.html#sec:properties">Section 18.2</a> that
<span class="code">var</span>s declared as members of classes come equipped with getter and
setter methods<a id="i553650449-2"></a><a id="i-1969580643-3"></a>. This holds for abstract <span class="code">var</span>s as well.
If you declare an abstract <span class="code">var</span> named <span class="code">hour</span>, for example, you implicitly declare an abstract
getter method, <span class="code">hour</span>, and an abstract setter method, <span class="code">hour_=</span>.
There's no reassignable field to be defined&mdash;that will come in subclasses
that define the concrete implementation of the abstract <span class="code">var</span>.
For instance, the definition of <span class="code">AbstractTime</span> shown in <a href="abstract-members.html#lst:abstract-vars">Listing 20.2</a> is
exactly equivalent to the definition shown in <a href="abstract-members.html#lst:abstract-vars-expanded">Listing 20.3</a>.
<a name="lst:abstract-vars-expanded"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">trait</span>&nbsp;<span class="typename">AbstractTime</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;hour:&nbsp;<span class="typename">Int</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;getter&nbsp;for&nbsp;`hour'</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;hour_=(x:&nbsp;<span class="typename">Int</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;setter&nbsp;for&nbsp;`hour'</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;minute:&nbsp;<span class="typename">Int</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;getter&nbsp;for&nbsp;`minute'</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;minute_=(x:&nbsp;<span class="typename">Int</span>)&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;setter&nbsp;for&nbsp;`minute'</span>
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.3 - How abstract <span class="code">var</span>s are expanded into getters and setters.</h5>


<h3><a name="20.5"></a>20.5 Initializing abstract <span class="code">val</span>s <span style="font-size: .5em">[<a href="abstract-members.html#20.5">link</a>]</span></h3>


<p><a name="sec:val-init"></a></p>

<p>Abstract <span class="code">val</span>s sometimes play a role analogous to superclass
parameters: they let you provide details in a subclass that are
missing in a superclass. This is particularly important for traits,
because traits don't have a constructor to which you could pass<a id="i-1985442764-1"></a><a id="i-280981118-1"></a>
parameters. So the usual notion of parameterizing a trait works via
abstract <span class="code">val</span>s that are implemented in subclasses.<a id="i1371895904-1"></a><a id="i-1767979071-1"></a> As an example,
consider a reformulation of class <span class="code">Rational</span> from <a href="functional-objects.html">Chapter 6</a>, as shown in <a href="functional-objects.html#lst:overloaded-methods">Listing 6.5</a> <a href="functional-objects.html#lst:overloaded-methods">here</a>,
as a trait: 
<pre>
  <span class="vem">trait</span>&nbsp;<span class="typename">RationalTrait</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg:&nbsp;<span class="typename">Int</span>&nbsp;
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg:&nbsp;<span class="typename">Int</span>&nbsp;
  }&nbsp;
</pre><!-- -->
The
<span class="code">Rational</span> class from <a href="functional-objects.html">Chapter 6</a> had two
parameters: <span class="code">n</span> for the numerator of the rational number, and <span class="code">d</span>
for the denominator. The <span class="code">RationalTrait</span> trait given here defines
instead two abstract <span class="code">val</span>s: <span class="code">numerArg</span> and <span class="code">denomArg</span>.  To
instantiate a concrete instance of that trait, you need to implement the
abstract <span class="code">val</span> definitions. Here's an example:
<pre>
  <span class="vem">new</span>&nbsp;<span class="typename">RationalTrait</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;<span class="literal">1</span>
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;<span class="literal">2</span>
  }
</pre><!-- -->
Here the keyword <span class="code">new</span> appears in front of a trait name, <span class="code">RationalTrait</span>, which is followed by a class body in curly braces.  This expression
yields an instance of an <a href="glossary.html#g-113939451"><em>anonymous class</em></a> that mixes in the trait
and is defined by the body<a id="i-2121626765-1"></a><a id="i-899295719-1"></a>. 
This particular anonymous class instantiation
has an effect analogous to the instance creation <span class="code">new</span>&nbsp;<span class="code">Rational(1,</span>&nbsp;<span class="code">2)</span>.
The analogy is not perfect, however. There's a subtle difference concerning the 
order in which expressions are initialized. When you write:
<pre>
  <span class="vem">new</span>&nbsp;<span class="typename">Rational</span>(expr1,&nbsp;expr2)
</pre><!-- -->
the two expressions, <span class="code">expr1</span> and <span class="code">expr2</span>, are evaluated before
class <span class="code">Rational</span> is initialized, so the values of <span class="code">expr1</span> and <span class="code">expr2</span> are 
available for the initialization of class <span class="code">Rational</span>. For traits, however, 
the situation is the opposite. When you write:
<pre>
  <span class="vem">new</span>&nbsp;<span class="typename">RationalTrait</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;expr1
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;expr2
  }
</pre><!-- -->
the expressions, <span class="code">expr1</span> and <span class="code">expr2</span>, are evaluated as part of the initialization
of the anonymous class, but the anonymous class is initialized <em>after</em> the <span class="code">RationalTrait</span>. So the values of <span class="code">numerArg</span> and <span class="code">denomArg</span> are not available
during the initialization of <span class="code">RationalTrait</span> (more precisely, a 
selection of either value would yield the default value for type <span class="code">Int</span>, 0).
For the definition of <span class="code">RationalTrait</span> given previously, this is not a problem, because
the trait's initialization does not make use of values <span class="code">numerArg</span> or <span class="code">denomArg</span>.
However, it does become a problem in the variant of <span class="code">RationalTrait</span> shown in <a href="abstract-members.html#lst:rational-trait">Listing 20.4</a>,
which defines normalized numerators and denominators:</p>

<p><a name="lst:rational-trait"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">trait</span>&nbsp;<span class="typename">RationalTrait</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg:&nbsp;<span class="typename">Int</span>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg:&nbsp;<span class="typename">Int</span>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;require(denomArg&nbsp;!=&nbsp;<span class="literal">0</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">val</span>&nbsp;g&nbsp;=&nbsp;gcd(numerArg,&nbsp;denomArg)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numer&nbsp;=&nbsp;numerArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denom&nbsp;=&nbsp;denomArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;gcd(a:&nbsp;<span class="typename">Int</span>,&nbsp;b:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(b&nbsp;==&nbsp;<span class="literal">0</span>)&nbsp;a&nbsp;<span class="vem">else</span>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;denom
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.4 - A trait that uses its abstract <span class="code">val</span>s.</h5>


<p>If you try to instantiate this trait with some numerator and
denominator expressions that are not simple literals, you'll get an exception:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;<span class="literal">2</span>
  <span class="output">x:&nbsp;Int&nbsp;=&nbsp;2</span>
  <br />  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">RationalTrait</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;<span class="literal">2</span>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <span class="output">java.lang.IllegalArgumentException:&nbsp;requirement&nbsp;failed</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;scala.Predef$.require(Predef.scala:107)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;RationalTrait$class.$init$(&lt;console&gt;:7)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at&nbsp;$anon$1.&lt;init&gt;(&lt;console&gt;:7)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....</span>
</pre><!-- -->
The exception in this example was thrown because <span class="code">denomArg</span> still had its
default value of 0 when class <span class="code">RationalTrait</span> was initialized, which caused
the <span class="code">require</span> invocation to fail.</p>

<p>This example demonstrates that initialization order is not the same
for class parameters and abstract fields.<a id="i-1695985614-1"></a><a id="i-17530359-1"></a><a id="i-1356458045-1"></a> A class parameter argument is evaluated <span style="font-style:italic">before</span> it is passed to the class
constructor (unless the parameter is by-name). An implementing <span class="code">val</span>
definition in a subclass, by contrast, is evaluated only <span style="font-style:italic">after</span> the
superclass has been initialized.</p>

<p>Now that you understand why abstract <span class="code">val</span>s behave differently from
parameters, it would be good to know what can be done about this. Is
it possible to define a <span class="code">RationalTrait</span> that can be initialized
robustly, without fearing errors due to uninitialized fields? In fact,
Scala offers two alternative solutions to this problem, <span style="font-style:italic">
pre-initialized fields</span> and <span style="font-style:italic">lazy <span class="code">val</span>s</span>. They are presented in the
remainder of this section.</p>

<h4>Pre-initialized fields</h4>


<p>The first solution, pre-initialized fields, lets you initialize a
field of a subclass before the superclass is
called.<a id="i-1387085847-1"></a><a id="i483675481-1"></a> To do this,
simply place the field definition in braces before the superclass
constructor call. As an example, <a href="abstract-members.html#lst:pre-init-anon-class">Listing 20.5</a> shows another attempt to create
an instance of <span class="code">RationalTrait</span>.
As you see from this example, the initialization section comes before
the mention of the supertrait <span class="code">RationalTrait</span>. Both are separated
by<!-- --> a <span class="code">with</span>.</p>

<p><a name="lst:pre-init-anon-class"></a></p>

<pre>
  &nbsp;&nbsp;scala&gt;&nbsp;<span class="vem">new</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;<span class="literal">2</span>&nbsp;*&nbsp;x&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="vem">with</span>&nbsp;<span class="typename">RationalTrait</span>
  <span class="output">&nbsp;&nbsp;res15:&nbsp;java.lang.Object&nbsp;with&nbsp;RationalTrait&nbsp;=&nbsp;1/2</span>
</pre><!-- -->


<h5>Listing 20.5 - Pre-initialized fields in an anonymous class expression.</h5>


<p><a name="lst:pre-init-fields-object"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">object</span>&nbsp;twoThirds&nbsp;<span class="vem">extends</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;<span class="literal">2</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;<span class="literal">3</span>
  &nbsp;&nbsp;}&nbsp;<span class="vem">with</span>&nbsp;<span class="typename">RationalTrait</span>
</pre><!-- -->


<h5>Listing 20.6 - Pre-initialized fields in an object definition.</h5>


<p>Pre-initialized fields are not restricted to anonymous classes; they
can also be used in objects or named subclasses. Two
examples are shown in <a href="abstract-members.html#lst:pre-init-fields-object">Listings 20.6</a>
<a href="abstract-members.html#lst:pre-init-fields-class">and 20.7</a>.
As you can see from these examples, the pre-initialization section
comes in each case after the <span class="code">extends</span> keyword of the defined object or
class.  Class <span class="code">RationalClass</span>, shown in <a href="abstract-members.html#lst:pre-init-fields-class">Listing 20.7</a>, exemplifies a general schema of how class
parameters can be made available for the initialization of a
supertrait.</p>

<p>Because pre-initialized fields are initialized before the superclass
constructor is called, their initializers cannot refer to the object
that's being constructed. Consequently, if such an initializer refers
to <span class="code">this</span>, the reference goes to the object containing the class or
object that's being constructed, not the constructed object itself.
Here's an example:<a id="i988779894-2"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;<span class="literal">1</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;<span class="vem">this</span>.numerArg&nbsp;*&nbsp;<span class="literal">2</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="vem">with</span>&nbsp;<span class="typename">RationalTrait</span>
  <span class="output">&lt;console&gt;:8:&nbsp;error:&nbsp;value&nbsp;numerArg&nbsp;is&nbsp;not&nbsp;a</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member&nbsp;of&nbsp;object&nbsp;$iw</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;denomArg&nbsp;=&nbsp;this.numerArg&nbsp;*&nbsp;2</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<p><a name="lst:pre-init-fields-class"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">RationalClass</span>(n:&nbsp;<span class="typename">Int</span>,&nbsp;d:&nbsp;<span class="typename">Int</span>)&nbsp;<span class="vem">extends</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;d
  &nbsp;&nbsp;}&nbsp;<span class="vem">with</span>&nbsp;<span class="typename">RationalTrait</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">RationalClass</span>)&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">RationalClass</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numer&nbsp;*&nbsp;that.denom&nbsp;+&nbsp;that.numer&nbsp;*&nbsp;denom,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;denom&nbsp;*&nbsp;that.denom
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.7 - Pre-initialized fields in a class definition.</h5>


<p>The example did not compile because the reference <span class="code">this.numerArg</span> was
looking for a <span class="code">numerArg</span> field in the object containing the <span class="code">new</span>
(which in this case was the synthetic object named <span class="code">$iw</span>, into which
the interpreter puts user input lines). Once more, pre-initialized fields 
behave in this respect like class constructor arguments.</p>

<h4>Lazy <span class="code">val</span>s</h4>


<p>You can use pre-initialized fields to simulate precisely the
initialization behavior of class constructor arguments. Sometimes,
however, you might prefer to let the system itself sort out how things
should be initialized. This can be achieved by making your <span class="code">val</span>
definitions <em>lazy</em>. If you prefix a <span class="code">val</span> definition with a <span class="code">lazy</span><a id="i1386009102-1"></a>
modifier, the initializing expression on the right-hand side will only
be evaluated the first time the <span class="code">val</span> is used.</p>

<p>For an example, define an object <span class="code">Demo</span> with a <span class="code">val</span> as follows:
<pre>
  scala&gt;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Demo</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;{&nbsp;println(<span class="quotedstring">"initializing&nbsp;x"</span>);&nbsp;<span class="quotedstring">"done"</span>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <span class="output">defined&nbsp;module&nbsp;Demo</span>
</pre><!-- -->
Now, first refer to <span class="code">Demo</span>, then to <span class="code">Demo.x</span>:
<pre>
  scala&gt;&nbsp;<span class="typename">Demo</span>
  <span class="output">initializing&nbsp;x</span>
  <span class="output">res19:&nbsp;Demo.type&nbsp;=&nbsp;Demo$@97d1ff</span>
  <br />  scala&gt;&nbsp;Demo.x
  <span class="output">res20:&nbsp;java.lang.String&nbsp;=&nbsp;done</span>
</pre><!-- -->
As you can see, the moment you use <span class="code">Demo</span>, its <span class="code">x</span> field becomes
initialized. 
The initialization of <span class="code">x</span> forms part of the initialization of <span class="code">Demo</span>.
The situation changes, however, if you define the <span class="code">x</span> field to be <span class="code">lazy</span>:
<pre>
  scala&gt;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Demo</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lazy&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;{&nbsp;println(<span class="quotedstring">"initializing&nbsp;x"</span>);&nbsp;<span class="quotedstring">"done"</span>&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <span class="output">defined&nbsp;module&nbsp;Demo</span>
  <br />  scala&gt;&nbsp;<span class="typename">Demo</span>
  <span class="output">res21:&nbsp;Demo.type&nbsp;=&nbsp;Demo$@d81341</span>
  <br />  scala&gt;&nbsp;Demo.x
  <span class="output">initializing&nbsp;x</span>
  <span class="output">res22:&nbsp;java.lang.String&nbsp;=&nbsp;done</span>
</pre><!-- -->
Now, initializing <span class="code">Demo</span> does not involve initializing <span class="code">x</span>. The initialization
of <span class="code">x</span> will be deferred until the first time <span class="code">x</span> is used.</p>

<p><a name="lst:init-trait-lazy-vals"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">trait</span>&nbsp;<span class="typename">LazyRationalTrait</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg:&nbsp;<span class="typename">Int</span>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg:&nbsp;<span class="typename">Int</span>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;lazy&nbsp;<span class="vem">val</span>&nbsp;numer&nbsp;=&nbsp;numerArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;lazy&nbsp;<span class="vem">val</span>&nbsp;denom&nbsp;=&nbsp;denomArg&nbsp;/&nbsp;g
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;numer&nbsp;+<span class="quotedstring">"/"</span>+&nbsp;denom
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;lazy&nbsp;<span class="vem">val</span>&nbsp;g&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require(denomArg&nbsp;!=&nbsp;<span class="literal">0</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd(numerArg,&nbsp;denomArg)
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;gcd(a:&nbsp;<span class="typename">Int</span>,&nbsp;b:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(b&nbsp;==&nbsp;<span class="literal">0</span>)&nbsp;a&nbsp;<span class="vem">else</span>&nbsp;gcd(b,&nbsp;a&nbsp;%&nbsp;b)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.8 - Initializing a trait with lazy <span class="code">val</span>s.</h5>


<p>This is similar to the situation where <span class="code">x</span> is defined as a
parameterless method, using a <span class="code">def</span>. However, unlike a <span class="code">def</span> a lazy
<span class="code">val</span> is never evaluated more than
once<a id="i-861970308-1"></a><a id="i3314548-1"></a>. In fact, after the first
evaluation of a lazy <span class="code">val</span> the result of the evaluation is stored, to
be reused when the same <span class="code">val</span> is used subsequently.</p>

<p>Looking at this example, it seems that objects like <span class="code">Demo</span> themselves
behave like lazy <span class="code">val</span>s, in that they are also initialized on demand,
the first time they are used. This is correct. In fact an object
definition can be seen as a shorthand for the definition of a lazy
<span class="code">val</span> with an anonymous class that describes the object's contents.</p>

<p>Using lazy <span class="code">val</span>s, you could reformulate <span class="code">RationalTrait</span> as shown in <a href="abstract-members.html#lst:init-trait-lazy-vals">Listing 20.8</a>.
In the new trait definition, all concrete fields are defined <span class="code">lazy</span>.
Another change with respect to the previous definition of <span class="code">RationalTrait</span>, shown
in <a href="abstract-members.html#lst:rational-trait">Listing 20.4</a>,
is that the <span class="code">require</span> clause was moved from the body of the trait to the
initializer of the private field, <span class="code">g</span>, which computes the greatest
common divisor of <span class="code">numerArg</span> and <span class="code">denomArg</span>.
With these changes, there's nothing that remains to be done when  
<span class="code">LazyRationalTrait</span> is initialized; all initialization code is now
part of the right-hand side of a lazy <span class="code">val</span>. Therefore, it is
safe to initialize the abstract fields of <span class="code">LazyRationalTrait</span> after
the class is defined. Here's an example:
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;x&nbsp;=&nbsp;<span class="literal">2</span>
  <span class="output">x:&nbsp;Int&nbsp;=&nbsp;2</span>
  <br />  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">LazyRationalTrait</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;numerArg&nbsp;=&nbsp;<span class="literal">1</span>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;denomArg&nbsp;=&nbsp;<span class="literal">2</span>&nbsp;*&nbsp;x
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <span class="output">res1:&nbsp;java.lang.Object&nbsp;with&nbsp;LazyRationalTrait&nbsp;=&nbsp;1/2</span>
</pre><!-- -->
No pre-initialization is needed.
It's instructive to trace the sequence of initializations that lead to
the string <span class="code">1/2</span> to be printed in the code above:</p>

<ol>
<li>
First, a fresh instance of <span class="code">LazyRationalTrait</span> gets created, and 
the initialization code of <span class="code">LazyRationalTrait</span> is run. 
This initialization code is empty&mdash;none of the fields of <span class="code">LazyRationalTrait</span> is as yet initialized.
</li>
<li>
Next, the primary constructor of the anonymous subclass defined by the
<span class="code">new</span> expression is executed.  This involves the initialization of
<span class="code">numerArg</span> with <span class="code">2</span> and <span class="code">denomArg</span> with <span class="code">4</span>.
</li>
<li>
Next, the <span class="code">toString</span> method is invoked on the constructed object by the
interpreter, so that the resulting value can be printed.
</li>
<li>
Next, the <span class="code">numer</span> field is accessed for the first time by the 
<span class="code">toString</span> method in trait <span class="code">LazyRationalTrait</span>, so its initializer is
evaluated.
</li>
<li>
The initializer of <span class="code">numer</span> accesses the private field, <span class="code">g</span>, 
so <span class="code">g</span> is evaluated next. This evaluation accesses <span class="code">numerArg</span> and <span class="code">denomArg</span>, 
which were defined in Step 2.
</li>
<li>
Next, the <span class="code">toString</span> method accesses the value of <span class="code">denom</span>, which causes
<span class="code">denom</span>'s evaluation. The evaluation of <span class="code">denom</span> accesses the values of <span class="code">denomArg</span> and <span class="code">g</span>.
The initializer of the <span class="code">g</span> field is not re-evaluated, because it was already evaluated
in Step 5.
</li>
<li>
Finally, the result string <span class="code">"1/2"</span> is constructed and printed.
</li></ol> 
Note that the definition of <span class="code">g</span> comes textually after the definitions of
<span class="code">numer</span> and <span class="code">denom</span> in class <span class="code">LazyRationalTrait</span>. Nevertheless,
because all three values are lazy, <span class="code">g</span> gets initialized before the
initialization of <span class="code">numer</span> and <span class="code">denom</span> is completed. This shows an
important property of lazy <span class="code">val</span>s: the textual order of their
definitions does not matter, because values get initialized on
demand. Therefore, lazy vals can free you as a programmer from having
to think hard how to arrange <span class="code">val</span> definitions to ensure that everything is
defined when it is needed.


<p>However, this advantage holds only as long as the initialization of
lazy <span class="code">val</span>s neither produces side effects nor depends on them.  In
the presence of side effects, initialization order starts to
matter. And then it can be quite difficult to trace in what order
initialization code is run, as the previous example has
demonstrated. So lazy <span class="code">val</span>s are an ideal complement to functional
objects, where the order of initializations does not matter, as long
as everything gets initialized eventually<a id="i-1860042908-1"></a>. They are less well suited
for code that's predominantly imperative.</p>

<div class="aside">
<h3>Lazy functional languages</h3>


<p>Scala is by no means the first language to have exploited the perfect
match of lazy definitions and functional code. In fact, there is a
category of "lazy functional programming languages" in which <span style="font-style:italic">
every</span> value and parameter is initialized lazily<a id="i-748662080-1"></a>. The best known
member of this class of languages is Haskell
<a href="bibliography.html#haskell98">haskell98</a><a id="i-156161824-1"></a>.</p>

</div>


<h3><a name="20.6"></a>20.6 Abstract <span class="code">type</span>s <span style="font-size: .5em">[<a href="abstract-members.html#20.6">link</a>]</span></h3>


<p><a name="sec:abstract-types"></a></p>

<p>In the beginning of this chapter, you saw, "<span class="code">type</span>&nbsp;<span class="code">T</span>", an abstract type
declaration<a id="i-332843517-1"></a><a id="i669006587-1"></a>.
The rest of this chapter discusses what such an abstract type
declaration means and what it's good for.
Like all other abstract declarations, an abstract type declaration 
is a placeholder for something that will
be defined concretely in subclasses. In this case, it is a type that
will be defined further down the class hierarchy. So <span class="code">T</span> above refers
to a type that is at yet unknown at the point where it is declared. 
Different subclasses can provide different realizations of <span class="code">T</span>.</p>

<p>Here is a well-known example where abstract types show up
naturally. Suppose you are given the task of modeling the eating habits of
animals. You might start with a class <span class="code">Food</span> and a class <span class="code">Animal</span>
with an <span class="code">eat</span> method:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Food</span>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Animal</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;eat(food:&nbsp;<span class="typename">Food</span>)
  }
</pre><!-- -->
You might then attempt to specialize these two classes to a class of <span class="code">Cow</span>s that eat
<span class="code">Grass</span>:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Grass</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Food</span>
  <span class="vem">class</span>&nbsp;<span class="typename">Cow</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Animal</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;eat(food:&nbsp;<span class="typename">Grass</span>)&nbsp;{}&nbsp;<span class="comment">//&nbsp;This&nbsp;won't&nbsp;compile</span>
  }
</pre><!-- -->
However, if you tried to compile the new classes, you'd get the following compilation errors:<a id="i-1458364982-1"></a><a id="i934798591-2"></a></p>

<pre>
  <span class="output">BuggyAnimals.scala:7:&nbsp;error:&nbsp;class&nbsp;Cow&nbsp;needs&nbsp;to&nbsp;be</span>
  <span class="output">abstract,&nbsp;since&nbsp;method&nbsp;eat&nbsp;in&nbsp;class&nbsp;Animal&nbsp;of&nbsp;type</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Food)Unit&nbsp;is&nbsp;not&nbsp;defined</span>
  <span class="output">class&nbsp;Cow&nbsp;extends&nbsp;Animal&nbsp;{</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
  <span class="output">BuggyAnimals.scala:8:&nbsp;error:&nbsp;method&nbsp;eat&nbsp;overrides&nbsp;nothing</span>
  <span class="output">&nbsp;&nbsp;override&nbsp;def&nbsp;eat(food:&nbsp;Grass)&nbsp;{}</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- -->


<p>What happened is that the <span class="code">eat</span> method in class <span class="code">Cow</span> does not override
the <span class="code">eat</span> method in class <span class="code">Animal</span>, because its parameter type is different&mdash;it's
<span class="code">Grass</span> in class <span class="code">Cow</span> vs. <span class="code">Food</span> in class <span class="code">Animal</span>.</p>

<p>Some people have argued that the type system is unnecessarily strict
in refusing these classes.  They have said that it should be OK to
specialize a parameter of a method in a subclass. However, if
the classes were allowed as written, you could get yourself in unsafe
situations very quickly. For instance, the following script would pass the type checker:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Food</span>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Animal</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;eat(food:&nbsp;<span class="typename">Food</span>)
  }
  <span class="vem">class</span>&nbsp;<span class="typename">Grass</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Food</span>
  <span class="vem">class</span>&nbsp;<span class="typename">Cow</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Animal</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;eat(food:&nbsp;<span class="typename">Grass</span>)&nbsp;{}&nbsp;<span class="comment">//&nbsp;This&nbsp;won't&nbsp;compile,</span>
  }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;but&nbsp;if&nbsp;it&nbsp;did,...</span>
  <span class="vem">class</span>&nbsp;<span class="typename">Fish</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Food</span>
  <span class="vem">val</span>&nbsp;bessy:&nbsp;<span class="typename">Animal</span>&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Cow</span>
  bessy&nbsp;eat&nbsp;(<span class="vem">new</span>&nbsp;<span class="typename">Fish</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...you&nbsp;could&nbsp;feed&nbsp;fish&nbsp;to&nbsp;cows.</span>
</pre><!-- -->
The program would compile if the restriction were eased, because <span class="code">Cow</span>s are <span class="code">Animal</span>s and <span class="code">Animal</span>s 
do have an <span class="code">eat</span> method that accepts any kind of <span class="code">Food</span>, including <span class="code">Fish</span>.
But surely it would do a cow no good to eat a fish!</p>

<p>What you need to do instead is apply some more precise modeling. <span class="code">Animal</span>s do eat <span class="code">Food</span>, but what kind of <span class="code">Food</span> each <span class="code">Animal</span> eats depends on the <span class="code">Animal</span>. This can be neatly expressed
with an abstract type, as shown in <a href="abstract-members.html#lst:suitablefood-abstract-type">Listing 20.9</a>:</p>

<p><a name="lst:suitablefood-abstract-type"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Food</span>
  &nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Animal</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">SuitableFood</span>&nbsp;&lt;:&nbsp;<span class="typename">Food</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;eat(food:&nbsp;<span class="typename">SuitableFood</span>)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.9 - Modeling suitable food with an abstract type.</h5>


<p>With the new class definition, an <span class="code">Animal</span> can eat only food that's
suitable.  What food is suitable cannot be determined at the level of
the <span class="code">Animal</span> class. That's why <span class="code">SuitableFood</span> is modeled as an
abstract type. The type has an upper bound, <span class="code">Food</span>, which is expressed
by the "<span class="code">&lt;:</span>&nbsp;<span class="code">Food</span>" clause. This means that any concrete instantiation
of <span class="code">SuitableFood</span> (in a subclass of <span class="code">Animal</span>) must be a subclass of <span class="code">Food</span>. For example, you
would not be able to instantiate <span class="code">SuitableFood</span> with class
<span class="code">IOException</span>.</p>

<p><a name="lst:suitable-cow"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Grass</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Food</span>
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Cow</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Animal</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">SuitableFood</span>&nbsp;=&nbsp;<span class="typename">Grass</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;eat(food:&nbsp;<span class="typename">Grass</span>)&nbsp;{}
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.10 - Implementing an abstract type in a subclass.</h5>


<p>With <span class="code">Animal</span> defined, you can now progress to cows, as shown in <a href="abstract-members.html#lst:suitable-cow">Listing 20.10</a>.
Class <span class="code">Cow</span> fixes its <span class="code">SuitableFood</span> to be <span class="code">Grass</span> and also defines
a concrete <span class="code">eat</span> method for this kind of food. These new class 
definitions compile without errors. If you tried to run 
the "cows-that-eat-fish" counterexample with the new class definitions,
you would get the following compiler error:<a id="i-677980410-4"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Fish</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Food</span>
  <span class="output">defined&nbsp;class&nbsp;Fish</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;bessy:&nbsp;<span class="typename">Animal</span>&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Cow</span>
  <span class="output">bessy:&nbsp;Animal&nbsp;=&nbsp;Cow@674bf6</span>
  <br />  scala&gt;&nbsp;bessy&nbsp;eat&nbsp;(<span class="vem">new</span>&nbsp;<span class="typename">Fish</span>)
  <span class="output">&lt;console&gt;:10:&nbsp;error:&nbsp;type&nbsp;mismatch;</span>
  <span class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Fish</span>
  <span class="output">&nbsp;required:&nbsp;bessy.SuitableFood</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bessy&nbsp;eat&nbsp;(new&nbsp;Fish)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<h3><a name="20.7"></a>20.7 Path-dependent types <span style="font-size: .5em">[<a href="abstract-members.html#20.7">link</a>]</span></h3>


<p><a name="sec:path-dependent-types"></a></p>

<p>Have a look at the last error message: What's interesting about it is the<a id="i419165808-1"></a><a id="i-2033041288-1"></a> 
type required by the <span class="code">eat</span> method: <span class="code">bessy.SuitableFood</span>. This type
consists of an object reference, <span class="code">bessy</span>, which is followed by a type
field, <span class="code">SuitableFood</span>, of the object. So this shows that objects in
Scala can have types as members. The meaning of <span class="code">bessy.SuitableFood</span> is "the type
<span class="code">SuitableFood</span> that is a member of the object referenced from <span class="code">bessy</span>," or
alternatively, the type of food that's suitable for <span class="code">bessy</span>. A type like
<span class="code">bessy.SuitableFood</span> is called a <span style="font-style:italic">path-dependent
type</span>.
The word "path" here means a reference to an object. 
It could be a single name, such as <span class="code">bessy</span>, or a longer access path, such as <span class="code">farm.barn.bessy.SuitableFood</span>,
where each of <span class="code">farm</span>, <span class="code">barn</span>, and <span class="code">bessy</span> are variables (or singleton object names) that refer to objects.</p>

<p>As the term "path-dependent type" says, the type depends on the
path: in general, different paths give rise to different types. For
instance, say you defined classes <span class="code">DogFood</span> and <span class="code">Dog</span>, like this:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">DogFood</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Food</span>
  <span class="vem">class</span>&nbsp;<span class="typename">Dog</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Animal</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">SuitableFood</span>&nbsp;=&nbsp;<span class="typename">DogFood</span>
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;eat(food:&nbsp;<span class="typename">DogFood</span>)&nbsp;{}
  }
</pre><!-- -->
If you attempted to feed a dog with food fit for a cow, your code would not compile:<a id="i-677980410-5"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;bessy&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Cow</span>
  <span class="output">bessy:&nbsp;Cow&nbsp;=&nbsp;Cow@10cd6d</span>
  <br />  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;lassie&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Dog</span>
  <span class="output">bootsie:&nbsp;Dog&nbsp;=&nbsp;Dog@d11fa6</span>
  <br />  scala&gt;&nbsp;lassie&nbsp;eat&nbsp;(<span class="vem">new</span>&nbsp;<span class="typename">bessy.SuitableFood</span>)
  <span class="output">&lt;console&gt;:13:&nbsp;error:&nbsp;type&nbsp;mismatch;</span>
  <span class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;Grass</span>
  <span class="output">&nbsp;required:&nbsp;DogFood</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lassie&nbsp;eat&nbsp;(new&nbsp;bessy.SuitableFood)</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<p>The problem here is that the type of the <span class="code">SuitableFood</span> object passed to the <span class="code">eat</span> method, <span class="code">bessy.SuitableFood</span>, is 
incompatible with the parameter type of <span class="code">eat</span>, <span class="code">lassie.SuitableFood</span>.
The case would be different for
two <span class="code">Dog</span>s however. Because <span class="code">Dog</span>'s <span class="code">SuitableFood</span> type is defined to be
an alias for class <span class="code">DogFood</span>, the <span class="code">SuitableFood</span> types of two <span class="code">Dog</span>s are
in fact the same. As a result, the <span class="code">Dog</span> instance named <span class="code">lassie</span> could actually eat the
suitable food of a different <span class="code">Dog</span> instance (which we'll name <span class="code">bootsie</span>):
<pre>
  scala&gt;&nbsp;<span class="vem">val</span>&nbsp;bootsie&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Dog</span>
  <span class="output">bootsie:&nbsp;Dog&nbsp;=&nbsp;Dog@54ca71</span>
  <br />  scala&gt;&nbsp;lassie&nbsp;eat&nbsp;(<span class="vem">new</span>&nbsp;<span class="typename">bootsie.SuitableFood</span>)
</pre><!-- --></p>

<p>A path-dependent type resembles the syntax for an inner class type in
Java<a id="i1051202392-1"></a>, but there is a crucial difference: a path-dependent type
names an outer <span style="font-style:italic">object</span>, whereas an inner class
type names an
outer <span style="font-style:italic">class</span>. Java-style inner class types can also be
expressed in Scala, but they are written differently. 
Consider these two classes, <span class="code">Outer</span> and <span class="code">Inner</span>:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">Outer</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Inner</span>
  }
</pre><!-- -->
In Scala, the inner class is addressed using the expression <span class="code">Outer#Inner</span> 
instead of Java's <span class="code">Outer.Inner</span>. The `<span class="code">.</span>' syntax is reserved for objects.<a id="i-1229370884-1"></a>
For example, imagine you instantiate two objects of type <span class="code">Outer</span>, like this:
<pre>
  <span class="vem">val</span>&nbsp;o1&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Outer</span>
  <span class="vem">val</span>&nbsp;o2&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Outer</span>
</pre><!-- -->
Here <span class="code">o1.Inner</span> and <span class="code">o2.Inner</span> are two path-dependent types<a id="i1286205047-1"></a><a id="i-1290990775-1"></a>
(and they are different types). Both of these types conform to (are subtypes of) the
more general type <span class="code">Outer#Inner</span>, which represents the <span class="code">Inner</span> class 
with an <em>arbitrary</em> outer object of type <span class="code">Outer</span>. By contrast, type <span class="code">o1.Inner</span> 
refers to the <span class="code">Inner</span> class with a <em>specific</em> outer object (the one referenced from <span class="code">o1</span>).
Likewise, type <span class="code">o2.Inner</span> refers to the <span class="code">Inner</span> class with a different, specific outer object (the one referenced from <span class="code">o2</span>).</p>

<p>In Scala, as in Java, inner class instances hold a reference to an enclosing outer class instance. This allows an
inner class, for example, to access members of its outer class. Thus you can't instantiate an inner class without
in some way specifying an outer class instance. One way to do this is to instantiate the inner class inside the body of the
outer class. In this case, the current outer class instance (referenced from <span class="code">this</span>) will be used. Another way is to use
a path-dependent type. For example, because the type, <span class="code">o1.Inner</span>, names a specific outer object, you can instantiate it:
<pre>
  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">o1.Inner</span>
  <span class="output">res1:&nbsp;o1.Inner&nbsp;=&nbsp;Outer$Inner@13727f</span>
</pre><!-- -->
The resulting inner object will contain a reference to its outer object, the object referenced from <span class="code">o1</span>. By contrast, because
the type <span class="code">Outer#Inner</span> does not name any specific instance of <span class="code">Outer</span>, you can't create an instance of it:<a id="i-480808313-1"></a>
<pre>
  scala&gt;&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Outer</span>#<span class="typename">Inner</span>
  <span class="output">&lt;console&gt;:6:&nbsp;error:&nbsp;Outer&nbsp;is&nbsp;not&nbsp;a&nbsp;legal&nbsp;prefix&nbsp;for</span>
  <span class="output">&nbsp;&nbsp;a&nbsp;constructor</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Outer#Inner</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<h3><a name="20.8"></a>20.8 Enumerations <span style="font-size: .5em">[<a href="abstract-members.html#20.8">link</a>]</span></h3>


<p><a name="sec:enums"></a></p>

<p>An interesting application of path-dependent types is found in Scala's
support for enumerations. Some other languages, including Java and C#,
have enumerations as a built-in language construct to define new types. 
Scala does not need special syntax for
enumerations<a id="i-469710704-1"></a><a id="i1297750808-1"></a>. Instead, there's a class
in its standard library,
<span class="code">scala.Enumeration</span><a id="i-1102794201-1"></a>. To create a new
enumeration, you define an object that extends this class, as in the
following example, which defines a new enumeration of <span class="code">Color</span>s:
<pre>
  <span class="vem">object</span>&nbsp;<span class="typename">Color</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Enumeration</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Red</span>&nbsp;=&nbsp;<span class="typename">Value</span>
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Green</span>&nbsp;=&nbsp;<span class="typename">Value</span>
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Blue</span>&nbsp;=&nbsp;<span class="typename">Value</span>
  }
</pre><!-- -->
Scala lets you also shorten several successive <span class="code">val</span> or <span class="code">var</span> 
definitions with the same right-hand 
side. Equivalently to the above you could write:
<pre>
  <span class="vem">object</span>&nbsp;<span class="typename">Color</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Enumeration</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Red</span>,&nbsp;<span class="typename">Green</span>,&nbsp;<span class="typename">Blue</span>&nbsp;=&nbsp;<span class="typename">Value</span>
  }
</pre><!-- -->
This object definition provides three values:
<span class="code">Color.Red</span>, <span class="code">Color.Green</span>, and <span class="code">Color.Blue</span>. You could also import
everything in <span class="code">Color</span> with:
<pre>
  <span class="vem">import</span>&nbsp;Color._
</pre><!-- -->
and then just use <span class="code">Red</span>, <span class="code">Green</span>, and <span class="code">Blue</span>. But what is the type
of these values? <span class="code">Enumeration</span> defines 
an inner class named <span class="code">Value</span>, and the same-named 
parameterless <span class="code">Value</span> method returns a 
fresh instance of that class.<a id="i-1232708119-1"></a>
This means that a value such as <span class="code">Color.Red</span> is of type
<span class="code">Color.Value</span>.  <span class="code">Color.Value</span> is the type of all enumeration values
defined in object <span class="code">Color</span>. It's a path-dependent type, with 
<span class="code">Color</span> being the path and <span class="code">Value</span> being the dependent type. 
What's significant about this is that it is a completely new type, different 
from all other types. In particular, if you would define another enumeration, such as:
<pre>
  <span class="vem">object</span>&nbsp;<span class="typename">Direction</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Enumeration</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">North</span>,&nbsp;<span class="typename">East</span>,&nbsp;<span class="typename">South</span>,&nbsp;<span class="typename">West</span>&nbsp;=&nbsp;<span class="typename">Value</span>
  }
</pre><!-- -->
then <span class="code">Direction.Value</span> would be different from <span class="code">Color.Value</span> because the path
parts of the two types differ.</p>

<p>Scala's <span class="code">Enumeration</span> class also offers many other features found in the enumeration designs of other languages.
You can associate names with enumeration values by using a different overloaded
variant of the <span class="code">Value</span> method:
<pre>
  <span class="vem">object</span>&nbsp;<span class="typename">Direction</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Enumeration</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">North</span>&nbsp;=&nbsp;<span class="typename">Value</span>(<span class="quotedstring">"North"</span>)
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">East</span>&nbsp;=&nbsp;<span class="typename">Value</span>(<span class="quotedstring">"East"</span>)
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">South</span>&nbsp;=&nbsp;<span class="typename">Value</span>(<span class="quotedstring">"South"</span>)
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">West</span>&nbsp;=&nbsp;<span class="typename">Value</span>(<span class="quotedstring">"West"</span>)
  }
</pre><!-- -->
You can step through all values of an enumeration with <span class="code">foreach</span>, or 
use <span class="code">for</span> expressions with <span class="code">map</span>, <span class="code">flatMap</span> and <span class="code">filter</span>:
<pre>
  scala&gt;&nbsp;<span class="vem">for</span>&nbsp;(d&nbsp;&lt;-&nbsp;<span class="typename">Direction</span>)&nbsp;print(d&nbsp;+<span class="quotedstring">"&nbsp;"</span>)
  <span class="output">North&nbsp;East&nbsp;South&nbsp;West&nbsp;</span>
</pre><!-- -->
Values of an enumeration are numbered from <span class="code">0</span>, and you can find out the 
number of an enumeration value by its <span class="code">id</span> method:
<pre>
  scala&gt;&nbsp;Direction.East.id
  <span class="output">res5:&nbsp;Int&nbsp;=&nbsp;1</span>
</pre><!-- -->
It's also possible to go the other way, from a non-negative 
integer number to the value that has this number as <span class="code">id</span> in an enumeration:
<pre>
  scala&gt;&nbsp;<span class="typename">Direction</span>(<span class="literal">1</span>)
  <span class="output">res6:&nbsp;Direction.Value&nbsp;=&nbsp;East</span>
</pre><!-- -->
This should be enough to get you started with enumerations. 
You can find more information
in the Scaladoc comments of class <span class="code">scala.Enumeration</span>.</p>

<h3><a name="20.9"></a>20.9 Case study: Currencies <span style="font-size: .5em">[<a href="abstract-members.html#20.9">link</a>]</span></h3>


<p><a name="sec:currencies"></a></p>

<p>The rest of this chapter presents a case study that explains how
abstract types can be used in Scala. The task is to design a class
<span class="code">Currency</span>. A typical instance of <span class="code">Currency</span> would
represent an amount of money in dollars, euros, yen, or some
other currency.  It should be
possible to do some arithmetic on currencies. For instance, you should
be able to add two amounts of the same currency. Or you should be able
to multiply a currency amount by a factor representing an interest rate.</p>

<p>These thoughts lead to the following first design for a currency class:
<pre>
  <span class="comment">//&nbsp;A&nbsp;first&nbsp;(faulty)&nbsp;design&nbsp;of&nbsp;the&nbsp;Currency&nbsp;class</span>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Currency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount:&nbsp;<span class="typename">Long</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation:&nbsp;<span class="typename">String</span>&nbsp;
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;amount&nbsp;+<span class="quotedstring">"&nbsp;"</span>+&nbsp;designation
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">Currency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;*&nbsp;(x:&nbsp;<span class="typename">Double</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;...
  }
</pre><!-- -->
The <span class="code">amount</span> of a currency is the number of currency units it represents.
This is a field of type <span class="code">Long</span> so that very large amounts of money such as the 
market capitalization of Google or Microsoft can be represented.
It's left abstract here, waiting to be defined when a subclass talks about concrete amounts of money. 
The <span class="code">designation</span> of a currency is a string that identifies it. 
The <span class="code">toString</span> method of class <span class="code">Currency</span> indicates an amount and a designation. 
It would yield results such as:
<pre>
  79&nbsp;USD
  11000&nbsp;Yen
  99&nbsp;Euro&nbsp;
</pre><!-- -->
Finally, there are methods <span class="code">+</span>, for adding currencies, and 
<span class="code">*</span>, for multiplying a currency with a floating-point
number. You can create a concrete currency value by supplying concrete <span class="code">amount</span> and <span class="code">designation</span> values, like this:
<pre>
  <span class="vem">new</span>&nbsp;<span class="typename">Currency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount&nbsp;=&nbsp;<span class="literal">79L</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"USD"</span>
  }
</pre><!-- -->
This design would be OK if all we wanted to model was a single
currency such as only dollars or only euros. But it fails once we need
to deal with several currencies. Assume you model dollars and euros
as two subclasses of class currency:
<pre>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Dollar</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Currency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"USD"</span>
  }
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Euro</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">Currency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"Euro"</span>
  }
</pre><!-- -->
At first glance this looks reasonable. But it would let you add 
dollars to euros. The result of such an addition would be of type <span class="code">Currency</span>.
But it would be a funny currency that was made up of a mix of euros and dollars.
What you want instead is a more specialized version of the <span class="code">+</span> method: 
when implemented in class <span class="code">Dollar</span>, it should take <span class="code">Dollar</span> arguments and yield a <span class="code">Dollar</span> result; when implemented in class <span class="code">Euro</span>, it should take
<span class="code">Euro</span> arguments and yield a <span class="code">Euro</span> result. So the type of the addition method
would change depending on which class you are in. Nonetheless, you would like to 
write the addition method just once, not each time a new currency is defined.</p>

<p>In Scala, there's a simple technique to deal with situations like
this: if something is not known at the point where a class is defined,
make it abstract in the class. This applies to both values and types.
In the case of currencies, the exact argument and result type of the
addition method are not known, so it is a good candidate for an
abstract type.  This would lead to the following sketch of class <span class="code">AbstractCurrency</span>:
<pre>
  <span class="comment">//&nbsp;A&nbsp;second&nbsp;(still&nbsp;imperfect)&nbsp;design&nbsp;of&nbsp;the&nbsp;Currency&nbsp;class</span>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;&lt;:&nbsp;<span class="typename">AbstractCurrency</span>
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount:&nbsp;<span class="typename">Long</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation:&nbsp;<span class="typename">String</span>&nbsp;
  &nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;amount&nbsp;+<span class="quotedstring">"&nbsp;"</span>+&nbsp;designation
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">Currency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;...
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;*&nbsp;(x:&nbsp;<span class="typename">Double</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;...
  }
</pre><!-- -->
The only differences from the previous situation are that the class is now
called <span class="code">AbstractCurrency</span>, and that it contains an abstract type
<span class="code">Currency</span>, which represents the real currency in question.  Each concrete
subclass of <span class="code">AbstractCurrency</span> would need to fix the <span class="code">Currency</span> type to refer
to the concrete subclass itself, thereby "tying the knot."</p>

<p>For instance, here is a new version of class <span class="code">Dollar</span>, which now extends class <span class="code">AbstractCurrency</span>:<!-- -->
<pre>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Dollar</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;<span class="typename">Dollar</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"USD"</span>
  }
</pre><!-- -->
This design is workable, but it is still not perfect. One problem is
hidden by the ellipses that indicate the missing method definitions of
 <span class="code">+</span> and <span class="code">*</span> in class <span class="code">AbstractCurrency</span>. In particular, how should 
addition be implemented in this class? It's easy enough to 
calculate the correct amount of the new currency as <span class="code">this.amount</span>&nbsp;<span class="code">+</span>&nbsp;<span class="code">that.amount</span>, 
but how would you convert the amount into a currency of the right type? You might try
something like:<a id="i-1457961297-1"></a>
<pre>
  <span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">Currency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Currency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount&nbsp;=&nbsp;<span class="vem">this</span>.amount&nbsp;+&nbsp;that.amount
  }
</pre><!-- -->
However, this would not compile:
<pre>
  <span class="output">error:&nbsp;class&nbsp;type&nbsp;required</span>
  <span class="output">&nbsp;&nbsp;def&nbsp;+&nbsp;(that:&nbsp;Currency):&nbsp;Currency&nbsp;=&nbsp;new&nbsp;Currency&nbsp;{</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<p>One of the restrictions of Scala's treatment of abstract types is that
you can neither create an instance of an abstract type, nor have an abstract type
as a supertype of another class.<a href="abstract-members.html#footnote20-1">[1]</a>
So the compiler would refuse the example code above that attempted to instantiate <span class="code">Currency</span>.</p>

<p>However, you can work around this restriction using a <span style="font-style:italic">factory
method</span>.  Instead of creating an instance of an abstract type
directly, declare an abstract method that does it. Then, wherever the abstract type
is fixed to be some concrete type, you also need to give a concrete implementation
of the factory method.<a id="i-1125093732-2"></a> For class <span class="code">AbstractCurrency</span>, this would look as follows:
<pre>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;&lt;:&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;<span class="comment">//&nbsp;abstract&nbsp;type</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;make(amount:&nbsp;<span class="typename">Long</span>):&nbsp;<span class="typename">Currency</span>&nbsp;&nbsp;<span class="comment">//&nbsp;factory&nbsp;method</span>
  &nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;rest&nbsp;of&nbsp;class</span>
  }
</pre><!-- -->
A design like this could be made to work, but it looks rather suspicious.
Why place the factory method <span style="font-style:italic">inside</span> class <span class="code">AbstractCurrency</span>?
This looks dubious, for at least two reasons. First,
if you have some amount of currency (say, one dollar), you also hold in your hand
the ability to make more of the same currency, using code such as:
<pre>
  myDollar.make(<span class="literal">100</span>)&nbsp;&nbsp;<span class="comment">//&nbsp;here&nbsp;are&nbsp;a&nbsp;hundred&nbsp;more!</span>
</pre><!-- -->
In the age of color copying this might be a tempting scenario, but
hopefully not one which you would be able to do for very long without being caught.
The second problem with this code is that you can make more <span class="code">Currency</span> objects
if you already have a reference to a <span class="code">Currency</span> object, 
but how do you get the first object
of a given <span class="code">Currency</span>? You'd need another creation method, which does essentially
the same job as <span class="code">make</span>. So you have a case of code duplication, which is a sure
sign of a code smell.</p>

<p>The solution, of course, is to move the abstract type and the factory method
outside class <span class="code">AbstractCurrency</span>. You need to create another class that contains
the <span class="code">AbstractCurrency</span> class, the <span class="code">Currency</span> type, and the <span class="code">make</span> factory method.
We'll call this a <span class="code">CurrencyZone</span>:
<pre>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">CurrencyZone</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;&lt;:&nbsp;<span class="typename">AbstractCurrency</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;make(x:&nbsp;<span class="typename">Long</span>):&nbsp;<span class="typename">Currency</span>
  &nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount:&nbsp;<span class="typename">Long</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation:&nbsp;<span class="typename">String</span>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;amount&nbsp;+<span class="quotedstring">"&nbsp;"</span>+&nbsp;designation
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">Currency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<span class="vem">this</span>.amount&nbsp;+&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;*&nbsp;(x:&nbsp;<span class="typename">Double</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<span class="vem">this</span>.amount&nbsp;*&nbsp;x).toLong)
  &nbsp;&nbsp;}
  }
</pre><!-- -->
An example of a concrete <span class="code">CurrencyZone</span> is the US. 
You could define this as follows:
<pre>
  <span class="vem">object</span>&nbsp;US&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">CurrencyZone</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Dollar</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"USD"</span>
  &nbsp;&nbsp;}
  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;<span class="typename">Dollar</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;make(x:&nbsp;<span class="typename">Long</span>)&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Dollar</span>&nbsp;{&nbsp;<span class="vem">val</span>&nbsp;amount&nbsp;=&nbsp;x&nbsp;}
  }
</pre><!-- -->
Here, <span class="code">US</span> is an object that extends <span class="code">CurrencyZone</span>. It defines a class
<span class="code">Dollar</span>, which is a subclass of <span class="code">AbstractCurrency</span>. So the type of
money in this zone is <span class="code">US.Dollar</span>. The <span class="code">US</span> object also fixes
the type <span class="code">Currency</span> to be an alias for <span class="code">Dollar</span>, and it gives an
implementation of the <span class="code">make</span> factory method to return a dollar amount.</p>

<p>This is a workable design. 
There are only a few refinements to be added.
The first refinement concerns subunits. So far, every currency was
measured in a single unit: dollars, euros, or yen. However, most
currencies have subunits: for instance, in the US, it's dollars and
cents. The most straightforward way to model cents is to have the
<span class="code">amount</span> field in <span class="code">US.Currency</span> represent cents instead of dollars.
To convert back to dollars, it's useful to introduce a field <span class="code">CurrencyUnit</span>
into class <span class="code">CurrencyZone</span>, which contains the amount of one
standard unit in that currency:
<pre>
  <span class="vem">class</span>&nbsp;<span class="typename">CurrencyZone</span>&nbsp;{&nbsp;
  &nbsp;&nbsp;...&nbsp;
  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">CurrencyUnit</span>:&nbsp;<span class="typename">Currency</span>&nbsp;
  }&nbsp;
</pre><!-- -->
The <span class="code">US</span> object could define the quantities <span class="code">Cent</span>, <span class="code">Dollar</span>, and <span class="code">CurrencyUnit</span>
as shown in <a href="abstract-members.html#lst:us-currency-zone">Listing 20.11</a>.
<a name="lst:us-currency-zone"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">object</span>&nbsp;US&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">CurrencyZone</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Dollar</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"USD"</span>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;<span class="typename">Dollar</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;make(cents:&nbsp;<span class="typename">Long</span>)&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Dollar</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount&nbsp;=&nbsp;cents
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Cent</span>&nbsp;=&nbsp;make(<span class="literal">1</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Dollar</span>&nbsp;=&nbsp;make(<span class="literal">100</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">CurrencyUnit</span>&nbsp;=&nbsp;<span class="typename">Dollar</span>
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.11 - The US currency zone.</h5>


<p>This definition is just like the previous definition of the <span class="code">US</span> object, except that
it adds three new fields. The field <span class="code">Cent</span> represents an amount of 1 <span class="code">US.Currency</span>.
It's an object analogous to a one-cent coin. The field <span class="code">Dollar</span>
represents an amount of 100 <span class="code">US.Currency</span>. So the <span class="code">US</span> object now defines the 
name <span class="code">Dollar</span> in two ways. The <span style="font-style:italic">type</span> <span class="code">Dollar</span> (defined by the abstract inner class named <span class="code">Dollar</span>) represents the generic name of the <span class="code">Currency</span> 
valid in the <span class="code">US</span> currency zone. By contrast, the <span style="font-style:italic">value</span> <span class="code">Dollar</span> (referenced from the <span class="code">val</span> field named <span class="code">Dollar</span>) represents
a single US dollar, analogous to a one-dollar bill. The third field definition of <span class="code">CurrencyUnit</span>
specifies that the standard currency unit in the <span class="code">US</span> zone is the <span class="code">Dollar</span> (<i>i.e.</i>, the value <span class="code">Dollar</span>, referenced from the field, not the type
<span class="code">Dollar</span>).</p>

<p>The <span class="code">toString</span> method in class <span class="code">Currency</span> also needs to be adapted to take 
subunits into account. For instance, the sum of ten dollars and twenty three cents should print as a decimal number: 10.23 USD.
To achieve this, you could implement <span class="code">Currency</span>'s 
<span class="code">toString</span> method as follows:
<pre>
  <span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;((amount.toDouble&nbsp;/&nbsp;CurrencyUnit.amount.toDouble)
  &nbsp;&nbsp;&nbsp;formatted&nbsp;(<span class="quotedstring">"%."</span>+&nbsp;decimals(CurrencyUnit.amount)&nbsp;+<span class="quotedstring">"f"</span>)
  &nbsp;&nbsp;&nbsp;+<span class="quotedstring">"&nbsp;"</span>+&nbsp;designation)
</pre><!-- -->
Here, <span class="code">formatted</span><a id="i-1143614518-1"></a>
is a method that Scala makes available
on several classes, including <span class="code">Double</span>.<a href="abstract-members.html#footnote20-2">[2]</a> 
The <span class="code">formatted</span> method returns<a id="i1886523229-1"></a><a id="i1659928775-1"></a>
the string that results from formatting the original string on which <span class="code">formatted</span> was invoked
according to a format string
passed as the <span class="code">formatted</span> method's right-hand operand.
The syntax of format strings passed to <span class="code">formatted</span> is the same as that of Java's <span class="code">String.format</span> method.
For instance, the format string <span class="code">%.2f</span> formats a number with two decimal digits.
The format string used in the <span class="code">toString</span> shown previously is assembled by calling the <span class="code">decimals</span> method on
<span class="code">CurrencyUnit.amount</span>. This method returns the number of decimal digits of a 
decimal power minus one. For instance, <span class="code">decimals(10)</span> is <span class="code">1</span>, <span class="code">decimals(100)</span> is <span class="code">2</span>, and so on. 
The <span class="code">decimals</span> method is implemented by a simple recursion:
<pre>
  <span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;decimals(n:&nbsp;<span class="typename">Long</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;<span class="vem">if</span>&nbsp;(n&nbsp;==&nbsp;<span class="literal">1</span>)&nbsp;<span class="literal">0</span>&nbsp;<span class="vem">else</span>&nbsp;<span class="literal">1</span>&nbsp;+&nbsp;decimals(n&nbsp;/&nbsp;<span class="literal">10</span>)
</pre><!-- -->
<a href="abstract-members.html#lst:europe-japan">Listing 20.12</a> shows some other currency zones:
<a name="lst:europe-japan"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Europe</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">CurrencyZone</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Euro</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"EUR"</span>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;<span class="typename">Euro</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;make(cents:&nbsp;<span class="typename">Long</span>)&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Euro</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount&nbsp;=&nbsp;cents
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Cent</span>&nbsp;=&nbsp;make(<span class="literal">1</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Euro</span>&nbsp;=&nbsp;make(<span class="literal">100</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">CurrencyUnit</span>&nbsp;=&nbsp;<span class="typename">Euro</span>
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Japan</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">CurrencyZone</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Yen</span>&nbsp;<span class="vem">extends</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation&nbsp;=&nbsp;<span class="quotedstring">"JPY"</span>
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;<span class="typename">Yen</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;make(yen:&nbsp;<span class="typename">Long</span>)&nbsp;=&nbsp;<span class="vem">new</span>&nbsp;<span class="typename">Yen</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount&nbsp;=&nbsp;yen
  &nbsp;&nbsp;&nbsp;&nbsp;}
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">Yen</span>&nbsp;=&nbsp;make(<span class="literal">1</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">CurrencyUnit</span>&nbsp;=&nbsp;<span class="typename">Yen</span>
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.12 - Currency zones for Europe and Japan.</h5>


<p>As another refinement you can add a currency conversion feature to the
model.  As a first step, you could write a <span class="code">Converter</span> object that contains
applicable exchange rates between currencies, as shown in <a href="abstract-members.html#lst:currency-converter">Listing 20.13</a>.
<a name="lst:currency-converter"></a></p>

<pre>
  &nbsp;&nbsp;<span class="vem">object</span>&nbsp;<span class="typename">Converter</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">var</span>&nbsp;exchangeRate&nbsp;=&nbsp;<span class="typename">Map</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"USD"</span>&nbsp;-&gt;&nbsp;<span class="typename">Map</span>(<span class="quotedstring">"USD"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.0</span>&nbsp;&nbsp;&nbsp;,&nbsp;<span class="quotedstring">"EUR"</span>&nbsp;-&gt;&nbsp;<span class="literal">0.7596</span>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"JPY"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.211</span>&nbsp;,&nbsp;<span class="quotedstring">"CHF"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.223</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"EUR"</span>&nbsp;-&gt;&nbsp;<span class="typename">Map</span>(<span class="quotedstring">"USD"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.316</span>&nbsp;,&nbsp;<span class="quotedstring">"EUR"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.0</span>&nbsp;&nbsp;&nbsp;,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"JPY"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.594</span>&nbsp;,&nbsp;<span class="quotedstring">"CHF"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.623</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"JPY"</span>&nbsp;-&gt;&nbsp;<span class="typename">Map</span>(<span class="quotedstring">"USD"</span>&nbsp;-&gt;&nbsp;<span class="literal">0.8257</span>,&nbsp;<span class="quotedstring">"EUR"</span>&nbsp;-&gt;&nbsp;<span class="literal">0.6272</span>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"JPY"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.0</span>&nbsp;&nbsp;&nbsp;,&nbsp;<span class="quotedstring">"CHF"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.018</span>),
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"CHF"</span>&nbsp;-&gt;&nbsp;<span class="typename">Map</span>(<span class="quotedstring">"USD"</span>&nbsp;-&gt;&nbsp;<span class="literal">0.8108</span>,&nbsp;<span class="quotedstring">"EUR"</span>&nbsp;-&gt;&nbsp;<span class="literal">0.6160</span>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"JPY"</span>&nbsp;-&gt;&nbsp;<span class="literal">0.982</span>&nbsp;,&nbsp;<span class="quotedstring">"CHF"</span>&nbsp;-&gt;&nbsp;<span class="literal">1.0</span>&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;}
</pre><!-- -->


<h5>Listing 20.13 - A converter object with an exchange rates map.</h5>


<p>Then, you could add
a conversion method, <span class="code">from</span>, to class <span class="code">Currency</span>, which converts from a given source
currency into the current <span class="code">Currency</span> object:
<pre>
  <span class="vem">def</span>&nbsp;from(other:&nbsp;<span class="typename">CurrencyZone</span>#<span class="typename">AbstractCurrency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;make(Math.round(
  &nbsp;&nbsp;&nbsp;&nbsp;other.amount.toDouble&nbsp;*&nbsp;Converter.exchangeRate
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(other.designation)(<span class="vem">this</span>.designation)))
</pre><!-- -->
The <span class="code">from</span> method takes an arbitrary currency as argument. 
This is expressed by its formal parameter type, <span class="code">CurrencyZone#AbstractCurrency</span>, which indicates that
the argument passed as <span class="code">other</span> must be an <span class="code">AbstractCurrency</span> type in some arbitrary and unknown <span class="code">CurrencyZone</span>.
It produces its result by multiplying the amount of the <span class="code">other</span> currency 
with the exchange rate between the other and the current currency.<a href="abstract-members.html#footnote20-3">[3]</a></p>

<p>The final version of the <span class="code">CurrencyZone</span> class is 
shown in <a href="abstract-members.html#lst:CurrencyZone">Listing 20.14</a>.</p>

<p><a name="lst:CurrencyZone"></a></p>

<pre>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">CurrencyZone</span>&nbsp;{
  <br />  &nbsp;&nbsp;<span class="vem">type</span>&nbsp;<span class="typename">Currency</span>&nbsp;&lt;:&nbsp;<span class="typename">AbstractCurrency</span>
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;make(x:&nbsp;<span class="typename">Long</span>):&nbsp;<span class="typename">Currency</span>
  <br />  &nbsp;&nbsp;<span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">AbstractCurrency</span>&nbsp;{
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">val</span>&nbsp;amount:&nbsp;<span class="typename">Long</span>
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;designation:&nbsp;<span class="typename">String</span>&nbsp;
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;+&nbsp;(that:&nbsp;<span class="typename">Currency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<span class="vem">this</span>.amount&nbsp;+&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;*&nbsp;(x:&nbsp;<span class="typename">Double</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<span class="vem">this</span>.amount&nbsp;*&nbsp;x).toLong)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;-&nbsp;(that:&nbsp;<span class="typename">Currency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(<span class="vem">this</span>.amount&nbsp;-&nbsp;that.amount)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;/&nbsp;(that:&nbsp;<span class="typename">Double</span>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make((<span class="vem">this</span>.amount&nbsp;/&nbsp;that).toLong)
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;/&nbsp;(that:&nbsp;<span class="typename">Currency</span>)&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">this</span>.amount.toDouble&nbsp;/&nbsp;that.amount
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">def</span>&nbsp;from(other:&nbsp;<span class="typename">CurrencyZone</span>#<span class="typename">AbstractCurrency</span>):&nbsp;<span class="typename">Currency</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make(Math.round(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.amount.toDouble&nbsp;*&nbsp;Converter.exchangeRate
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(other.designation)(<span class="vem">this</span>.designation)))
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">private</span>&nbsp;<span class="vem">def</span>&nbsp;decimals(n:&nbsp;<span class="typename">Long</span>):&nbsp;<span class="typename">Int</span>&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(n&nbsp;==&nbsp;<span class="literal">1</span>)&nbsp;<span class="literal">0</span>&nbsp;<span class="vem">else</span>&nbsp;<span class="literal">1</span>&nbsp;+&nbsp;decimals(n&nbsp;/&nbsp;<span class="literal">10</span>)
  <br />  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">override</span>&nbsp;<span class="vem">def</span>&nbsp;toString&nbsp;=&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((amount.toDouble&nbsp;/&nbsp;CurrencyUnit.amount.toDouble)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatted&nbsp;(<span class="quotedstring">"%."</span>+&nbsp;decimals(CurrencyUnit.amount)&nbsp;+<span class="quotedstring">"f"</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+<span class="quotedstring">"&nbsp;"</span>+&nbsp;designation)
  &nbsp;&nbsp;}
  <br />  &nbsp;&nbsp;<span class="vem">val</span>&nbsp;<span class="typename">CurrencyUnit</span>:&nbsp;<span class="typename">Currency</span>
  }
</pre><!-- -->


<h5>Listing 20.14 - The full code of class <span class="code">CurrencyZone</span>.</h5>


<p>You can test the class in the Scala command shell. We'll assume that
the <span class="code">CurrencyZone</span> class and all concrete <span class="code">CurrencyZone</span> objects are
defined in a package <span class="code">org.stairwaybook.currencies</span>. The first step is to import
everything in this package into the command shell:
<pre>
  scala&gt;&nbsp;<span class="vem">import</span>&nbsp;org.stairwaybook.currencies._
</pre><!-- -->
You can then do some currency conversions:
<pre>
  scala&gt;&nbsp;<span class="typename">Japan.Yen</span>&nbsp;from&nbsp;<span class="typename">US.Dollar</span>&nbsp;*&nbsp;<span class="literal">100</span>
  <span class="output">res16:&nbsp;Japan.Currency&nbsp;=&nbsp;12110&nbsp;JPY</span>
  <br />  scala&gt;&nbsp;<span class="typename">Europe.Euro</span>&nbsp;from&nbsp;res16
  <span class="output">res17:&nbsp;Europe.Currency&nbsp;=&nbsp;75.95&nbsp;EUR</span>
  <br />  scala&gt;&nbsp;<span class="typename">US.Dollar</span>&nbsp;from&nbsp;res17
  <span class="output">res18:&nbsp;US.Currency&nbsp;=&nbsp;99.95&nbsp;USD</span>
</pre><!-- -->
The fact that we obtain almost the same amount after three conversions
implies that these are some pretty good exchange rates!</p>

<p>You can also add up values of the same currency:
<pre>
  scala&gt;&nbsp;<span class="typename">US.Dollar</span>&nbsp;*&nbsp;<span class="literal">100</span>&nbsp;+&nbsp;res18
  <span class="output">res19:&nbsp;currencies.US.Currency&nbsp;=&nbsp;199.95</span>
</pre><!-- -->
On the other hand, you cannot add amounts of different currencies:<a id="i-677980410-6"></a>
<pre>
  scala&gt;&nbsp;<span class="typename">US.Dollar</span>&nbsp;+&nbsp;<span class="typename">Europe.Euro</span>
  <span class="output">&lt;console&gt;:7:&nbsp;error:&nbsp;type&nbsp;mismatch;</span>
  <span class="output">&nbsp;found&nbsp;&nbsp;&nbsp;:&nbsp;currencies.Europe.Euro</span>
  <span class="output">&nbsp;required:&nbsp;currencies.US.Currency</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;US.Dollar&nbsp;+&nbsp;Europe.Euro</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</span>
</pre><!-- --></p>

<p>By preventing the addition of two values with different units (in this case, currencies),
the type abstraction has done its job. It prevents us from performing
calculations that are unsound. Failures to convert correctly between
different units may seem like trivial bugs, but they have caused many
serious systems faults. An example is the crash of the
Mars Climate Orbiter spacecraft on September 23, 1999, which was caused
because one engineering team used metric units while another used
English units. If units had been coded in the same way as currencies
are coded in this chapter, this error would have been detected 
by a simple compilation run.
Instead, it caused the crash of the orbiter after a near ten-month voyage.</p>

<h3><a name="20.10"></a>20.10 Conclusion <span style="font-size: .5em">[<a href="abstract-members.html#20.10">link</a>]</span></h3>


<p>Scala offers systematic and very general support for object-oriented
abstraction. It enables you to not only abstract over methods, but
also over values, variables, and types.  This chapter has
shown how to take advantage of abstract members.  They support a simple
yet effective principle for systems structuring: when designing a
class, make everything that is not yet known into an abstract member.
The type system will then drive the development of your model, just as
you saw with the currency case study.  It does not matter whether the
unknown is a type, method, variable or value. In Scala, all of these
can be declared abstract.</p>

<hr/>
<h4>Footnotes for Chapter 20:</h4>


<p><a name="footnote20-1">[1]</a> 
There's some promising recent research on <span style="font-style:italic">virtual classes</span>, which 
would allow this, but virtual classes are not currently supported in Scala.</p>

<p><a name="footnote20-2">[2]</a> Scala uses rich wrappers,
described in <a href="basic-types-and-operations.html#sec:rich-wrappers">Section 5.9</a>, to make <span class="code">formatted</span>
available.</p>

<p><a name="footnote20-3">[3]</a> By the way, in case you think you're getting a bad deal on Japanese yen, the
exchange rates convert currencies based on their <span class="code">CurrencyZone</span> amounts. Thus, 1.211 is the exchange rate between US cents to Japanese yen.</p>



<br clear="all">
<p>
<center>
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/abstract-membersP.html">Print</a>&nbsp;| 
<a href="/pins1ed/type-parameterization.html">Previous</a>&nbsp;| 
<a href="/pins1ed/implicit-conversions-and-parameters.html">Next</a>
</div>
</center>
</div>
<hr width="100%" />
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br />
<br />
<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/custom">
<table border="0" bgcolor="#ffffff">
<tr><td nowrap="nowrap" valign="top" align="left" height="32">
<a href="http://www.google.com/">
<img src="http://www.google.com/logos/Logo_25wht.gif"
border="0" alt="Google"></img></a>
</td>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="Artima.com"></input>
<input type="text" name="q" size="31" maxlength="255" value=""></input>
<input type="submit" name="sa" value="Search"></input>
</td></tr>
<tr>
<td>&nbsp;</td>
<td nowrap="nowrap">
<font size="-1" color="#000000">
<input type="radio" name="sitesearch" value=""></input> Web
<input type="radio" name="sitesearch" value="Artima.com" checked="checked"></input>Artima.com
</font>&nbsp;&nbsp;
<input type="hidden" name="client" value="pub-3911176865765226"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:http://www.artima.com/images/artima150.gif;S:http://www.artima.com;FORID:1;"></input>
<input type="hidden" name="hl" value="en"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</center>
<div class="sp">
<div style="text-align: center">
<a href="http://www.artima.com/copyright.html">Copyright</a> &copy; 1996-2014 Artima, Inc. All Rights Reserved.</a> - <a href="http://www.artima.com/privacy.html">Privacy Policy</a> - <a href="http://www.artima.com/termsofuse.html">Terms of Use</a> - <a href="http://www.artima.com/advertising.html">Advertise with Us</a>
</div>
</div>
<br />
</body>
</html>
