<html>
<head>
<title>For Expressions Revisited</title>
<meta name="description" content="
" />
<meta name="keywords" content="scala" />
<meta name="author" content="Martin Odersky, Lex Spoon, and Bill Venners" />
<link rel="stylesheet" type="text/css" href="/artimapf.css" />
<link rel="shortcut icon" href="/favicon.ico" />
</head>
<body><table width="100%" cellspacing="0">
<tr>
<td align="left" valign="bottom">
<a href="/index.jsp"><img src="/images/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43" /></a>
</td>
</table>
<table width="100%" bgcolor="#333333">
<tr>
<td align="center">
<div class="ml">
<a href="/articles" class="hl">Articles</a>&nbsp;|
<a href="/news/index.jsp" class="hl">News</a>&nbsp;|
<a href="/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;|
<a href="/buzz/index.jsp" class="hl">Buzz</a>&nbsp;|
<a href="/shop/catalog" class="hl">Books</a>&nbsp;|
<a href="/forums/index.jsp" class="hl">Forums</a>
</div>
</td>
</tr>
</table>
<table width="100%" bgcolor="#AACCFF">
<tr>
<td align="center">
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/for-expressions-revisited.html">Screen Friendly Version</a>&nbsp;| 
<a href="/pins1ed/implementing-lists.html">Previous</a>&nbsp;| 
<a href="/pins1ed/extractors.html">Next</a>
</div>
</td>
</tr>
</table>
<BR>
<div class="vegies">
<div class="tc">
<span class="sts">Chapter 23 of Programming in Scala, First Edition</span><br />
<span class="ts">For Expressions Revisited</span><br />
<span class="as">by Martin Odersky, Lex Spoon, and Bill Venners</span><br />
<span class="pd">December 10, 2008</span><br />
</div>




<p><a href="working-with-lists.html">Chapter 16</a>
demonstrated that higher-order functions such as
<span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">filter</span> provide powerful
constructions for dealing with lists.  But sometimes the level of
abstraction required by these functions makes a program a bit hard to
understand. Here's an example. Say you are given a list of persons,
each defined as an instance of a class <span class="code">Person</span>. Class <span class="code">Person</span> 
has fields indicating the person's name, whether (s)he is male, 
and his/her children. Here's the class definition:
<pre>
  scala&gt;&nbsp;<span class="vem">case</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Person</span>(name:&nbsp;<span class="typename">String</span>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isMale:&nbsp;<span class="typename">Boolean</span>,&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children:&nbsp;<span class="typename">Person</span>*)
</pre><!-- -->
Here's a list of some sample <span class="code">person</span>s:
<pre>
  <span class="vem">val</span>&nbsp;lara&nbsp;=&nbsp;<span class="typename">Person</span>(<span class="quotedstring">"Lara"</span>,&nbsp;<span class="vem">false</span>)
  <span class="vem">val</span>&nbsp;bob&nbsp;=&nbsp;<span class="typename">Person</span>(<span class="quotedstring">"Bob"</span>,&nbsp;<span class="vem">true</span>)
  <span class="vem">val</span>&nbsp;julie&nbsp;=&nbsp;<span class="typename">Person</span>(<span class="quotedstring">"Julie"</span>,&nbsp;<span class="vem">false</span>,&nbsp;lara,&nbsp;bob)
  <span class="vem">val</span>&nbsp;persons&nbsp;=&nbsp;<span class="typename">List</span>(lara,&nbsp;bob,&nbsp;julie)
</pre><!-- -->
Now, say you want to find out the names of all pairs 
of mothers and their children in that list.
Using <span class="code">map</span>, <span class="code">flatMap</span> and <span class="code">filter</span>, you can formulate the following query:
<pre>
  scala&gt;&nbsp;persons&nbsp;filter&nbsp;(p&nbsp;=&gt;&nbsp;!p.isMale)&nbsp;flatMap&nbsp;(p&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p.children&nbsp;map&nbsp;(c&nbsp;=&gt;&nbsp;(p.name,&nbsp;c.name))))
  <span class="output">res5:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</span>
</pre><!-- -->
The query does its job, but it's not exactly trivial to write or understand.
Is there a simpler way? In fact, there is. Remember the <span class="code">for</span> expressions in 
<a href="builtin-control-structures.html#sec:for-expressions">Section 7.3</a><a id="i-207940604-3"></a>? Using a <span class="code">for</span> expression, the same example 
can be written as follows:
<pre>
  scala&gt;&nbsp;<span class="vem">for</span>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;<span class="vem">if</span>&nbsp;!p.isMale;&nbsp;c&nbsp;&lt;-&nbsp;p.children)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">yield</span>&nbsp;(p.name,&nbsp;c.name)
  <span class="output">res6:&nbsp;List[(String,&nbsp;String)]&nbsp;=&nbsp;List((Julie,Lara),</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;(Julie,Bob))</span>
</pre><!-- -->
The result of this expression is exactly the same as the 
result of the previous expression.  What's more, most readers of the code would likely find the <span class="code">for</span> expression
much clearer than the previous query, which used the higher-order
functions, <span class="code">map</span><a id="i-482121133-1"></a>,
<span class="code">flatMap</span><a id="i-1499753963-1"></a>, and
<span class="code">filter</span><a id="i-713351569-1"></a>.</p>

<p>However, the two queries are not as dissimilar as it might seem. In
fact, it turns out that the Scala compiler will translate the second
query into the first one. More generally, all <span class="code">for</span> expressions that
<span class="code">yield</span><a id="i-1534065145-1"></a> a result are translated by the compiler into combinations of
invocations of the higher-order methods <span class="code">map</span>, <span class="code">flatMap</span>, and
<span class="code">filter</span>. All <span class="code">for</span> loops without <span class="code">yield</span> are translated into a
smaller set of higher-order functions: just <span class="code">filter</span>
and <span class="code">foreach</span><a id="i-493461951-1"></a>.</p>

<p>In this chapter, you'll find out first about the precise rules of
writing <span class="code">for</span> expressions. After that, you'll see how they can make
combinatorial problems easier to solve. Finally, you'll learn how
<span class="code">for</span> expressions are translated, and how as a result, <span class="code">for</span> expressions can help you "grow" the
Scala language into new application domains.</p>

<h3><a name="23.1"></a>23.1 For expressions <span style="font-size: .5em">[<a href="for-expressions-revisited.html#23.1">link</a>]</span></h3>


<p>Generally, a <span class="code">for</span> expression is of the form:
<pre>
  <span class="vem">for</span>&nbsp;(&nbsp;<span style="font-style:italic">seq</span>&nbsp;)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>
</pre><!-- -->
Here, <span style="font-style:italic">seq</span> is a sequence of <span style="font-style:italic">generators</span>, <span style="font-style:italic">definitions</span> and
<span style="font-style:italic">filters</span>, with semicolons between successive elements.
An example is the <span class="code">for</span> expression:
<pre>
  <span class="vem">for</span>&nbsp;(p&nbsp;&lt;-&nbsp;persons;&nbsp;n&nbsp;=&nbsp;p.name;&nbsp;<span class="vem">if</span>&nbsp;(n&nbsp;startsWith&nbsp;<span class="quotedstring">"To"</span>))&nbsp;
  <span class="vem">yield</span>&nbsp;n
</pre><!-- -->
The <span class="code">for</span> expression above contains one generator, one definition, and one filter.
As mentioned in <a href="builtin-control-structures.html#sec:for-expressions">Section 7.3</a>, you can also enclose the sequence in braces instead of parentheses, then
the semicolons become optional:
<pre>
  <span class="vem">for</span>&nbsp;{
  &nbsp;&nbsp;p&nbsp;&lt;-&nbsp;persons&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;generator</span>
  &nbsp;&nbsp;n&nbsp;=&nbsp;p.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;definition</span>
  &nbsp;&nbsp;<span class="vem">if</span>&nbsp;(n&nbsp;startsWith&nbsp;<span class="quotedstring">"To"</span>)&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;filter</span>
  }&nbsp;<span class="vem">yield</span>&nbsp;n
</pre><!-- -->
A <span style="font-style:italic">generator</span> is of the form:<a id="i1422302298-1"></a>
<pre>
  <span style="font-style:italic">pat</span>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>
</pre><!-- -->
The expression <span style="font-style:italic">expr</span> typically returns a list, even though you will see
later that this can be generalized. The pattern <span style="font-style:italic">pat</span> gets matched
one-by-one against all elements of that list.<a id="i-1272952554-2"></a><a id="i371386352-2"></a> If the match succeeds, the 
variables in the pattern get bound to the corresponding parts of the element, 
just the way it is described in <a href="case-classes-and-pattern-matching.html">Chapter 15</a>.
But if the match fails, no <span class="code">MatchError</span> is thrown.<a id="i797126047-1"></a>
Instead, the element is simply discarded from the iteration.</p>

<p>In the most common case,
the pattern <span style="font-style:italic">pat</span> is just a variable <span style="font-style:italic">x</span>, as in
<span class="code"><span style="font-style:italic">x</span></span>&nbsp;<span class="code">&lt;-</span>&nbsp;<span class="code"><span style="font-style:italic">expr</span></span>. In that case,
the variable <span style="font-style:italic">x</span> simply iterates over all elements returned by <span style="font-style:italic">expr</span>.</p>

<p>A <span style="font-style:italic">definition</span> is of the form:
<pre>
  <span style="font-style:italic">pat</span>&nbsp;=&nbsp;<span style="font-style:italic">expr</span>
</pre><!-- -->
This definition binds the pattern <span style="font-style:italic">pat</span> to the value of <span style="font-style:italic">expr</span>.
So it has the same effect as a <span class="code">val</span> definition:
<pre>
  <span class="vem">val</span>&nbsp;<span style="font-style:italic">x</span>&nbsp;=&nbsp;<span style="font-style:italic">expr</span>
</pre><!-- -->
The most common case is again where the pattern is a simple variable <span class="code">x</span>, <i>e.g.</i>,
<span class="code"><span style="font-style:italic">x</span></span>&nbsp;<span class="code">=</span>&nbsp;<span class="code"><span style="font-style:italic">expr</span></span>. This defines <span style="font-style:italic">x</span> as a name for the value
<span style="font-style:italic">expr</span>.</p>

<p>A <span style="font-style:italic">filter</span> is of the form:
<pre>
  <span class="vem">if</span>&nbsp;<span style="font-style:italic">expr</span>
</pre><!-- -->
Here, <span style="font-style:italic">expr</span> is an expression of type <span class="code">Boolean</span>.<a id="i331566550-1"></a>
The filter drops from the iteration all elements for which <span style="font-style:italic">expr</span> returns <span class="code">false</span>.</p>

<p>Every <span class="code">for</span> expression starts with a generator. If there are several
generators in a <span class="code">for</span> expression, later generators vary more rapidly than
earlier ones. You can verify this easily with the following simple test:
<pre>
  scala&gt;&nbsp;<span class="vem">for</span>&nbsp;(x&nbsp;&lt;-&nbsp;<span class="typename">List</span>(<span class="literal">1</span>,&nbsp;<span class="literal">2</span>);&nbsp;y&nbsp;&lt;-&nbsp;<span class="typename">List</span>(<span class="quotedstring">"one"</span>,&nbsp;<span class="quotedstring">"two"</span>))&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">yield</span>&nbsp;(x,&nbsp;y)
  <span class="output">res0:&nbsp;List[(Int,&nbsp;java.lang.String)]&nbsp;=&nbsp;</span>
  <span class="output">&nbsp;&nbsp;List((1,one),&nbsp;(1,two),&nbsp;(2,one),&nbsp;(2,two))</span>
</pre><!-- --></p>

<h3><a name="23.2"></a>23.2 The n-queens problem <span style="font-size: .5em">[<a href="for-expressions-revisited.html#23.2">link</a>]</span></h3>


<p>A particularly suitable application area of <span class="code">for</span> expressions are
combinatorial puzzles. An example of such a puzzle is the 8-queens
problem: Given a standard chess-board, place eight queens such that no
queen is in check from any other (a queen can check another piece if
they are on the same column, row, or diagonal). To find a solution to
this problem, it's actually simpler to generalize it to chess-boards
of arbitrary size. Hence, the problem is to place <i>N</i> queens on a
chess-board of <i>N</i> \<i>times</i> <i>N</i> squares, where the size <i>N</i> is
arbitrary. We'll start numbering cells at one, so the upper-left cell
of an <i>N</i> \<i>times</i> <i>N</i> board has coordinate (1, 1), and the lower-right
cell has coordinate (<i>N</i>, <i>N</i>).</p>

<p>To solve the N-queens problem, note that you need to place a queen in
each row.  So you could place queens in successive rows, each time
checking that a newly placed queen is not in check from any other
queens that have already been placed. In the course of this search, it
might arrive that a queen that needs to be placed in row <i>k</i> would be
in check in all fields of that row from queens in row 1 to <i>k</i>-1. In
that case, you need to abort that part of the search in order to
continue with a different configuration of queens in columns 1 to
<i>k</i>-1.</p>

<p>An imperative solution to this problem would place queens one by one,
moving them around on the board. But it looks difficult to come up
with a scheme that really tries all possibilities.</p>

<p>A more functional approach represents a solution directly, as a value.
A solution consists of a list of coordinates, one for each queen
placed on the board.</p>

<p>Note, however, that a full solution can
not be found in a single step. It needs to be built up gradually, by
occupying successive rows with queens.</p>

<p>This suggests a recursive algorithm.  Assume you have already
generated all solutions of placing <i>k</i> queens on a board of size <i>N</i>
\<i>times</i> <i>N</i>, where <i>k</i> is less than <i>N</i>. Each such solution can be
presented by a list of length <i>k</i> of coordinates <span class="code">(row,</span>&nbsp;<span class="code">column)</span>,
where both row and column numbers range from 1 to <i>N</i>.  It's
convenient to treat these partial solution lists as stacks, where the
coordinates of the queen in row <i>k</i> come first in the list, followed
by the coordinates of the queen in row <i>k</i>-1, and so on. The bottom of
the stack is the coordinate of the queen placed in the first row of
the board.  All solutions together are represented as a list of
lists, with one element for each solution.</p>

<p>Now, to place the next queen in row <i>k</i>+1, generate all possible extensions
of each previous solution by one more queen. This yields another list
of solution lists, this time of length <i>k</i>+1. Continue the process
until you have obtained all solutions of the size of the chess-board <i>N</i>.
This algorithmic idea is embodied in function <span class="code">placeQueens</span> below:
<pre>
  <span class="vem">def</span>&nbsp;queens(n:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">List[List[(Int, Int)]]</span>&nbsp;=&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;placeQueens(k:&nbsp;<span class="typename">Int</span>):&nbsp;<span class="typename">List[List[(Int, Int)]]</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(k&nbsp;==&nbsp;<span class="literal">0</span>)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">List</span>(<span class="typename">List</span>())
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">else</span>&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">for</span>&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queens&nbsp;&lt;-&nbsp;placeQueens(k&nbsp;-&nbsp;<span class="literal">1</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column&nbsp;&lt;-&nbsp;<span class="literal">1</span>&nbsp;to&nbsp;n
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queen&nbsp;=&nbsp;(k,&nbsp;column)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;isSafe(queen,&nbsp;queens)&nbsp;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="vem">yield</span>&nbsp;queen&nbsp;::&nbsp;queens
  <br />  &nbsp;&nbsp;placeQueens(n)
  }
</pre><!-- -->
The outer function <span class="code">queens</span> in the program above simply calls <span class="code">placeQueens</span>
with the size of the board <span class="code">n</span> as its argument. The task of the function 
application <span class="code">placeQueens(k)</span> is to
generate all partial solutions of length <span class="code">k</span> in a list. Every element
of the list is one solution, represented by a list of length <span class="code">k</span>. So <span class="code">placeQueens</span> 
returns a list of lists.</p>

<p>If the parameter <span class="code">k</span> to <span class="code">placeQueens</span> is <span class="code">0</span>, this means that it needs
to generate all solutions of placing zero queens on zero rows. There
is exactly one such solution: place no queen at all. This is
represented as a solution by the empty list. So if <span class="code">k</span> is zero,
<span class="code">placeQueens</span> returns <span class="code">List(List())</span>, a list consisting of a single
element that is the empty list.  Note that this is quite different
from the empty list <span class="code">List()</span>. If <span class="code">placeQueens</span> returns <span class="code">List()</span>,
this means <span style="font-style:italic">no solutions</span>, instead of a single solution consisting
of no placed queens.</p>

<p>In the other case, where <span class="code">k</span> is not zero, all the work of
<span class="code">placeQueens</span> is done in a <span class="code">for</span> expression. The first generator of
that <span class="code">for</span> expression iterates through all solutions of placing <span class="code">k</span>&nbsp;<span class="code">-</span>&nbsp;<span class="code">1</span>
queens on the board. The second generator iterates through all
possible <span class="code">column</span>s on which the <span class="code">k</span>'th queen might be placed.  
The third part of the <span class="code">for</span> expression 
defines the newly considered <span class="code">queen</span> position to be the pair consisting of row
<span class="code">k</span> and each produced <span class="code">column</span>.
The fourth part of the <span class="code">for</span> expression is a filter which checks with
<span class="code">isSafe</span> whether the new queen is safe from check of all previous queens
(the definition of <span class="code">isSafe</span> will be discussed a bit later).</p>

<p>If the new queen is not in check from any other queens, it can form
part of a partial solution, so <span class="code">placeQueens</span> generates with 
<span class="code">queen</span>&nbsp;<span class="code">::</span>&nbsp;<span class="code">queens</span> a new solution. If the new queen is not safe from check,
the filter returns <span class="code">false</span>, so no solution is generated.</p>

<p>The only remaining bit is the <span class="code">isSafe</span> method, which is used to check whether a
given <span class="code">queen</span> is in check from any other element in a list of <span class="code">queens</span>. Here is its definition:
<pre>
  <span class="vem">def</span>&nbsp;isSafe(queen:&nbsp;(<span class="typename">Int</span>,&nbsp;<span class="typename">Int</span>),&nbsp;queens:&nbsp;<span class="typename">List[(Int, Int)]</span>)&nbsp;=&nbsp;
  &nbsp;&nbsp;queens&nbsp;forall&nbsp;(q&nbsp;=&gt;&nbsp;!inCheck(queen,&nbsp;q))
  <br />  <span class="vem">def</span>&nbsp;inCheck(q1:&nbsp;(<span class="typename">Int</span>,&nbsp;<span class="typename">Int</span>),&nbsp;q2:&nbsp;(<span class="typename">Int</span>,&nbsp;<span class="typename">Int</span>))&nbsp;=&nbsp;
  &nbsp;&nbsp;q1._1&nbsp;==&nbsp;q2._1&nbsp;||&nbsp;&nbsp;<span class="comment">//&nbsp;same&nbsp;row</span>
  &nbsp;&nbsp;q1._2&nbsp;==&nbsp;q2._2&nbsp;||&nbsp;&nbsp;<span class="comment">//&nbsp;same&nbsp;column</span>
  &nbsp;&nbsp;(q1._1&nbsp;-&nbsp;q2._1).abs&nbsp;==&nbsp;(q1._2&nbsp;-&nbsp;q2._2).abs&nbsp;<span class="comment">//&nbsp;on&nbsp;diagonal</span>
</pre><!-- -->
The <span class="code">isSafe</span> method expresses that a <span class="code">queen</span> is safe with respect to some other <span class="code">queens</span> if 
it is not in check from any other queen. The <span class="code">inCheck</span> method expresses that
queens <span class="code">q1</span> and <span class="code">q2</span> are mutually in check. It returns <span class="code">true</span> in one of three cases:</p>

<ol>
<li>If the two queens have the same row coordinate, 
</li>
<li>If the two queens have the same column coordinate, 
</li>
<li>If the two queens are on the same diagonal, <i>i.e.</i>, the difference between their rows and the difference between their columns are the same.
</li></ol>
The first case, that the two queens have the same row coordinate,
cannot happen in the application because <span class="code">placeQueens</span> already takes
care to place each queen in a different row.  So you could remove the
test without changing the functionality of the program as a whole.


<h3><a name="23.3"></a>23.3 Querying with <span class="code">for</span> expressions <span style="font-size: .5em">[<a href="for-expressions-revisited.html#23.3">link</a>]</span></h3>


<p><a name="sec:for-queries"></a></p>

<p>The <span class="code">for</span> notation is essentially equivalent to common operations of
database query languages<a id="i1851175608-1"></a>. For instance, say you are given a 
database named <span class="code">books</span>,<!-- --> represented as a list of books, where
<span class="code">Book</span> is defined as follows:
<pre>
  <span class="vem">case</span>&nbsp;<span class="vem">class</span>&nbsp;<span class="typename">Book</span>(title:&nbsp;<span class="typename">String</span>,&nbsp;authors:&nbsp;<span class="typename">String</span>*)
</pre><!-- -->
Here is a small example database, represented as an in-memory
list:<a id="i471924076-2"></a><a id="i-1712702061-2"></a><a id="i1109104818-1"></a><a id="i-601321358-1"></a><a id="i134333723-1"></a><a id="i875843663-1"></a><a id="i1916394333-2"></a><a id="i-1202190098-1"></a><a id="i1512661551-2"></a>
<pre>
  <span class="vem">val</span>&nbsp;books:&nbsp;<span class="typename">List[Book]</span>&nbsp;=
  &nbsp;&nbsp;<span class="typename">List</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">Book</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Structure&nbsp;and&nbsp;Interpretation&nbsp;of&nbsp;Computer&nbsp;Programs"</span>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Abelson,&nbsp;Harold"</span>,&nbsp;<span class="quotedstring">"Sussman,&nbsp;Gerald&nbsp;J."</span>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">Book</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Principles&nbsp;of&nbsp;Compiler&nbsp;Design"</span>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Aho,&nbsp;Alfred"</span>,&nbsp;<span class="quotedstring">"Ullman,&nbsp;Jeffrey"</span>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">Book</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Programming&nbsp;in&nbsp;Modula-2"</span>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Wirth,&nbsp;Niklaus"</span>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">Book</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Elements&nbsp;of&nbsp;ML&nbsp;Programming"</span>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Ullman,&nbsp;Jeffrey"</span>
  &nbsp;&nbsp;&nbsp;&nbsp;),
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="typename">Book</span>(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"The&nbsp;Java&nbsp;Language&nbsp;Specification"</span>,&nbsp;<span class="quotedstring">"Gosling,&nbsp;James"</span>,
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="quotedstring">"Joy,&nbsp;Bill"</span>,&nbsp;<span class="quotedstring">"Steele,&nbsp;Guy"</span>,&nbsp;<span class="quotedstring">"Bracha,&nbsp;Gilad"</span>
  &nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;)
</pre><!-- -->
Then, to find the titles of all books whose author's last name is "Gosling":
<pre>
  scala&gt;&nbsp;<span class="vem">for</span>&nbsp;(b&nbsp;&lt;-&nbsp;books;&nbsp;a&nbsp;&lt;-&nbsp;b.authors
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;a&nbsp;startsWith&nbsp;<span class="quotedstring">"Gosling"</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">yield</span>&nbsp;b.title
  <span class="output">res0:&nbsp;List[String]&nbsp;=&nbsp;List(The&nbsp;Java&nbsp;Language&nbsp;Specification)</span>
</pre><!-- -->
Or, to find the titles of all books that have the string "Program" in
their title:
<pre>
  scala&gt;&nbsp;<span class="vem">for</span>&nbsp;(b&nbsp;&lt;-&nbsp;books&nbsp;<span class="vem">if</span>&nbsp;(b.title&nbsp;indexOf&nbsp;<span class="quotedstring">"Program"</span>)&nbsp;&gt;=&nbsp;<span class="literal">0</span>)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">yield</span>&nbsp;b.title
  <span class="output">res4:&nbsp;List[String]&nbsp;=&nbsp;List(Structure&nbsp;and&nbsp;Interpretation&nbsp;of</span>
  <span class="output">&nbsp;&nbsp;Computer&nbsp;Programs,&nbsp;Programming&nbsp;in&nbsp;Modula-2,&nbsp;Elements</span>
  <span class="output">&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;ML&nbsp;Programming)</span>
</pre><!-- -->
Or, to find the names of all authors that have written at least two
books in the database:<!-- -->
<pre>
  scala&gt;&nbsp;<span class="vem">for</span>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<span class="vem">if</span>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<span class="vem">if</span>&nbsp;a1&nbsp;==&nbsp;a2)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">yield</span>&nbsp;a1
  <span class="output">res5:&nbsp;List[String]&nbsp;=&nbsp;List(Ullman,&nbsp;Jeffrey,&nbsp;Ullman,&nbsp;Jeffrey)</span>
</pre><!-- -->
The last solution is not yet perfect, because authors will appear
several times in the list of results.  You still need to remove
duplicate authors from result lists.  This can be achieved with the
following function:
<pre>
  scala&gt;&nbsp;<span class="vem">def</span>&nbsp;removeDuplicates[A](xs:&nbsp;<span class="typename">List[A]</span>):&nbsp;<span class="typename">List[A]</span>&nbsp;=&nbsp;{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">if</span>&nbsp;(xs.isEmpty)&nbsp;xs
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">else</span>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs.tail&nbsp;filter&nbsp;(x&nbsp;=&gt;&nbsp;x&nbsp;!=&nbsp;xs.head)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
  <span class="output">removeDuplicates:&nbsp;[A](List[A])List[A]</span>
  <br />  scala&gt;&nbsp;removeDuplicates(res5)
  res6:&nbsp;<span class="typename">List[java.lang.String]</span>&nbsp;=&nbsp;<span class="typename">List</span>(<span class="typename">Ullman</span>,&nbsp;<span class="typename">Jeffrey</span>)
</pre><!-- -->
It's worth noting that the last expression in method <span class="code">removeDuplicates</span>
can be equivalently expressed using a <span class="code">for</span> expression:
<pre>
  xs.head&nbsp;::&nbsp;removeDuplicates(
  &nbsp;&nbsp;<span class="vem">for</span>&nbsp;(x&nbsp;&lt;-&nbsp;xs.tail&nbsp;<span class="vem">if</span>&nbsp;x&nbsp;!=&nbsp;xs.head)&nbsp;<span class="vem">yield</span>&nbsp;x
  )
</pre><!-- --></p>

<h3><a name="23.4"></a>23.4 Translation of <span class="code">for</span> expressions <span style="font-size: .5em">[<a href="for-expressions-revisited.html#23.4">link</a>]</span></h3>


<p>Every <span class="code">for</span> expression can be expressed in terms of the three
higher-order functions <span class="code">map</span>, <span class="code">flatMap</span> and <span class="code">filter</span>.
This section describes the translation scheme, which is also used by the Scala compiler.</p>

<h4>Translating <span class="code">for</span> expressions with one generator</h4>


<p>First, assume you have a simple <span class="code">for</span> expression:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_2
</pre><!-- -->
where <i>x</i> is a variable. Such an expression is translated to:
<pre>
  <span style="font-style:italic">expr</span>_1.map(<i>x</i>&nbsp;=&gt;&nbsp;<span style="font-style:italic">expr</span>_2)
</pre><!-- --></p>

<h4>Translating <span class="code">for</span> expressions starting with a generator and a filter</h4>


<p>Now, consider <span class="code">for</span> expressions that combine a leading generator with some other
elements. A <span class="code">for</span> expression of the form:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1&nbsp;<span class="vem">if</span>&nbsp;<span style="font-style:italic">expr</span>_2)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3
</pre><!-- -->
is translated to:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1&nbsp;filter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<span style="font-style:italic">expr</span>_2))&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3
</pre><!-- -->
This translation gives another <span class="code">for</span> expression that is  
shorter by one element than the original, because an <span class="code">if</span> 
element is transformed into an application of <span class="code">filter</span> on the first
generator expression. The translation then continues with this second expression, 
so in the end you obtain:
<pre>
  <span style="font-style:italic">expr</span>_1&nbsp;filter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<span style="font-style:italic">expr</span>_2)&nbsp;map&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<span style="font-style:italic">expr</span>_3)
</pre><!-- -->
The same translation scheme also applies if there are further elements 
following the filter. If <span style="font-style:italic">seq</span> is an arbitrary sequence of generators,
definitions and filters, then:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1&nbsp;<span class="vem">if</span>&nbsp;<span style="font-style:italic">expr</span>_2;&nbsp;<span style="font-style:italic">seq</span>)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3
</pre><!-- -->
is translated to:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1&nbsp;filter&nbsp;<span style="font-style:italic">expr</span>_2;&nbsp;<span style="font-style:italic">seq</span>)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3
</pre><!-- -->
Then translation continues with the second expression, which is again shorter
by one element than the original one.</p>

<h4>Translating <span class="code">for</span> expressions starting with two generators</h4>


<p>The next case handles <span class="code">for</span> expressions that start with two filters, as in:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1;&nbsp;<i>y</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_2;&nbsp;<span style="font-style:italic">seq</span>)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3
</pre><!-- -->
Again, assume that <span style="font-style:italic">seq</span> is an arbitrary sequence of
generators, definitions and filters. In fact, <span style="font-style:italic">seq</span> might also be
empty, and in that case there would not be a semicolon after
<span class="code"><span style="font-style:italic">expr</span>_2</span>. The translation scheme stays the same in each case. The 
<span class="code">for</span> expression above is translated to an application of <span class="code">flatMap</span>:
<pre>
  <span style="font-style:italic">expr</span>_1.flatMap(<i>x</i>&nbsp;=&gt;&nbsp;<span class="vem">for</span>&nbsp;(<i>y</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_2;&nbsp;<span style="font-style:italic">seq</span>)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3)
</pre><!-- -->
This time, there is another <span class="code">for</span> expression in the function value passed to <span class="code">flatMap</span>.
That <span class="code">for</span> expression (which is again simpler by one element than the original)
is in turn translated with the same rules.</p>

<p>The three translation schemes given so far are sufficient to translate
all <span class="code">for</span> expressions that contain just generators and filters, and
where generators bind only simple variables. Take for instance the query, "find all authors 
who have published at least two books," from <a href="for-expressions-revisited.html#sec:for-queries">Section 23.3</a>:
<pre>
  <span class="vem">for</span>&nbsp;(b1&nbsp;&lt;-&nbsp;books;&nbsp;b2&nbsp;&lt;-&nbsp;books&nbsp;<span class="vem">if</span>&nbsp;b1&nbsp;!=&nbsp;b2;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1&nbsp;&lt;-&nbsp;b1.authors;&nbsp;a2&nbsp;&lt;-&nbsp;b2.authors&nbsp;<span class="vem">if</span>&nbsp;a1&nbsp;==&nbsp;a2)
  <span class="vem">yield</span>&nbsp;a1
</pre><!-- -->
This query translates to the following <span class="code">map</span>/<span class="code">flatMap</span>/<span class="code">filter</span> combination:
<pre>
  books&nbsp;flatMap&nbsp;(b1&nbsp;=&gt;
  &nbsp;&nbsp;books&nbsp;filter&nbsp;(b2&nbsp;=&gt;&nbsp;b1&nbsp;!=&nbsp;b2)&nbsp;flatMap&nbsp;(b2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;b1.authors&nbsp;flatMap&nbsp;(a1&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2.authors&nbsp;filter&nbsp;(a2&nbsp;=&gt;&nbsp;a1&nbsp;==&nbsp;a2)&nbsp;map&nbsp;(a2&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a1))))
</pre><!-- -->
The translation scheme presented so far does not yet handle generators
that that bind whole patterns instead of simple variables.  It also
does not yet cover definitions. These two aspects will be explained in
the next two sub-sections.</p>

<h4>Translating patterns in generators</h4>


<p>The translation scheme becomes more complicated if the left hand side
of generator is a pattern, <span style="font-style:italic">pat</span>, other than a simple variable. 
Still relatively easy to handle is the case where the <span class="code">for</span> expression binds a tuple of
variables. In that case, almost the same scheme as for single variables applies.
A <span class="code">for</span> expression of the form:</p>

<pre>
  <span class="vem">for</span>&nbsp;((<i>x_1</i>,&nbsp;...,&nbsp;<i>x_n</i>)&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_2
</pre><!-- -->
translates to:
<pre>
  <span style="font-style:italic">expr</span>_1.map&nbsp;{&nbsp;<span class="vem">case</span>&nbsp;(<i>x_1</i>,&nbsp;...,&nbsp;<i>x_n</i>)&nbsp;=&gt;&nbsp;<span style="font-style:italic">expr</span>_2&nbsp;}
</pre><!-- -->
Things become a bit more involved if the left hand side of the generator
is an arbitrary pattern <span style="font-style:italic">pat</span> instead of a single variable or a tuple. 
In this case:
<pre>
  <span class="vem">for</span>&nbsp;(<span style="font-style:italic">pat</span>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_2
</pre><!-- -->
translates to:
<pre>
  <span style="font-style:italic">expr</span>_1&nbsp;filter&nbsp;{
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;<span style="font-style:italic">pat</span>&nbsp;=&gt;&nbsp;<span class="vem">true</span>
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;_&nbsp;=&gt;&nbsp;<span class="vem">false</span>
  }&nbsp;map&nbsp;{&nbsp;
  &nbsp;&nbsp;<span class="vem">case</span>&nbsp;<span style="font-style:italic">pat</span>&nbsp;=&gt;&nbsp;<span style="font-style:italic">expr</span>_2
  }
</pre><!-- -->
That is, the generated items are first filtered and
only those that match <span style="font-style:italic">pat</span> are mapped. Therefore, it's guaranteed
that a pattern-matching generator will never throw a <span class="code">MatchError</span><a id="i797126047-2"></a>


<p>The scheme above only treated the case where the <span class="code">for</span> expression
contains a single pattern-matching generator. Analogous rules apply if
the <span class="code">for</span> expression contains other generators, filters, or
definitions. Because these additional rules don't add much new
insight, they are omitted from discussion here. If you are interested,<!-- -->
you can look them up in the <em>Scala Language Specification</em> <a href="bibliography.html#sls">sls</a>.</p>

<h4>Translating definitions</h4>


<p>The last missing situation is where a <span class="code">for</span> expression contains embedded
definitions.  Here's a typical case:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1;&nbsp;<i>y</i>&nbsp;=&nbsp;<span style="font-style:italic">expr</span>_2;&nbsp;<span style="font-style:italic">seq</span>)&nbsp;<span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3
</pre><!-- -->
Assume again that <span style="font-style:italic">seq</span> is a (possibly empty) sequence of generators, definitions, and filters.
This expression is translated to the following one: 
<pre>
  <span class="vem">for</span>&nbsp;((<i>x</i>,&nbsp;<i>y</i>)&nbsp;&lt;-&nbsp;<span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1)&nbsp;<span class="vem">yield</span>&nbsp;(<i>x</i>,&nbsp;<span style="font-style:italic">expr</span>_2);&nbsp;<span style="font-style:italic">seq</span>)&nbsp;
  <span class="vem">yield</span>&nbsp;<span style="font-style:italic">expr</span>_3
</pre><!-- -->
So you see that <span class="code"><span style="font-style:italic">expr</span>_2</span> is evaluated each time there is a new <i>x</i> value being generated.
This re-evaluation is necessary, because <span class="code"><span style="font-style:italic">expr</span>_2</span> might refer to <i>x</i> and so needs
to be re-evaluated for changing values of <i>x</i>. For you as a programmer
the conclusion is that it's probably not a good idea to have definitions
embedded in <span class="code">for</span> expressions that do not refer to variables bound by some 
preceding generator, because re-evaluating such expressions would be wasteful.
For instance, instead of:
<pre>
  <span class="vem">for</span>&nbsp;(x&nbsp;&lt;-&nbsp;<span class="literal">1</span>&nbsp;to&nbsp;<span class="literal">1000</span>;&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX)
  <span class="vem">yield</span>&nbsp;x&nbsp;*&nbsp;y
</pre><!-- -->
it's usually better to write:
<pre>
  <span class="vem">val</span>&nbsp;y&nbsp;=&nbsp;expensiveComputationNotInvolvingX
  <span class="vem">for</span>&nbsp;(x&nbsp;&lt;-&nbsp;<span class="literal">1</span>&nbsp;to&nbsp;<span class="literal">1000</span>)&nbsp;<span class="vem">yield</span>&nbsp;x&nbsp;*&nbsp;y
</pre><!-- --></p>

<h4>Translating <span class="code">for</span> loops</h4>


<p>The previous subsections showed how <span class="code">for</span> expressions that
contain a <span class="code">yield</span> are translated.<a id="i-382847944-1"></a> What about <span class="code">for</span> loops that simply
perform a side effect without returning anything? Their translation is
similar, but simpler than <span class="code">for</span> expressions. In principle, wherever the
previous translation scheme used a <span class="code">map</span> or a <span class="code">flatMap</span> in the
translation, the translation scheme for <span class="code">for</span> loops uses just a <span class="code">foreach</span>.
For instance, the expression:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1)&nbsp;<span style="font-style:italic">body</span>
</pre><!-- -->
translates to:
<pre>
  <span style="font-style:italic">expr</span>_1&nbsp;foreach&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<span style="font-style:italic">body</span>)
</pre><!-- -->
A larger example is the expression:
<pre>
  <span class="vem">for</span>&nbsp;(<i>x</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_1;&nbsp;<span class="vem">if</span>&nbsp;<span style="font-style:italic">expr</span>_2;&nbsp;<i>y</i>&nbsp;&lt;-&nbsp;<span style="font-style:italic">expr</span>_3)&nbsp;<span style="font-style:italic">body</span>
</pre><!-- -->
This expression translates to:
<pre>
  <span style="font-style:italic">expr</span>_1&nbsp;filter&nbsp;(<i>x</i>&nbsp;=&gt;&nbsp;<span style="font-style:italic">expr</span>_2)&nbsp;foreach&nbsp;(<i>x</i>&nbsp;=&gt;
  &nbsp;&nbsp;<span style="font-style:italic">expr</span>_3&nbsp;foreach&nbsp;(<i>y</i>&nbsp;=&gt;&nbsp;<span style="font-style:italic">body</span>))
</pre><!-- -->
For example, the following expression sums up all elements of a
matrix represented as a list of lists:
<pre>
  <span class="vem">var</span>&nbsp;sum&nbsp;=&nbsp;<span class="literal">0</span>
  <span class="vem">for</span>&nbsp;(xs&nbsp;&lt;-&nbsp;xss;&nbsp;x&nbsp;&lt;-&nbsp;xs)&nbsp;sum&nbsp;+=&nbsp;x
</pre><!-- -->
This loop is translated into two nested <span class="code">foreach</span> applications:
<pre>
  <span class="vem">var</span>&nbsp;sum&nbsp;=&nbsp;<span class="literal">0</span>
  xss&nbsp;foreach&nbsp;(xs&nbsp;=&gt;&nbsp;
  &nbsp;&nbsp;xs&nbsp;foreach&nbsp;(x&nbsp;=&gt;
  &nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;x))
</pre><!-- --></p>

<h3><a name="23.5"></a>23.5 Going the other way <span style="font-size: .5em">[<a href="for-expressions-revisited.html#23.5">link</a>]</span></h3>


<p>The previous section showed that <span class="code">for</span> expressions can be translated
into applications of the higher-order functions <span class="code">map</span>, <span class="code">flatMap</span>,
and <span class="code">filter</span>.  In fact, you could equally well go the other way:
every application of a <span class="code">map</span>, <span class="code">flatMap</span>, or <span class="code">filter</span> 
can be represented as a <span class="code">for</span> expression. Here are implementations of
the three methods in terms of <span class="code">for</span> expressions. The methods are contained
in an object <span class="code">Demo</span>, to distinguish them from the standard operations
on <span class="code">List</span>s. To be concrete, the three functions all take a <span class="code">List</span> as parameter, but the translation
scheme would work just as well with other collection types:
<pre>
  <span class="vem">object</span>&nbsp;<span class="typename">Demo</span>&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;map[A,&nbsp;B](xs:&nbsp;<span class="typename">List[A]</span>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;<span class="typename">List[B]</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">for</span>&nbsp;(x&nbsp;&lt;-&nbsp;xs)&nbsp;<span class="vem">yield</span>&nbsp;f(x)
  <br />  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;flatMap[A,&nbsp;B](xs:&nbsp;<span class="typename">List[A]</span>,&nbsp;f:&nbsp;A&nbsp;=&gt;&nbsp;<span class="typename">List[B]</span>):&nbsp;<span class="typename">List[B]</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">for</span>&nbsp;(x&nbsp;&lt;-&nbsp;xs;&nbsp;y&nbsp;&lt;-&nbsp;f(x))&nbsp;<span class="vem">yield</span>&nbsp;y
  <br />  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;filter[A](xs:&nbsp;<span class="typename">List[A]</span>,&nbsp;p:&nbsp;A&nbsp;=&gt;&nbsp;<span class="typename">Boolean</span>):&nbsp;<span class="typename">List[A]</span>&nbsp;=
  &nbsp;&nbsp;&nbsp;&nbsp;<span class="vem">for</span>&nbsp;(x&nbsp;&lt;-&nbsp;xs&nbsp;<span class="vem">if</span>&nbsp;p(x))&nbsp;<span class="vem">yield</span>&nbsp;x
  }
</pre><!-- -->
Not surprisingly, the translation of the <span class="code">for</span> expression used in the body of
<span class="code">Demo.map</span> will produce a call to <span class="code">map</span> in class <span class="code">List</span>.
Similarly, <span class="code">Demo.flatMap</span> and <span class="code">Demo.filter</span> translate to
<span class="code">flatMap</span> and <span class="code">filter</span> in class <span class="code">List</span>.</p>

<p>So this little demonstration has shown that <span class="code">for</span> expressions really are
equivalent in their expressiveness to applications of the three
functions <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">filter</span>.</p>

<h3><a name="23.6"></a>23.6 Generalizing <span class="code">for</span> <span style="font-size: .5em">[<a href="for-expressions-revisited.html#23.6">link</a>]</span></h3>


<p>Because the translation of <span class="code">for</span> expressions only relies on
the presence of methods <span class="code">map</span>, <span class="code">flatMap</span>, and
<span class="code">filter</span>, it is possible to apply the <span class="code">for</span> notation 
to a large class of data types.</p>

<p>You have already seen <span class="code">for</span> expressions over lists and arrays.  These
are supported because lists, as well as arrays, define operations
<span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">filter</span>. Because they define a <span class="code">foreach</span> method as well, <span class="code">for</span> loops
over these data types are also possible.</p>

<p>Besides lists and arrays, there are also many other types in the Scala
standard library that support the same four methods and therefore
allow <span class="code">for</span> expressions. Examples are ranges, iterators, streams, and
all implementations of sets.<a id="i-47073124-1"></a> It's also perfectly possible for your own
data types to support <span class="code">for</span> expressions by defining the necessary
methods. To support the full range of <span class="code">for</span> expressions and <span class="code">for</span> loops,
you need to define <span class="code">map</span>, <span class="code">flatMap</span>, <span class="code">filter</span>, and <span class="code">foreach</span> as
methods of your data type. But it's also possible to define a subset
of these methods, and thereby support a subset of all possible
<span class="code">for</span> expressions or loops. Here are the precise rules:</p>

<ul>
<li>
If your type defines just <span class="code">map</span>, it allows <span class="code">for</span> expressions 
consisting of a single generator.
</li>
<li>
If it defines <span class="code">flatMap</span> as well as <span class="code">map</span>, it allows <span class="code">for</span> expressions
consisting of several generators.
</li>
<li>
If it defines <span class="code">foreach</span>, it allows <span class="code">for</span> loops (both with single and multiple generators).
</li>
<li>
If it defines <span class="code">filter</span>, it allows for 
filter expressions starting with an <span class="code">if</span> in
the <span class="code">for</span> expression.
</li></ul>
The translation of <span class="code">for</span> expressions happens before type
checking.<a id="i-1430360982-1"></a><a id="i746576009-1"></a> This
allows for maximal flexibility, because it is only required that the
result of expanding a <span class="code">for</span> expression type checks. Scala defines no
typing rules for the <span class="code">for</span> expressions themselves, and does not require
<span class="code">map</span>, <span class="code">flatMap</span>, <span class="code">filter</span>, or <span class="code">foreach</span> to have any particular
type signatures.


<p>Nevertheless, there is a typical setup that captures the most
common intention of the higher order methods to which <span class="code">for</span> expressions translate. 
Say you have a
parameterized class, <span class="code">C</span>, which typically would stand for some sort of
collection. Then it's quite natural to pick the following type signatures 
for <span class="code">map</span>, <span class="code">flatMap</span>, <span class="code">filter</span>, and <span class="code">foreach</span>:<!-- -->
<pre>
  <span class="vem">abstract</span>&nbsp;<span class="vem">class</span>&nbsp;C[A]&nbsp;{
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;map[B](f:&nbsp;A&nbsp;=&gt;&nbsp;B):&nbsp;C[B]
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;flatMap[B](f:&nbsp;A&nbsp;=&gt;&nbsp;C[B]):&nbsp;C[B]
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;filter(p:&nbsp;A&nbsp;=&gt;&nbsp;<span class="typename">Boolean</span>):&nbsp;C[A]
  &nbsp;&nbsp;<span class="vem">def</span>&nbsp;foreach(b:&nbsp;A&nbsp;=&gt;&nbsp;<span class="typename">Unit</span>):&nbsp;<span class="typename">Unit</span>
  }
</pre><!-- -->
That is, the <span class="code">map</span> function takes a function from the collection's
element type <span class="code">A</span> to some other type <span class="code">B</span>. It produces a new
collection of the same kind <span class="code">C</span>, but with <span class="code">B</span> as the element type.
The <span class="code">flatMap</span> method takes a function <span class="code">f</span> from <span class="code">A</span> to some
<span class="code">C</span>-collection of <span class="code">B</span>s and produces a <span class="code">C</span>-collection of
<span class="code">B</span>s.  The <span class="code">filter</span> method takes a predicate function from the
collection's element type <span class="code">A</span> to <span class="code">Boolean</span>. It produces a collection
of the same type as the one on which it is invoked.  Finally, the
<span class="code">foreach</span> method takes a function from <span class="code">A</span> to <span class="code">Unit</span>, and produces
a <span class="code">Unit</span> result.</p>

<p>Concentrating on just the first three functions, the following facts
are noteworthy. In functional programming, there's a general concept
called a <span style="font-style:italic">monad</span>, which can explain a large number of types with computations,
ranging from collections, to computations with state and I/O,
backtracking computations, and transactions, to name but a
few.<a id="i-1068505564-1"></a> You can
formulate functions <span class="code">map</span>, <span class="code">flatMap</span>, and <span class="code">filter</span> on a monad, and,
if you do, they end up having exactly the types given
above. Furthermore, you can characterize every monad by <span class="code">map</span>,
<span class="code">flatMap</span>, and <span class="code">filter</span>, plus a "unit" constructor that produces a
monad from an element value. In an object-oriented language, this "unit"
constructor is simply an instance constructor or a factory method.
Therefore, <span class="code">map</span>, <span class="code">flatMap</span> and <span class="code">filter</span> can be seen as an
object-oriented version of the functional concept of monad.  Because
<span class="code">for</span> expressions are equivalent to applications of these three methods,
they can be seen as syntax for monads.</p>

<p>All this suggests that the concept of <span class="code">for</span> expression is something more
general than just iteration over a collection, and indeed it is. For
instance, <span class="code">for</span> expressions also play an important role in asynchronous
I/O, or as an alternative notation for optional values.
Watch out in the Scala libraries for occurrences of <span class="code">map</span>,
<span class="code">flatMap</span>, and <span class="code">filter</span>&mdash;wherever they are present,
<span class="code">for</span> expressions suggest themselves as a concise way of manipulating
elements of the type.</p>

<h3><a name="23.7"></a>23.7 Conclusion <span style="font-size: .5em">[<a href="for-expressions-revisited.html#23.7">link</a>]</span></h3>


<p>In this chapter, you were given a peek under the hood of
<span class="code">for</span> expressions and <span class="code">for</span> loops. You learned that they translate
into applications of a standard set of higher-order methods. As a
consequence of this, you saw that <span class="code">for</span> expressions are really
much more general than mere iterations over collections, and that you
can design your own classes to support them.</p>



<p>
<center>
<div class="sc">
<a href="/pins1ed/index.html">Top</a>&nbsp;| 
<a href="/pins1ed/index.html#TOC">Table of Contents</a>&nbsp;| 
<a href="/pins1ed/glossary.html">Glossary</a>&nbsp;| 
<a href="/pins1ed/book-index.html">Index</a>&nbsp;| 
<a href="/pins1ed/for-expressions-revisited.html">Screen Friendly Version</a>&nbsp;| 
<a href="/pins1ed/implementing-lists.html">Previous</a>&nbsp;| 
<a href="/pins1ed/extractors.html">Next</a>
</div>
</center>
</div>
<hr width="100%" />
<div class="sp">
<div style="text-align: center">
<a href="http://www.artima.com/copyright.html">Copyright</a> &copy; 1996-2014 Artima, Inc. All Rights Reserved.</a> - <a href="http://www.artima.com/privacy.html">Privacy Policy</a> - <a href="http://www.artima.com/termsofuse.html">Terms of Use</a> - <a href="http://www.artima.com/advertising.html">Advertise with Us</a>
</div>
</div>
<br />
</body>
</html>
